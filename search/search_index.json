{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Automation for maintaining long-lived forks</p>"},{"location":"#the-challenge","title":"The Challenge","text":"<p>Managing long-lived forks of OSDU repositories is complex. Organizations need to balance upstream compatibility with proprietary implementations while avoiding integration overhead, release delays, and community divergence.</p> <p>Traditional manual approaches are error-prone and resource-intensive.</p>"},{"location":"#the-solution","title":"The Solution","text":"<p>Complete automation framework for enterprise fork management:</p> <p> Smart Synchronization</p> <p>Automated daily upstream integration with AI-enhanced conflict detection and resolution guidance.   </p> <p> Three-Branch Strategy</p> <p>Proven branching strategy that isolates changes at each stage, preventing cascade failures.   </p> <p> AI Automation</p> <p>Intelligent analysis with automated commit messages, PR descriptions, and conflict categorization.   </p> <p> Enterprise Security</p> <p>Built-in vulnerability scanning, compliance checks, and branch protection rules.   </p>"},{"location":"#key-benefits","title":"Key Benefits","text":"<p> 90% reduction in manual integration work Automated conflict detection with AI guidance Enterprise security and compliance built-in Zero-configuration template deployment  </p>"},{"location":"concepts/","title":"Concepts","text":"<p>The Open Subsurface Data Universe (OSDU) project presents a fundamental architectural challenge for cloud providers who need to maintain both open-source compatibility and proprietary cloud-specific implementations. This challenge centers on the effective separation and management of Service Provider Interface (SPI) code.</p> <p>OSDU defines a structured architecture where community standards must remain separate from cloud-specific implementations. The diagram below illustrates how Microsoft maintains this separation through forking:</p> <pre><code>graph TB\n    subgraph Community[\"OSDU Community Repository - Upstream\"]\n        A1[API] --- B1[Core Code] --- C1[SPI Interface] --- D1[Community Implementation]\n    end\n\n    Community --&gt;|Synced Fork| Fork\n\n    subgraph Fork[\"Azure SPI Repository\"]\n        A2[API] --- B2[Core Code] --- C2[SPI Interface] --- D2[Azure Implementation]\n    end\n\n    style Community fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style Fork fill:#e3f2fd,stroke:#1565c0,stroke-width:2px\n    style C1 fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style C2 fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style D1 fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    style D2 fill:#e3f2fd,stroke:#1565c0,stroke-width:2px</code></pre> <p>The SPI Interface (highlighted in orange) serves as the critical boundary where community-defined standards meet cloud-specific implementations. Everything to the left must stay synchronized with upstream, while only the implementation layer (rightmost) contains Azure-specific code.</p> <p> Open Source Components include OSDU core interfaces, community-validated business logic, standard data models, and reference implementations for testing.</p> <p> Azure-Specific Components encompass Azure SPI layer implementations, Azure-native service integrations, proprietary optimizations, and Microsoft-specific configuration and deployment patterns.</p> <p>The Separation Challenge</p> <p>Microsoft must maintain clear boundaries between open-source OSDU core components and Azure-specific SPI implementations, while ensuring both remain compatible and current with upstream community standards.</p>"},{"location":"concepts/#the-fork-management-problem","title":"The Fork Management Problem","text":"<p>Maintaining long-lived forks of upstream OSDU repositories creates several critical challenges that compound in enterprise environments:</p> <p> Integration Complexity</p> <p>Manual synchronization with upstream changes requires significant engineering effort, particularly when upstream modifications affect interfaces that Azure SPI implementations depend upon.   </p> <p> Divergence Risk</p> <p>Over time, local modifications can diverge significantly from upstream standards, making integration increasingly difficult and potentially compromising compatibility.   </p> <p> Blocking Dependencies</p> <p>Under traditional approaches, compilation or testing failures in any Cloud Provider's SPI implementation could block merging changes to main branches, creating dependencies between unrelated provider implementations.   </p> <p> Release Coordination</p> <p>Correlating fork versions with upstream releases becomes complex without systematic tracking and version management.   </p> <p>Enterprise Compounding Effects</p> <p>These challenges multiply in enterprise environments where quarterly planning cycles cannot accommodate unpredictable upstream changes, teams require different workflows for upstream vs. proprietary code, compliance demands complete audit trails, and multiple downstream systems depend on stable, predictable releases.</p> <p>Traditional vs. Automated Approach</p> Aspect Traditional Fork Management Automated Solution Synchronization Manual, error-prone, weekly/monthly Automated daily with conflict detection Conflict Resolution Ad-hoc, blocking, expertise-dependent AI-enhanced guidance, isolated resolution Release Coordination Manual tracking, version drift risk Automatic correlation with upstream tags Integration Testing After conflicts resolved Continuous validation at each stage Team Productivity 40% time on integration overhead 90% reduction in manual integration work Risk Management Reactive, cascade failures possible Proactive, isolated failure containment"},{"location":"concepts/#the-automation-solution","title":"The Automation Solution","text":"<p>The fork management system implements controlled isolation through a three-branch strategy that separates concerns while maintaining automation throughout the integration process.</p> <p>Success Pattern: Three-Branch Strategy</p> <p>The key insight is controlled isolation - changes flow through <code>fork_upstream</code> \u2192 <code>fork_integration</code> \u2192 <code>main</code> with validation at each stage, preventing cascade failures while enabling systematic integration.</p> <pre><code>graph TD\n    A[OSDU Community Repository - Upstream]\n    A --&gt;|Fork| B\n\n    subgraph Azure[\"Azure SPI Repository\"]\n        B[fork_upstream&lt;br/&gt;Mirror]\n        B --&gt; C[fork_integration&lt;br/&gt;Conflict Resolution]\n        C --&gt; D[main&lt;br/&gt;Azure SPI Ready]\n    end\n\n    style A fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style Azure fill:#e3f2fd,stroke:#1565c0,stroke-width:2px\n    style B fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style C fill:#fce4ec,stroke:#c2185b,stroke-width:2px\n    style D fill:#e3f2fd,stroke:#1565c0,stroke-width:2px</code></pre> <p>Automated Workflow Capabilities:</p> <p> Upstream Synchronization</p> <ul> <li>Scheduled pulls from upstream repositories</li> <li>Automated conflict detection and categorization  </li> <li>AI enhanced analysis of change impacts   </li> </ul> <p> Conflict Management</p> <ul> <li>Isolated resolution environment in <code>fork_integration</code></li> <li>Guided resolution with generated instructions</li> <li>Testing validation before production integration   </li> </ul> <p> Release Coordination</p> <ul> <li>Automatic correlation with upstream version tags</li> <li>Semantic versioning aligned with upstream releases</li> <li>Clear change documentation and impact analysis   </li> </ul> <p>AI Enhanced Development Support leverages multiple AI providers for intelligent analysis, automated impact assessment, step-by-step conflict resolution guidance, and generated commit messages and PR descriptions through custom agent integration.</p>"},{"location":"concepts/#why-this-matters","title":"Why This Matters","text":"<p>This automated fork management approach delivers significant operational and strategic value across development teams, operations, and enterprise architecture.</p> <p>Key Impact Areas</p> <p>Teams achieve a major reduction in manual integration work while maintaining full compatibility with upstream OSDU community standards. This enables focus on innovation rather than integration overhead.</p> Strategic ValueDevelopment TeamsOperations Teams <p> Separation of Concerns <p>Clear boundaries between open-source and proprietary development enable teams to optimize for their specific technical contexts without compromising either approach.   </p> <p> Scalable Automation <p>Template-based deployment supports unlimited fork instances with consistent automation patterns, enabling expansion across multiple OSDU repository forks.   </p> <p> Future-Proof Architecture <p>The system's design accommodates evolving upstream requirements and changing cloud provider strategies without requiring fundamental architectural changes.    </p> <p> Focus on Innovation <p>Teams spend time on Azure SPI enhancements rather than integration overhead, accelerating feature delivery and reducing context switching between upstream and proprietary development contexts.   </p> <p> Reduced Technical Debt <p>Systematic upstream integration prevents accumulation of compatibility issues, maintaining code quality and reducing maintenance burden through predictable automation.   </p> <p> Predictable Planning <p>Automated handling of routine integration tasks enables more reliable sprint planning and feature roadmap execution with fewer unexpected disruptions.    </p> <p> Enhanced Compliance <p>Complete audit trails and automated security scanning ensure regulatory requirements are consistently met throughout the integration process.   </p> <p> Reliable Delivery <p>Structured release correlation provides predictable, stable delivery points for downstream systems like Azure Data Manager for Energy (ADME).   </p> <p> Risk Mitigation <p>Early conflict detection and isolated resolution prevent integration issues from impacting production systems through controlled isolation patterns.    </p>"},{"location":"adr/","title":"Architecture Decision Records","text":"<p>This catalog documents the architectural choices that shape the OSDU SPI Fork Management system. Each ADR captures the context, rationale, and consequences of significant design choices that enable automated management of long-lived upstream forks.</p> <p>Impact Levels</p> <p> Critical - Fundamental to system operation; changes require careful migration planning</p> <p> High - Significant workflow effects; changes affect multiple components</p> <p> Medium - Localized improvements; changes have bounded effects</p>"},{"location":"adr/#catalog","title":"Catalog","text":""},{"location":"adr/#foundation-core-architecture","title":"Foundation &amp; Core Architecture","text":"<p>\"What are the fundamental design choices?\"</p> <p>Foundation decisions that define the system's structure and approach:</p> ADR Decision Impact Status 001 Three-Branch Strategy  Critical  Accepted 002 GitHub Actions Automation  Critical  Accepted 003 Template Repository Pattern  Critical  Accepted"},{"location":"adr/#repository-initialization-setup","title":"Repository Initialization &amp; Setup","text":"<p>\"How do I create and configure a new fork?\"</p> <p>Decisions governing repository initialization, configuration, and security setup:</p> ADR Decision Impact Status 006 Two-Workflow Initialization  High  Accepted 007 Workflow Bootstrap Pattern  Medium  Accepted 008 Centralized Label Management  Medium  Accepted 016 Initialization Security Handling  Medium  Accepted 017 MCP Server Integration  Medium  Accepted"},{"location":"adr/#upstream-synchronization-integration","title":"Upstream Synchronization &amp; Integration","text":"<p>\"How do I keep my fork in sync with upstream?\"</p> <p>Decisions for synchronizing with upstream repositories and integrating changes:</p> ADR Decision Impact Status 005 Conflict Management Strategy  Critical  Accepted 009 Asymmetric Cascade Review  Medium  Accepted 019 Cascade Monitor Pattern  High  Accepted 021 Pull Request Target Pattern  Medium  Accepted 023 Meta Commit Strategy  High  Accepted 024 Duplicate Prevention Architecture  Medium  Accepted"},{"location":"adr/#state-management-tracking","title":"State Management &amp; Tracking","text":"<p>\"How do I track progress and workflow state?\"</p> <p>Decisions for managing workflow state and tracking lifecycle:</p> ADR Decision Impact Status 020 Human-Required Label Strategy  High  Accepted 022 Issue Lifecycle Tracking  Medium  Accepted"},{"location":"adr/#build-test-dependencies","title":"Build, Test &amp; Dependencies","text":"<p>\"How do I build, test, and maintain dependencies?\"</p> <p>Build architecture, dependency management, and documentation:</p> ADR Decision Impact Status 025 Java/Maven Build Architecture  High  Accepted 026 Dependabot Security Updates  Medium  Accepted 027 Documentation Generation  Medium  Accepted"},{"location":"adr/#release-management","title":"Release Management","text":"<p>\"How do releases get created and published?\"</p> <p>Version management and release automation:</p> ADR Decision Impact Status 004 Release Please Versioning  High  Accepted"},{"location":"adr/#template-maintenance-evolution","title":"Template Maintenance &amp; Evolution","text":"<p>\"How do fork repositories stay updated with template improvements?\"</p> <p>Decisions for propagating template updates to fork repositories:</p> ADR Decision Impact Status 011 Configuration-Driven Sync  High  Accepted 012 Template Update Propagation  High  Accepted 018 Fork-Resources Staging  Medium  Accepted 031 Template Sync Duplicate Prevention  Medium  Accepted"},{"location":"adr/#workflow-infrastructure-patterns","title":"Workflow Infrastructure &amp; Patterns","text":"<p>\"What are the reusable building blocks?\"</p> <p>Technical patterns and infrastructure for workflow implementation:</p> ADR Decision Impact Status 010 YAML-Safe Shell Scripting  Medium  Accepted 013 Reusable GitHub Actions  Medium  Accepted 014 AI-Enhanced Workflows  High  Accepted 015 Template-Workflows Separation  Medium  Accepted 028 Workflow Script Extraction  Medium  Accepted 029 GitHub App Authentication  High  Accepted 030 CodeQL Summary Job Pattern  High  Accepted"},{"location":"adr/#navigation-tips","title":"Navigation Tips","text":""},{"location":"adr/#finding-relevant-adrs","title":"Finding Relevant ADRs","text":"<p>By Workflow Task: Use the question-based categories above to find ADRs related to specific activities (initialization, synchronization, build, release, etc.).</p> <p>By Impact Level: Focus on  Critical and  High Impact ADRs when understanding core system behavior or planning significant changes.</p> <p>By Category: Navigate to specific sections when troubleshooting issues in particular workflow areas.</p>"},{"location":"adr/#understanding-context","title":"Understanding Context","text":"<p>Most ADRs reference related decisions. Follow the cross-reference links to understand how decisions build upon each other and why certain patterns evolved.</p> <p>For insights on lessons learned and architectural principles, see Learnings.</p>"},{"location":"adr/001-three-branch-strategy/","title":"ADR-001: Three-Branch Fork Management Strategy","text":""},{"location":"adr/001-three-branch-strategy/#status","title":"Status","text":"<p>Accepted - 2025-10-01</p>"},{"location":"adr/001-three-branch-strategy/#context","title":"Context","text":"<p>When maintaining a long-lived fork of an upstream repository, teams need to balance staying current with upstream changes while preserving their own modifications. Traditional forking approaches often lead to complex merge conflicts, difficulty tracking upstream changes, and challenges in maintaining a stable release branch.</p> <p>The system needs to support: - Regular synchronization with upstream repositories - Isolation of local modifications from upstream changes - Safe conflict resolution workflow - Stable release management - Clear separation of concerns between different types of changes</p>"},{"location":"adr/001-three-branch-strategy/#decision","title":"Decision","text":"<p>Implement a three-branch strategy for fork management:</p> <ol> <li><code>main</code> - Stable production branch containing successfully integrated changes</li> <li><code>fork_upstream</code> - Tracks the upstream repository's main branch exactly</li> <li><code>fork_integration</code> - Validation workspace for conflict resolution and comprehensive testing of upstream changes</li> </ol>"},{"location":"adr/001-three-branch-strategy/#rationale","title":"Rationale","text":""},{"location":"adr/001-three-branch-strategy/#branch-purposes","title":"Branch Purposes","text":"<ul> <li><code>main</code>: Protected branch that only receives changes through PRs, ensuring stability</li> <li><code>fork_upstream</code>: Clean tracking of upstream without local modifications, enabling clear diff analysis</li> <li><code>fork_integration</code>: Dedicated space for conflict resolution and comprehensive validation (build, test, lint) without affecting stable branches</li> </ul>"},{"location":"adr/001-three-branch-strategy/#workflow-benefits","title":"Workflow Benefits","text":"<ol> <li>Clear Change Attribution: Easy to identify what comes from upstream vs local modifications</li> <li>Conflict Isolation: Merge conflicts are resolved in a dedicated branch before affecting main</li> <li>Quality Validation: Comprehensive build, test, and lint validation in integration branch</li> <li>Upstream Tracking: Pure upstream branch enables accurate diff analysis and change detection</li> <li>Safe Integration: Multiple review and validation points before changes reach the stable main branch</li> <li>Early Issue Detection: Integration validation catches problems before they reach production PRs</li> <li>Rollback Capability: Easy to revert problematic integrations without losing upstream sync</li> </ol>"},{"location":"adr/001-three-branch-strategy/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/001-three-branch-strategy/#1-two-branch-strategy-fork-main","title":"1. Two-Branch Strategy (fork + main)","text":"<ul> <li>Pros: Simpler branch structure</li> <li>Cons: Conflicts would occur directly on main branch, no dedicated conflict resolution space</li> <li>Decision: Rejected due to safety concerns</li> </ul>"},{"location":"adr/001-three-branch-strategy/#2-feature-branch-per-upstream-sync","title":"2. Feature Branch per Upstream Sync","text":"<ul> <li>Pros: Each sync is isolated</li> <li>Cons: Branch proliferation, complex tracking of multiple upstream syncs</li> <li>Decision: Rejected due to complexity</li> </ul>"},{"location":"adr/001-three-branch-strategy/#3-direct-upstream-merge-to-main","title":"3. Direct Upstream Merge to Main","text":"<ul> <li>Pros: Simplest possible approach</li> <li>Cons: No conflict isolation, high risk of breaking main branch</li> <li>Decision: Rejected due to lack of safety controls</li> </ul>"},{"location":"adr/001-three-branch-strategy/#consequences","title":"Consequences","text":""},{"location":"adr/001-three-branch-strategy/#positive","title":"Positive","text":"<ul> <li>Stability: Main branch remains stable through protected PR workflow</li> <li>Clarity: Clear separation between upstream changes and local modifications</li> <li>Safety: Multiple integration points prevent problematic changes from reaching production</li> <li>Traceability: Easy to track source of changes and resolve conflicts systematically</li> <li>Flexibility: Can handle complex upstream changes without disrupting ongoing development</li> </ul>"},{"location":"adr/001-three-branch-strategy/#negative","title":"Negative","text":"<ul> <li>Complexity: Three branches require more management overhead</li> <li>Learning Curve: Team needs to understand the branch strategy and workflows</li> <li>Automation Dependency: Requires automated workflows to manage branch synchronization effectively</li> </ul>"},{"location":"adr/001-three-branch-strategy/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/001-three-branch-strategy/#branch-protection-rules","title":"Branch Protection Rules","text":"<ul> <li><code>main</code>: Require PR reviews, status checks, and up-to-date branches</li> <li><code>fork_upstream</code>: Allow direct pushes from automation only</li> <li><code>fork_integration</code>: Allow direct pushes for conflict resolution</li> </ul>"},{"location":"adr/001-three-branch-strategy/#branch-preservation-strategy","title":"Branch Preservation Strategy","text":"<p>Critical Requirement: All three branches must be permanently preserved and never deleted.</p> <ul> <li><code>main</code>: Production branch - never delete</li> <li><code>fork_upstream</code>: Upstream tracking branch - never delete (needed for future syncs)</li> <li><code>fork_integration</code>: Conflict resolution branch - never delete (needed for future integrations)</li> </ul> <p>Implementation: When creating production PRs, use temporary release branches (e.g., <code>release/upstream-YYYYMMDD-HHMMSS</code>) from <code>fork_integration</code> to <code>main</code>. This allows safe deletion of release branches while preserving the core three-branch structure.</p>"},{"location":"adr/001-three-branch-strategy/#integration-branch-synchronization","title":"Integration Branch Synchronization","text":"<p>Problem: After a production PR merges to <code>main</code>, <code>fork_integration</code> contains the old commit history that was integrated via the release branch. This causes the cascade workflow to incorrectly detect an \"integration in progress\" because <code>fork_integration</code> appears to be ahead of <code>main</code>.</p> <p>Solution: The <code>integration-cleanup.yml</code> workflow automatically synchronizes <code>fork_integration</code> with <code>main</code> after any upstream-sync PR is merged to <code>main</code>. This: - Prevents false \"integration in progress\" detections - Clears the pipeline for processing new upstream changes - Automatically closes any \"upstream-held\" issues - Maintains the three-branch strategy integrity</p> <p>Trigger: Runs automatically on PR merge to <code>main</code> when PR has <code>upstream-sync</code> label</p>"},{"location":"adr/001-three-branch-strategy/#workflow-integration","title":"Workflow Integration","text":"<ol> <li>Upstream Sync: <code>fork_upstream</code> tracks upstream automatically</li> <li>Change Detection: Compare <code>fork_upstream</code> with <code>main</code> to identify new upstream changes</li> <li>Integration Cascade: Merge <code>fork_upstream</code> to <code>fork_integration</code> with comprehensive validation</li> <li>Validation Gate: Run build, test, and lint checks on <code>fork_integration</code> branch</li> <li>Quality Assurance: Block progression if validation fails, create detailed failure issues</li> <li>Production Release: Create PR from validated <code>fork_integration</code> to <code>main</code> only after successful validation</li> <li>Manual Review: All production PRs require human approval before final merge</li> <li>Integration Sync: After PR merge to <code>main</code>, automatically synchronize <code>fork_integration</code> with <code>main</code> to clear pipeline state</li> </ol>"},{"location":"adr/001-three-branch-strategy/#automation-requirements","title":"Automation Requirements","text":"<ul> <li>Scheduled upstream synchronization to <code>fork_upstream</code></li> <li>Automated conflict detection and PR creation</li> <li>Comprehensive integration validation (build, test, lint)</li> <li>Validation failure detection and issue creation</li> <li>Branch protection enforcement</li> <li>Status checks and validation workflows</li> <li>Issue lifecycle tracking and status reporting</li> <li>Automatic <code>fork_integration</code> synchronization after main merges (integration-cleanup workflow)</li> </ul>"},{"location":"adr/001-three-branch-strategy/#success-criteria","title":"Success Criteria","text":"<ul> <li>Teams can safely integrate upstream changes without breaking main branch</li> <li>Conflicts are resolved in isolated environment before affecting production</li> <li>Integration validation catches build/test issues before production PRs</li> <li>Validation failures are tracked and resolved systematically</li> <li>Clear audit trail of all changes, validation results, and their sources</li> <li>Reduced time to resolve upstream integration issues</li> <li>Maintained stability of main branch throughout integration process</li> <li>Quality gate ensures only validated, tested changes reach production</li> </ul> <p> Catalog | ADR-002 \u2192</p>"},{"location":"adr/002-github-actions-automation/","title":"ADR-002: GitHub Actions-Based Automation Architecture","text":""},{"location":"adr/002-github-actions-automation/#status","title":"Status","text":"<p>Accepted - 2025-10-01</p>"},{"location":"adr/002-github-actions-automation/#context","title":"Context","text":"<p>The fork management system requires extensive automation to handle repository initialization, upstream synchronization, conflict detection, build validation, and release management. The automation must be reliable, maintainable, and integrate seamlessly with GitHub's repository management features.</p> <p>Key automation requirements: - Repository initialization and configuration - Scheduled upstream synchronization - Automated conflict detection and resolution workflows - Build and test automation - Release management and versioning - Security scanning and compliance checks</p>"},{"location":"adr/002-github-actions-automation/#decision","title":"Decision","text":"<p>Implement all automation using GitHub Actions with a modular workflow architecture consisting of:</p> <ol> <li>init.yml - Repository initialization and setup</li> <li>sync.yml - Upstream synchronization with issue lifecycle tracking and duplicate prevention</li> <li>cascade.yml - Human-triggered integration workflow with issue updates</li> <li>cascade-monitor.yml - Safety net detection and health monitoring</li> <li>validate.yml - PR validation and compliance checks</li> <li>build.yml - Build, test, and coverage reporting</li> <li>release.yml - Automated release management</li> </ol>"},{"location":"adr/002-github-actions-automation/#rationale","title":"Rationale","text":""},{"location":"adr/002-github-actions-automation/#github-actions-benefits","title":"GitHub Actions Benefits","text":"<ol> <li>Native Integration: Deep integration with GitHub repository features</li> <li>No External Dependencies: Eliminates need for external CI/CD services</li> <li>Cost Effective: Included with GitHub repositories</li> <li>Security: Runs in GitHub's secure environment with built-in secrets management</li> <li>Marketplace Ecosystem: Rich ecosystem of pre-built actions</li> <li>Event-Driven: Responds to repository events automatically</li> </ol>"},{"location":"adr/002-github-actions-automation/#modular-workflow-design","title":"Modular Workflow Design","text":"<ol> <li>Separation of Concerns: Each workflow has a single responsibility</li> <li>Maintainability: Easier to update and debug individual workflows</li> <li>Reusability: Common patterns can be extracted to composite actions</li> <li>Conditional Execution: Workflows only run when relevant</li> <li>Parallel Execution: Independent workflows can run concurrently</li> </ol>"},{"location":"adr/002-github-actions-automation/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/002-github-actions-automation/#1-external-cicd-platform-jenkins-gitlab-ci-etc","title":"1. External CI/CD Platform (Jenkins, GitLab CI, etc.)","text":"<ul> <li>Pros: More powerful build environments, advanced features</li> <li>Cons: External dependencies, additional cost, complexity, security considerations</li> <li>Decision: Rejected due to complexity and external dependencies</li> </ul>"},{"location":"adr/002-github-actions-automation/#2-monolithic-single-workflow","title":"2. Monolithic Single Workflow","text":"<ul> <li>Pros: All logic in one place</li> <li>Cons: Complex, hard to maintain, unnecessary execution of unrelated tasks</li> <li>Decision: Rejected due to maintainability concerns</li> </ul>"},{"location":"adr/002-github-actions-automation/#3-serverless-functions-aws-lambda-azure-functions","title":"3. Serverless Functions (AWS Lambda, Azure Functions)","text":"<ul> <li>Pros: Highly scalable, event-driven</li> <li>Cons: Platform lock-in, complex setup, additional infrastructure costs</li> <li>Decision: Rejected due to complexity and vendor lock-in</li> </ul>"},{"location":"adr/002-github-actions-automation/#consequences","title":"Consequences","text":""},{"location":"adr/002-github-actions-automation/#positive","title":"Positive","text":"<ul> <li>Zero Setup: Works immediately when repository is created from template</li> <li>Integrated Security: Leverages GitHub's security features and secrets management</li> <li>Event-Driven: Automatically responds to repository changes</li> <li>Maintainable: Modular design makes updates and debugging easier</li> <li>Cost Effective: No additional service costs beyond GitHub subscription</li> <li>Reliable: GitHub's infrastructure provides high availability</li> </ul>"},{"location":"adr/002-github-actions-automation/#negative","title":"Negative","text":"<ul> <li>GitHub Lock-in: Tied to GitHub platform specifically</li> <li>Execution Limits: Subject to GitHub Actions usage limits and timeouts</li> <li>Limited Environment: Less control over build environment compared to self-hosted runners</li> <li>YAML Complexity: Complex workflows can become difficult to read and maintain</li> </ul>"},{"location":"adr/002-github-actions-automation/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/002-github-actions-automation/#workflow-triggers","title":"Workflow Triggers","text":"<ul> <li>init.yml: <code>repository_dispatch</code> event triggered by repository creation</li> <li>sync.yml: Scheduled (daily) + manual <code>workflow_dispatch</code> - creates tracking issues with duplicate prevention</li> <li>cascade.yml: Manual <code>workflow_dispatch</code> (human-triggered) - updates issue lifecycle</li> <li>cascade-monitor.yml: Scheduled (6 hours) + manual <code>workflow_dispatch</code> - safety net</li> <li>validate.yml: PR events (opened, synchronize, reopened)</li> <li>build.yml: Push to feature branches and PR events</li> <li>release.yml: Push to main branch with conventional commit messages</li> </ul>"},{"location":"adr/002-github-actions-automation/#security-considerations","title":"Security Considerations","text":"<ul> <li>Secrets Management: Use GitHub secrets for API keys and tokens</li> <li>Token Permissions: Minimal required permissions for each workflow</li> <li>Branch Protection: Workflows enforce branch protection rules</li> <li>Security Scanning: Integrated Trivy scanning for vulnerabilities</li> </ul>"},{"location":"adr/002-github-actions-automation/#composite-actions","title":"Composite Actions","text":"<p>Extract common patterns into reusable composite actions: - pr-status: Update PR status with validation results - java-build: Standardized Java/Maven build process - java-build-status: Report build status with coverage</p>"},{"location":"adr/002-github-actions-automation/#error-handling","title":"Error Handling","text":"<ul> <li>Graceful Degradation: Workflows continue even if optional steps fail</li> <li>Clear Error Messages: Detailed error reporting for debugging</li> <li>Issue Lifecycle Tracking: Comprehensive issue tracking for cascade state management</li> <li>Human-Required Labels: Failed workflows create issues with <code>human-required</code> labels</li> <li>Safety Net Recovery: Monitor workflow detects and recovers from missed triggers</li> <li>Retry Logic: Automatic retry for transient failures</li> </ul>"},{"location":"adr/002-github-actions-automation/#success-criteria","title":"Success Criteria","text":"<ul> <li>Repository initialization completes successfully within 5 minutes</li> <li>Upstream synchronization runs reliably on schedule with issue tracking and duplicate prevention</li> <li>90%+ of sync merges followed by manual cascade triggers within 2 hours</li> <li>Issue lifecycle tracking provides complete audit trail for 95%+ of cascades</li> <li>Build workflows complete within 15 minutes for typical projects</li> <li>Failed workflows create actionable issues for team resolution</li> <li>Safety net detects 100% of missed cascade triggers within 6 hours</li> <li>Workflows are maintainable by team members without GitHub Actions expertise</li> <li>Security scanning catches vulnerabilities before they reach main branch</li> </ul>"},{"location":"adr/002-github-actions-automation/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-029: GitHub App Authentication Strategy - Authentication mechanism for workflow automation</li> </ul> <p>\u2190 ADR-001 |  Catalog | ADR-003 \u2192</p>"},{"location":"adr/003-template-repository-pattern/","title":"ADR-003: Template Repository Pattern for Self-Configuration","text":""},{"location":"adr/003-template-repository-pattern/#status","title":"Status","text":"<p>Accepted - 2025-10-01</p>"},{"location":"adr/003-template-repository-pattern/#context","title":"Context","text":"<p>Teams need a way to quickly set up fork management systems for different upstream repositories without manual configuration. The setup process involves creating branch structures, configuring workflows, setting up branch protection rules, and establishing the upstream relationship.</p> <p>Manual setup requirements would include: - Creating and configuring three branches with proper relationships - Setting up GitHub Actions workflows with repository-specific parameters - Configuring branch protection rules and security settings - Establishing upstream repository connection - Initializing project-specific build configurations</p> <p>The solution must provide zero-configuration deployment while allowing customization for different project types and requirements.</p>"},{"location":"adr/003-template-repository-pattern/#decision","title":"Decision","text":"<p>Implement the fork management system as a GitHub Template Repository with automatic self-configuration through an initialization workflow that:</p> <ol> <li>Template Repository Structure: Repository marked as template with complete workflow and configuration files</li> <li>Issue-Based Configuration: Use GitHub Issues to capture upstream repository URL during initialization</li> <li>Automated Setup Workflow: <code>init.yml</code> workflow configures the repository automatically upon creation</li> <li>Self-Modifying Workflows: Workflows update themselves with repository-specific parameters</li> </ol>"},{"location":"adr/003-template-repository-pattern/#rationale","title":"Rationale","text":""},{"location":"adr/003-template-repository-pattern/#template-repository-benefits","title":"Template Repository Benefits","text":"<ol> <li>One-Click Deployment: Users create new repositories with single click from template</li> <li>Complete Setup: All workflows, configurations, and documentation included</li> <li>Version Control: Template updates can be tracked and deployed systematically</li> <li>GitHub Native: Uses GitHub's built-in template functionality</li> <li>No External Dependencies: Requires no external tools or services</li> </ol>"},{"location":"adr/003-template-repository-pattern/#issue-based-configuration","title":"Issue-Based Configuration","text":"<ol> <li>User-Friendly: Simple form-based interface for configuration input</li> <li>Validation: Can validate upstream repository URLs before processing</li> <li>Audit Trail: Configuration decisions are recorded in issue history</li> <li>Interactive: Allows clarification and validation during setup</li> <li>Accessible: Works through GitHub web interface without technical setup</li> </ol>"},{"location":"adr/003-template-repository-pattern/#self-configuration-approach","title":"Self-Configuration Approach","text":"<ol> <li>Immediate Activation: Repository becomes functional immediately after creation</li> <li>Customization: Can adapt to different project types and requirements</li> <li>Consistency: Ensures all fork repositories follow the same patterns</li> <li>Maintenance: Template updates can be propagated to existing repositories</li> </ol>"},{"location":"adr/003-template-repository-pattern/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/003-template-repository-pattern/#1-manual-setup-documentation","title":"1. Manual Setup Documentation","text":"<ul> <li>Pros: Simple, no automation complexity</li> <li>Cons: Error-prone, time-consuming, inconsistent results, requires technical expertise</li> <li>Decision: Rejected due to user experience and consistency concerns</li> </ul>"},{"location":"adr/003-template-repository-pattern/#2-cli-tool-for-setup","title":"2. CLI Tool for Setup","text":"<ul> <li>Pros: Powerful, flexible configuration options</li> <li>Cons: Requires tool installation, platform dependencies, maintenance overhead</li> <li>Decision: Rejected due to deployment complexity</li> </ul>"},{"location":"adr/003-template-repository-pattern/#3-external-configuration-service","title":"3. External Configuration Service","text":"<ul> <li>Pros: Centralized management, advanced configuration options</li> <li>Cons: External dependency, security concerns, additional infrastructure</li> <li>Decision: Rejected due to complexity and external dependencies</li> </ul>"},{"location":"adr/003-template-repository-pattern/#4-cookiecutteryeoman-template","title":"4. Cookiecutter/Yeoman Template","text":"<ul> <li>Pros: Industry standard, powerful templating</li> <li>Cons: Requires local tools, no automatic updates, static generation</li> <li>Decision: Rejected due to local tool requirements</li> </ul>"},{"location":"adr/003-template-repository-pattern/#consequences","title":"Consequences","text":""},{"location":"adr/003-template-repository-pattern/#positive","title":"Positive","text":"<ul> <li>Zero Friction: Teams can deploy fork management in under 5 minutes</li> <li>Consistency: All repositories follow identical patterns and configurations</li> <li>Self-Updating: Template improvements benefit all deployed repositories</li> <li>User-Friendly: No technical expertise required for deployment</li> <li>Maintainable: Centralized template makes updates and improvements easy</li> <li>Scalable: Can support unlimited repository deployments</li> </ul>"},{"location":"adr/003-template-repository-pattern/#negative","title":"Negative","text":"<ul> <li>GitHub Lock-in: Tied specifically to GitHub's template repository feature</li> <li>Limited Customization: Initial setup options are constrained by issue form capabilities</li> <li>Bootstrap Complexity: Self-modifying workflows add complexity to initialization</li> <li>~~Update Propagation: Changes to template don't automatically update existing repositories~~ [RESOLVED by ADR-011, ADR-012]</li> </ul>"},{"location":"adr/003-template-repository-pattern/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/003-template-repository-pattern/#template-repository-setup","title":"Template Repository Setup","text":"<ul> <li>Repository marked as template in GitHub settings</li> <li>Complete workflow files with placeholder variables</li> <li>Documentation and configuration files included</li> <li>Example configurations for common scenarios</li> </ul>"},{"location":"adr/003-template-repository-pattern/#initialization-process","title":"Initialization Process","text":"<ol> <li>Repository Creation: User creates repository from template</li> <li>Issue Creation: <code>init.yml</code> workflow creates configuration issue automatically</li> <li>User Input: User provides upstream repository URL in issue comment</li> <li>Validation: Workflow validates upstream repository accessibility</li> <li>Configuration: Workflows update themselves with repository-specific parameters</li> <li>Branch Setup: Three-branch structure created with upstream connection</li> <li>Protection Rules: Branch protection and security settings applied</li> <li>Cleanup: Initialization issue closed, repository ready for use</li> </ol>"},{"location":"adr/003-template-repository-pattern/#configuration-parameters","title":"Configuration Parameters","text":"<ul> <li>Upstream Repository: GitHub or GitLab repository URL</li> <li>Project Type: Java, Node.js, Python, etc. (affects build workflows)</li> <li>Sync Schedule: Weekly, daily, or manual synchronization</li> <li>Security Settings: Branch protection, required reviews, status checks</li> </ul>"},{"location":"adr/003-template-repository-pattern/#self-modification-approach","title":"Self-Modification Approach","text":"<pre><code># Example: Update workflow file with repository-specific values\n- name: Configure Sync Workflow\n  run: |\n    sed -i 's|UPSTREAM_REPO_PLACEHOLDER|${{ env.UPSTREAM_REPO }}|g' .github/workflows/sync.yml\n    git add .github/workflows/sync.yml\n    git commit -m \"Configure upstream repository for sync workflow\"\n</code></pre>"},{"location":"adr/003-template-repository-pattern/#success-criteria","title":"Success Criteria","text":"<ul> <li>Repository deployment completes in under 5 minutes from template creation</li> <li>Non-technical users can successfully deploy and configure repositories</li> <li>All deployed repositories maintain consistent structure and behavior</li> <li>Template updates can be propagated to existing repositories</li> <li>Configuration errors are caught and reported clearly during setup</li> <li>Deployed repositories are immediately functional for upstream synchronization</li> </ul> <p>\u2190 ADR-002 |  Catalog | ADR-004 \u2192</p>"},{"location":"adr/004-release-please-versioning/","title":"ADR-004: Release Please for Automated Version Management","text":""},{"location":"adr/004-release-please-versioning/#status","title":"Status","text":"<p>Accepted - 2025-10-01</p>"},{"location":"adr/004-release-please-versioning/#context","title":"Context","text":"<p>Fork repositories need automated version management that can handle both local changes and upstream integration while maintaining semantic versioning and clear changelog documentation. The versioning system must:</p> <ul> <li>Support semantic versioning based on commit message conventions</li> <li>Generate meaningful changelogs that distinguish local vs upstream changes</li> <li>Maintain release tags that reference both local and upstream versions</li> <li>Automate the release process without manual intervention</li> <li>Integrate with the three-branch fork management strategy</li> </ul> <p>Traditional versioning approaches for forks often struggle with distinguishing between local changes and upstream integration, leading to unclear changelogs and confusing version histories.</p>"},{"location":"adr/004-release-please-versioning/#decision","title":"Decision","text":"<p>Adopt Google's Release Please action for automated version management with Conventional Commits, configured to:</p> <ol> <li>Conventional Commits: Enforce commit message format for automated version determination</li> <li>Automated Changelog: Generate changelogs from commit messages with custom formatting</li> <li>Semantic Versioning: Automatically determine version bumps based on commit types</li> <li>Release Tags: Create tags with upstream version references</li> <li>Release Notes: Publish GitHub releases with comprehensive change documentation</li> </ol>"},{"location":"adr/004-release-please-versioning/#rationale","title":"Rationale","text":""},{"location":"adr/004-release-please-versioning/#release-please-benefits","title":"Release Please Benefits","text":"<ol> <li>Industry Standard: Widely adopted by Google and open-source community</li> <li>Conventional Commits: Standardized commit message format enables automation</li> <li>Semantic Versioning: Automatic version determination based on change types</li> <li>Changelog Generation: Automatically generates and maintains CHANGELOG.md</li> <li>GitHub Integration: Native GitHub releases with proper tagging</li> <li>Flexible Configuration: Customizable for fork-specific requirements</li> </ol>"},{"location":"adr/004-release-please-versioning/#conventional-commits-alignment","title":"Conventional Commits Alignment","text":"<ol> <li>Clear Intent: Commit messages explicitly declare change types</li> <li>Automated Processing: Enables automated version determination</li> <li>Team Communication: Improves commit message quality and consistency</li> <li>Breaking Changes: Clear marking of breaking changes for major version bumps</li> <li>Feature Tracking: Easy identification of new features vs bug fixes</li> </ol>"},{"location":"adr/004-release-please-versioning/#fork-specific-adaptations","title":"Fork-Specific Adaptations","text":"<ol> <li>Upstream References: Release tags include upstream version information</li> <li>Change Attribution: Changelog distinguishes between local and upstream changes</li> <li>Integration Tracking: Clear documentation of upstream integration points</li> <li>Version Correlation: Maintains relationship between fork and upstream versions</li> </ol>"},{"location":"adr/004-release-please-versioning/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/004-release-please-versioning/#1-manual-version-management","title":"1. Manual Version Management","text":"<ul> <li>Pros: Complete control, simple implementation</li> <li>Cons: Error-prone, time-consuming, inconsistent, requires human intervention</li> <li>Decision: Rejected due to automation requirements</li> </ul>"},{"location":"adr/004-release-please-versioning/#2-semantic-release","title":"2. Semantic Release","text":"<ul> <li>Pros: Popular, flexible, extensive plugin ecosystem</li> <li>Cons: Node.js dependency, complex configuration, less GitHub native</li> <li>Decision: Rejected in favor of GitHub-native solution</li> </ul>"},{"location":"adr/004-release-please-versioning/#3-custom-versioning-script","title":"3. Custom Versioning Script","text":"<ul> <li>Pros: Full customization, fork-specific logic</li> <li>Cons: Maintenance overhead, testing requirements, reinventing established patterns</li> <li>Decision: Rejected due to maintenance complexity</li> </ul>"},{"location":"adr/004-release-please-versioning/#4-gitversion-or-similar-tools","title":"4. GitVersion or Similar Tools","text":"<ul> <li>Pros: Powerful versioning logic, branch-based versioning</li> <li>Cons: Complex configuration, learning curve, less automation-friendly</li> <li>Decision: Rejected due to complexity and automation requirements</li> </ul>"},{"location":"adr/004-release-please-versioning/#consequences","title":"Consequences","text":""},{"location":"adr/004-release-please-versioning/#positive","title":"Positive","text":"<ul> <li>Automated Releases: No manual intervention required for version management</li> <li>Consistent Versioning: Semantic versioning ensures predictable version progression</li> <li>Clear Changelogs: Automated changelog generation with meaningful categorization</li> <li>GitHub Integration: Native GitHub releases with proper asset management</li> <li>Team Productivity: Eliminates manual release tasks and potential errors</li> <li>Audit Trail: Complete version history with clear change attribution</li> </ul>"},{"location":"adr/004-release-please-versioning/#negative","title":"Negative","text":"<ul> <li>Commit Message Discipline: Team must follow Conventional Commits format</li> <li>Limited Flexibility: Version determination is constrained by commit message rules</li> <li>GitHub Dependency: Tied to GitHub's release mechanism</li> <li>Learning Curve: Team needs to understand Conventional Commits format</li> </ul>"},{"location":"adr/004-release-please-versioning/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/004-release-please-versioning/#conventional-commits-format","title":"Conventional Commits Format","text":"<pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>Types: - <code>feat</code>: New features (minor version bump) - <code>fix</code>: Bug fixes (patch version bump) - <code>docs</code>: Documentation changes - <code>style</code>: Code style changes - <code>refactor</code>: Code refactoring - <code>test</code>: Test additions or modifications - <code>chore</code>: Maintenance tasks - <code>BREAKING CHANGE</code>: Breaking changes (major version bump)</p>"},{"location":"adr/004-release-please-versioning/#release-please-configuration","title":"Release Please Configuration","text":"<pre><code># .github/workflows/release.yml\n- uses: googleapis/release-please-action@v3\n  with:\n    release-type: simple\n    package-name: fork-management-template\n    changelog-types: |\n      [\n        {\"type\":\"feat\",\"section\":\"Features\",\"hidden\":false},\n        {\"type\":\"fix\",\"section\":\"Bug Fixes\",\"hidden\":false},\n        {\"type\":\"chore\",\"section\":\"Miscellaneous\",\"hidden\":false},\n        {\"type\":\"upstream\",\"section\":\"Upstream Integration\",\"hidden\":false}\n      ]\n</code></pre>"},{"location":"adr/004-release-please-versioning/#fork-specific-enhancements","title":"Fork-Specific Enhancements","text":"<ul> <li>Upstream Tags: Release tags include reference to upstream version</li> <li>Change Attribution: Commits marked with source (local vs upstream)</li> <li>Integration Notes: Special handling for upstream integration commits</li> <li>Version Correlation: Changelog includes upstream version references</li> </ul>"},{"location":"adr/004-release-please-versioning/#validation-workflow-integration","title":"Validation Workflow Integration","text":"<p>The validate.yml workflow enforces Conventional Commits format: <pre><code>- name: Validate Commit Messages\n  uses: wagoid/commitlint-github-action@v5\n  with:\n    configFile: .commitlintrc.json\n</code></pre></p>"},{"location":"adr/004-release-please-versioning/#success-criteria","title":"Success Criteria","text":"<ul> <li>Releases are generated automatically based on commit messages</li> <li>Changelog accurately reflects all changes with clear categorization</li> <li>Version numbers follow semantic versioning principles</li> <li>Release tags include upstream version references where applicable</li> <li>Team can easily identify what changed between releases</li> <li>Breaking changes are clearly identified and documented</li> <li>No manual intervention required for standard release process</li> </ul>"},{"location":"adr/004-release-please-versioning/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-029: GitHub App Authentication Strategy - Authentication mechanism for release automation</li> </ul> <p>\u2190 ADR-003 |  Catalog | ADR-005 \u2192</p>"},{"location":"adr/005-conflict-management/","title":"ADR-005: Automated Conflict Management Strategy","text":""},{"location":"adr/005-conflict-management/#status","title":"Status","text":"<p>Accepted - 2025-10-01</p>"},{"location":"adr/005-conflict-management/#context","title":"Context","text":"<p>When synchronizing with upstream repositories, merge conflicts are inevitable due to modifications made in the fork. The system needs to handle conflicts in a way that:</p> <ul> <li>Prevents automatic merging of conflicted code</li> <li>Provides clear visibility into conflicts and their resolution requirements</li> <li>Maintains the stability of the main branch during conflict resolution</li> <li>Enables systematic resolution of conflicts without blocking other development</li> <li>Tracks conflict resolution decisions for future reference</li> </ul> <p>Traditional approaches often result in conflicts being resolved directly on main branches, leading to instability, or conflicts being ignored, leading to drift from upstream.</p>"},{"location":"adr/005-conflict-management/#decision","title":"Decision","text":"<p>Implement an automated conflict management strategy that:</p> <ol> <li>Conflict Detection: Automatically detect merge conflicts during upstream synchronization</li> <li>Isolation Strategy: Use the <code>fork_integration</code> branch for conflict resolution</li> <li>Issue Creation: Create GitHub Issues for each conflict requiring resolution</li> <li>Pull Request Workflow: Create separate PRs for conflict resolution and integration</li> <li>Manual Resolution: Require human review for all conflict resolutions</li> <li>Documentation: Maintain clear records of conflict resolution decisions</li> </ol>"},{"location":"adr/005-conflict-management/#rationale","title":"Rationale","text":""},{"location":"adr/005-conflict-management/#automated-detection-benefits","title":"Automated Detection Benefits","text":"<ol> <li>Early Warning: Conflicts identified immediately during sync process</li> <li>Visibility: Team is notified of conflicts through issues and PRs</li> <li>Prevention: Prevents conflicted code from reaching main branch</li> <li>Systematic: Consistent handling of all conflicts regardless of complexity</li> <li>Audit Trail: Complete record of when conflicts occurred and how they were resolved</li> </ol>"},{"location":"adr/005-conflict-management/#fork-integration-branch-strategy","title":"Fork Integration Branch Strategy","text":"<ol> <li>Isolation: Conflicts resolved in dedicated branch without affecting main</li> <li>Safety: Main branch remains stable during conflict resolution process</li> <li>Flexibility: Multiple conflicts can be resolved independently</li> <li>Testing: Conflict resolutions can be tested before integration</li> <li>Rollback: Easy to abandon problematic conflict resolutions</li> </ol>"},{"location":"adr/005-conflict-management/#issue-driven-process","title":"Issue-Driven Process","text":"<ol> <li>Accountability: Clear ownership of conflict resolution tasks</li> <li>Discussion: Platform for discussing resolution strategies</li> <li>Documentation: Permanent record of resolution decisions and rationale</li> <li>Tracking: Progress tracking and resolution status visibility</li> <li>Knowledge Transfer: Future conflicts can reference previous resolution patterns</li> </ol>"},{"location":"adr/005-conflict-management/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/005-conflict-management/#1-automatic-conflict-resolution","title":"1. Automatic Conflict Resolution","text":"<ul> <li>Pros: No manual intervention, faster integration</li> <li>Cons: Risk of incorrect resolutions, loss of context, potential data loss</li> <li>Decision: Rejected due to safety and quality concerns</li> </ul>"},{"location":"adr/005-conflict-management/#2-conflict-resolution-on-main-branch","title":"2. Conflict Resolution on Main Branch","text":"<ul> <li>Pros: Simpler workflow, direct resolution</li> <li>Cons: Destabilizes main branch, blocks other development, risky</li> <li>Decision: Rejected due to stability requirements</li> </ul>"},{"location":"adr/005-conflict-management/#3-feature-branch-per-conflict","title":"3. Feature Branch per Conflict","text":"<ul> <li>Pros: Complete isolation of each conflict</li> <li>Cons: Branch proliferation, complex tracking, overhead</li> <li>Decision: Rejected due to management complexity</li> </ul>"},{"location":"adr/005-conflict-management/#4-manual-conflict-detection","title":"4. Manual Conflict Detection","text":"<ul> <li>Pros: Human judgment in conflict identification</li> <li>Cons: Inconsistent, delays in detection, human error prone</li> <li>Decision: Rejected due to automation requirements</li> </ul>"},{"location":"adr/005-conflict-management/#consequences","title":"Consequences","text":""},{"location":"adr/005-conflict-management/#positive","title":"Positive","text":"<ul> <li>Stability: Main branch protected from conflicts during resolution</li> <li>Visibility: Clear tracking of all conflicts and their resolution status</li> <li>Quality: Human review ensures appropriate conflict resolution</li> <li>Documentation: Permanent record of resolution decisions for future reference</li> <li>Systematic: Consistent handling regardless of conflict complexity</li> <li>Safe: Multiple review points before conflicts reach production</li> </ul>"},{"location":"adr/005-conflict-management/#negative","title":"Negative","text":"<ul> <li>Manual Overhead: Requires human intervention for all conflicts</li> <li>Potential Delays: Conflicts must be resolved before upstream integration</li> <li>Process Complexity: Multiple branches and PRs for conflict resolution</li> <li>Learning Curve: Team must understand conflict resolution workflow</li> </ul>"},{"location":"adr/005-conflict-management/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/005-conflict-management/#current-architecture-2025","title":"Current Architecture (2025)","text":"<p>The conflict management strategy is now integrated with the Cascade Monitor Pattern (ADR-019) and uses the Human-Required Label Strategy (ADR-020):</p> <ol> <li>Sync Workflow: Creates clean PRs to <code>fork_upstream</code> when possible</li> <li>Cascade Monitor: Detects merged sync PRs and triggers cascade</li> <li>Cascade Workflow: Handles conflict detection and resolution during integration</li> </ol>"},{"location":"adr/005-conflict-management/#conflict-detection-in-cascade-workflow","title":"Conflict Detection in Cascade Workflow","text":"<pre><code># In cascade.yml - Phase 1: Upstream to Integration\n- name: Merge upstream into fork_integration\n  id: merge_upstream\n  run: |\n    # Merge fork_upstream into fork_integration\n    echo \"Merging upstream changes into fork_integration...\"\n    CONFLICTS_FOUND=false\n\n    if git merge origin/fork_upstream --no-edit; then\n      echo \"\u2705 Clean merge of upstream changes achieved\"\n    else\n      # Check if there are unresolved conflicts\n      if git status --porcelain | grep -q \"^UU\\|^AA\\|^DD\"; then\n        echo \"::warning::Merge conflicts detected\"\n        CONFLICTS_FOUND=true\n\n        # List conflicted files\n        echo \"Conflicted files:\"\n        git diff --name-only --diff-filter=U | tee conflicted_files.txt\n\n        # Create conflict resolution issue\n        CONFLICT_BODY=\"Upstream merge conflicts detected in fork_integration branch.\n\n        **Conflicted Files:**\n        \\`\\`\\`\n        $(cat conflicted_files.txt)\n        \\`\\`\\`\n\n        **Next Steps:**\n        1. Checkout the fork_integration branch locally\n        2. Resolve conflicts in the listed files\n        3. Commit and push the resolution\n        4. The cascade will automatically continue once conflicts are resolved\n\n        **SLA:** 48 hours for resolution\"\n\n        gh issue create \\\n          --title \"\ud83d\udea8 Cascade Conflicts: Manual Resolution Required - $(date +%Y-%m-%d)\" \\\n          --body \"$CONFLICT_BODY\" \\\n          --label \"conflict,cascade-blocked,high-priority,human-required\"\n\n        echo \"conflicts=true\" &gt;&gt; $GITHUB_OUTPUT\n        exit 1\n      else\n        echo \"\u2705 Merge completed with automatic resolution\"\n      fi\n    fi\n\n    echo \"conflicts=false\" &gt;&gt; $GITHUB_OUTPUT\n</code></pre>"},{"location":"adr/005-conflict-management/#current-conflict-resolution-process-2025","title":"Current Conflict Resolution Process (2025)","text":"<ol> <li>Trigger: Cascade monitor detects sync PR merge to <code>fork_upstream</code></li> <li>Attempt Integration: Cascade workflow attempts merge to <code>fork_integration</code></li> <li>Conflict Detection: Automated detection of merge conflicts during cascade</li> <li>Issue Creation: Issue created with <code>conflict,cascade-blocked,human-required</code> labels</li> <li>Manual Resolution: Developer resolves conflicts directly in <code>fork_integration</code> branch</li> <li>Automatic Continuation: Once resolved, cascade automatically continues to main</li> <li>SLA Management: Conflicts older than 48 hours are automatically escalated</li> <li>Cleanup: Issues closed when conflicts resolved and cascade completes</li> </ol>"},{"location":"adr/005-conflict-management/#label-based-management-adr-020","title":"Label-Based Management (ADR-020)","text":"<ul> <li>Primary Label: <code>human-required</code> - Indicates manual intervention needed</li> <li>Type Label: <code>conflict</code> - Identifies the type of issue  </li> <li>Status Label: <code>cascade-blocked</code> - Shows pipeline is blocked</li> <li>Priority Label: <code>high-priority</code> - Indicates urgency level</li> </ul>"},{"location":"adr/005-conflict-management/#conflict-categorization","title":"Conflict Categorization","text":"<ul> <li>Code Conflicts: Overlapping changes in source files</li> <li>Configuration Conflicts: Changes to build files, dependencies</li> <li>Documentation Conflicts: README, documentation updates</li> <li>Deletion Conflicts: Files deleted in upstream or fork</li> </ul>"},{"location":"adr/005-conflict-management/#resolution-guidelines","title":"Resolution Guidelines","text":"<ul> <li>Preserve Fork Intent: Maintain the purpose of fork-specific changes</li> <li>Adopt Upstream Improvements: Integrate beneficial upstream changes</li> <li>Document Decisions: Explain resolution rationale in PR description</li> <li>Test Thoroughly: Ensure resolution doesn't break functionality</li> <li>Consistent Patterns: Follow established resolution patterns for similar conflicts</li> </ul>"},{"location":"adr/005-conflict-management/#success-criteria","title":"Success Criteria","text":"<ul> <li>No conflicted code ever reaches the main branch</li> <li>All conflicts are detected automatically during sync process</li> <li>Conflict resolution issues are created with actionable information</li> <li>Average conflict resolution time is under 48 hours</li> <li>Resolution decisions are clearly documented for future reference</li> <li>Team can handle conflicts without blocking regular development work</li> <li>Conflict resolution patterns become consistent over time</li> </ul> <p>\u2190 ADR-004 |  Catalog | ADR-006 \u2192</p>"},{"location":"adr/006-two-workflow-initialization/","title":"ADR-006: Two-Workflow Initialization Pattern","text":""},{"location":"adr/006-two-workflow-initialization/#status","title":"Status","text":"<p>Accepted - 2025-10-01</p>"},{"location":"adr/006-two-workflow-initialization/#context","title":"Context","text":"<p>The original initialization system used a single, complex workflow (<code>init.yml</code>) that handled everything from issue creation to repository setup, branch creation, security scanning, and cleanup in one 492-line file. This approach led to several challenges:</p> <p>Problems with Single Workflow Approach: - Complexity: One workflow trying to handle multiple concerns (UI, validation, setup, cleanup) - Maintainability: Large, complex workflow difficult to debug and modify - User Experience: Technical error messages and status updates not user-friendly - Error Handling: Complex nested conditions with multiple failure points - State Management: Overlapping initialization checks and complex cleanup process</p> <p>Need for Better Architecture: The initialization process naturally divides into two distinct phases: 1. User Interaction: Issue creation, validation, and communication 2. Repository Setup: Branch creation, configuration, and finalization</p>"},{"location":"adr/006-two-workflow-initialization/#decision","title":"Decision","text":"<p>Split the initialization process into two focused workflows:</p> <ol> <li><code>init.yml</code> - User interface and issue management (~40 lines, streamlined)</li> <li>Triggered on push to main branch (template creation)</li> <li>Creates initialization issue with user-friendly instructions</li> <li>Handles template vs. instance detection</li> <li> <p>Removed: README status updates (unnecessary noise)</p> </li> <li> <p><code>init-complete.yml</code> - Repository setup and configuration (~300 lines, comprehensive)</p> </li> <li>Triggered on issue comments (user providing upstream repo)</li> <li>Validates user input with clear error messages</li> <li>Performs repository setup and configuration</li> <li>Enhanced: Repository variable state management</li> <li>Enhanced: Automatic validation workflow triggering</li> <li>Streamlined: Minimal issue comments, consolidated commits</li> <li>Added: Self-cleanup of initialization workflows</li> </ol>"},{"location":"adr/006-two-workflow-initialization/#rationale","title":"Rationale","text":""},{"location":"adr/006-two-workflow-initialization/#separation-of-concerns-benefits","title":"Separation of Concerns Benefits","text":"<ol> <li>Single Responsibility: Each workflow has one clear purpose</li> <li>Maintainability: Smaller, focused files easier to understand and modify</li> <li>Debugging: Issues can be isolated to specific workflow phase</li> <li>Testing: Each workflow can be tested independently</li> <li>User Experience: Clear separation between user interaction and system setup</li> </ol>"},{"location":"adr/006-two-workflow-initialization/#user-experience-improvements","title":"User Experience Improvements","text":"<ol> <li>Friendly Communication: Welcome messages with emoji and clear instructions</li> <li>Progress Updates: Real-time status updates during setup process</li> <li>Clear Error Messages: User-friendly validation feedback</li> <li>Completion Celebration: Comprehensive summary of what was configured</li> </ol>"},{"location":"adr/006-two-workflow-initialization/#technical-architecture-benefits","title":"Technical Architecture Benefits","text":"<ol> <li>State Management: <code>.github/workflow.env</code> as primary initialization indicator</li> <li>Concurrency Control: Proper job isolation with issue-based locking</li> <li>Error Recovery: Better error handling with user feedback</li> <li>Simplified Logic: No complex cleanup process required</li> </ol>"},{"location":"adr/006-two-workflow-initialization/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/006-two-workflow-initialization/#1-maintain-single-workflow-with-refactoring","title":"1. Maintain Single Workflow with Refactoring","text":"<ul> <li>Pros: Fewer files to manage, all logic in one place</li> <li>Cons: Would still be complex, difficult to separate concerns properly</li> <li>Decision: Rejected due to fundamental complexity issues</li> </ul>"},{"location":"adr/006-two-workflow-initialization/#2-three-workflow-pattern-init-validate-setup","title":"2. Three-Workflow Pattern (Init + Validate + Setup)","text":"<ul> <li>Pros: Even more granular separation</li> <li>Cons: Over-engineering for current needs, too many moving parts</li> <li>Decision: Rejected as unnecessary complexity</li> </ul>"},{"location":"adr/006-two-workflow-initialization/#3-composite-actions-for-reusable-components","title":"3. Composite Actions for Reusable Components","text":"<ul> <li>Pros: Code reuse, modular components</li> <li>Cons: Doesn't address fundamental architecture issues</li> <li>Decision: Considered for future enhancement but not core solution</li> </ul>"},{"location":"adr/006-two-workflow-initialization/#consequences","title":"Consequences","text":""},{"location":"adr/006-two-workflow-initialization/#positive","title":"Positive","text":"<ul> <li>Dramatically Improved UX: Users get friendly guidance throughout process</li> <li>Easier Maintenance: Developers can quickly understand and modify workflows</li> <li>Better Error Handling: Clear validation with actionable feedback</li> <li>Simplified State Management: Single source of truth for initialization status</li> <li>Reduced Complexity: Each workflow handles 50% fewer concerns</li> <li>Enhanced Reliability: Fewer complex operations reduce failure points</li> </ul>"},{"location":"adr/006-two-workflow-initialization/#negative","title":"Negative","text":"<ul> <li>More Files: Two workflows instead of one (mitigated by much simpler content)</li> <li>Cross-Workflow Dependencies: <code>init-complete.yml</code> depends on issue created by <code>init.yml</code></li> <li>Learning Curve: Team needs to understand two-workflow pattern</li> </ul>"},{"location":"adr/006-two-workflow-initialization/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/006-two-workflow-initialization/#workflow-triggers","title":"Workflow Triggers","text":"<pre><code># init.yml - Template creation detection\non:\n  push:\n    branches: [main]\n\n# init-complete.yml - User response handling\non:\n  issue_comment:\n    types: [created]\n</code></pre>"},{"location":"adr/006-two-workflow-initialization/#state-management","title":"State Management","text":"<pre><code># Primary initialization indicator\necho \"INITIALIZATION_COMPLETE=true\" &gt; .github/workflow.env\necho \"UPSTREAM_REPO_URL=$UPSTREAM_URL\" &gt;&gt; .github/workflow.env\n</code></pre>"},{"location":"adr/006-two-workflow-initialization/#user-communication-pattern","title":"User Communication Pattern","text":"<pre><code># Progress updates during setup\necho \"\ud83d\udd27 **Setting up upstream connection...**\" | \n  gh issue comment \"${{ github.event.issue.number }}\" --body-file -\n\necho \"\ud83c\udf3f **Creating branch structure...**\" | \n  gh issue comment \"${{ github.event.issue.number }}\" --body-file -\n</code></pre>"},{"location":"adr/006-two-workflow-initialization/#concurrency-control","title":"Concurrency Control","text":"<pre><code>concurrency:\n  group: ${{ github.workflow }}-${{ github.event.issue.number }}\n  cancel-in-progress: false\n</code></pre>"},{"location":"adr/006-two-workflow-initialization/#success-criteria","title":"Success Criteria","text":"<ul> <li>\u2705 Initialization workflows are maintainable by team members without GitHub Actions expertise</li> <li>\u2705 Users receive clear, friendly guidance throughout the initialization process</li> <li>\u2705 Error messages provide actionable feedback for common mistakes</li> <li>\u2705 Workflow execution is more reliable with fewer failure points</li> <li>\u2705 State management is clear and consistent across deployments</li> <li>\u2705 README automatically reflects initialization status for user guidance</li> </ul>"},{"location":"adr/006-two-workflow-initialization/#migration-impact","title":"Migration Impact","text":""},{"location":"adr/006-two-workflow-initialization/#from-previous-single-workflow","title":"From Previous Single Workflow","text":"<ul> <li>Reduced Complexity: 492 lines \u2192 222 + 180 lines (better organized)</li> <li>Eliminated Complex Security Filtering: Relies on GitHub's native security features</li> <li>Removed Cleanup PR Requirement: Self-contained initialization process</li> <li>Improved Error Recovery: Better handling of edge cases and user errors</li> </ul>"},{"location":"adr/006-two-workflow-initialization/#backward-compatibility","title":"Backward Compatibility","text":"<ul> <li>Existing Repositories: Continue to work with previous initialization</li> <li>Template Updates: New pattern applies to newly created repositories</li> <li>Migration Path: Optional migration guide for existing repositories</li> </ul>"},{"location":"adr/006-two-workflow-initialization/#future-evolution","title":"Future Evolution","text":""},{"location":"adr/006-two-workflow-initialization/#potential-enhancements","title":"Potential Enhancements","text":"<ol> <li>Template Customization: Support for different initialization templates</li> <li>Advanced Validation: More sophisticated upstream repository checks</li> <li>Integration Testing: Automated validation of repository setup</li> <li>Analytics: Tracking initialization success rates and common issues</li> </ol>"},{"location":"adr/006-two-workflow-initialization/#extensibility-design","title":"Extensibility Design","text":"<ul> <li>Modular Structure: Additional validation or setup steps can be added easily</li> <li>Configuration Options: Environment variables for customizing behavior</li> <li>Error Handling Framework: Consistent patterns for handling and reporting errors</li> </ul>"},{"location":"adr/006-two-workflow-initialization/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-029: GitHub App Authentication Strategy - Authentication mechanism for initialization workflows</li> </ul> <p>\u2190 ADR-005 |  Catalog | ADR-007 \u2192</p>"},{"location":"adr/007-initialization-workflow-bootstrap/","title":"ADR-007: Initialization Workflow Bootstrap Pattern","text":""},{"location":"adr/007-initialization-workflow-bootstrap/#status","title":"Status","text":"<p>Accepted - 2025-10-01</p>"},{"location":"adr/007-initialization-workflow-bootstrap/#context","title":"Context","text":"<p>During testing with OSDU repositories, we discovered a critical bootstrap problem in the template initialization process:</p> <p>The Bootstrap Problem: When a new repository is created from this template, it runs the initialization workflow from the template's initial commit, not the current/updated version. This means any fixes or improvements to the initialization workflow (like adding <code>--allow-unrelated-histories</code> to handle merge conflicts) are not available during the actual initialization.</p> <p>Discovery Timeline: 1. User creates repository from template 2. Initialization workflow runs from commit <code>b40474835cd53d4e78bf20108e18ac6178af6842</code> 3. Workflow fails at: <code>git merge fork_integration --no-ff -m \"chore: complete repository initialization\"</code> 4. Error: <code>fatal: refusing to merge unrelated histories</code> 5. Current template already has the fix: <code>--allow-unrelated-histories</code> flag 6. But the fix isn't available to the running workflow</p> <p>Additional Discovery: Even with <code>--allow-unrelated-histories</code>, merge conflicts occur in common files: - <code>.gitignore</code> - Template version vs upstream version - <code>README.md</code> - Template documentation vs upstream documentation - Solution requires <code>-X theirs</code> merge strategy to automatically resolve conflicts</p> <p>Permission Discovery: The built-in GITHUB_TOKEN lacks permissions to create repository secrets: - Error: <code>HTTP 403: Resource not accessible by integration</code> - Solution: Use Personal Access Token (PAT) stored as <code>GH_TOKEN</code> secret - Fallback: Skip secret creation with warning if PAT not available</p> <p>Root Cause: GitHub Actions runs workflows from the commit that triggered the event. For template-created repositories, this is the initial commit containing the old workflow version, creating a chicken-and-egg problem.</p>"},{"location":"adr/007-initialization-workflow-bootstrap/#decision","title":"Decision","text":"<p>Implement a self-updating initialization workflow pattern:</p> <ol> <li>Phase 1: Bootstrap Update - The initialization workflow first updates itself from the template repository</li> <li>Phase 2: Execute Initialization - Run the updated workflow logic</li> </ol> <p>This ensures that any fixes or improvements to the initialization process are immediately available to new repositories.</p>"},{"location":"adr/007-initialization-workflow-bootstrap/#rationale","title":"Rationale","text":""},{"location":"adr/007-initialization-workflow-bootstrap/#why-this-matters","title":"Why This Matters","text":"<ol> <li>Fix Propagation: Critical fixes reach new repositories immediately</li> <li><code>--allow-unrelated-histories</code> for unrelated history errors</li> <li><code>-X theirs</code> for automatic merge conflict resolution</li> <li>Continuous Improvement: Template improvements benefit all future users</li> <li>Reduced Support: Users don't encounter already-fixed issues</li> <li>Maintainability: Single source of truth for initialization logic</li> </ol>"},{"location":"adr/007-initialization-workflow-bootstrap/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"adr/007-initialization-workflow-bootstrap/#1-document-manual-workarounds","title":"1. Document Manual Workarounds","text":"<ul> <li>Approach: Tell users to manually run missing commands when initialization fails</li> <li>Pros: Simple, no code changes needed</li> <li>Cons: Poor user experience, requires technical knowledge, defeats automation purpose</li> <li>Decision: Rejected - Goes against the template's goal of automation</li> </ul>"},{"location":"adr/007-initialization-workflow-bootstrap/#2-pre-create-all-branches-in-template","title":"2. Pre-create All Branches in Template","text":"<ul> <li>Approach: Include fork_upstream and fork_integration branches in template</li> <li>Pros: Might avoid unrelated histories issue</li> <li>Cons: Pollutes template with upstream-specific content, still doesn't solve workflow updates</li> <li>Decision: Rejected - Doesn't address root cause</li> </ul>"},{"location":"adr/007-initialization-workflow-bootstrap/#3-external-initialization-script","title":"3. External Initialization Script","text":"<ul> <li>Approach: Use a separate script hosted externally that gets downloaded and run</li> <li>Pros: Always runs latest version</li> <li>Cons: External dependency, security concerns, complexity</li> <li>Decision: Rejected - Adds unnecessary external dependencies</li> </ul>"},{"location":"adr/007-initialization-workflow-bootstrap/#4-two-stage-workflow-with-self-update","title":"4. Two-Stage Workflow with Self-Update","text":"<ul> <li>Approach: Workflow updates itself before running initialization</li> <li>Pros: Self-contained, automatic, always uses latest fixes</li> <li>Cons: Slightly more complex workflow logic</li> <li>Decision: Accepted - Best balance of automation and reliability</li> </ul>"},{"location":"adr/007-initialization-workflow-bootstrap/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/007-initialization-workflow-bootstrap/#proposed-workflow-structure","title":"Proposed Workflow Structure","text":"<pre><code>name: Initialize Fork\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  update-workflow:\n    name: Update initialization workflow\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout current repository\n        uses: actions/checkout@v5\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Fetch latest workflow from template\n        run: |\n          # Add template as remote\n          git remote add template https://github.com/azure/osdu-spi.git\n          git fetch template main\n\n          # Update workflows to latest version\n          git checkout template/main -- .github/workflows/init.yml\n          git checkout template/main -- .github/workflows/init-complete.yml\n\n          # Commit if changes exist\n          if git diff --staged --quiet; then\n            echo \"Workflows are already up to date\"\n          else\n            git config user.name \"github-actions[bot]\"\n            git config user.email \"github-actions[bot]@users.noreply.github.com\"\n            git commit -m \"chore: update initialization workflows to latest version\"\n            git push\n          fi\n\n  initialize:\n    name: Initialize repository\n    needs: update-workflow\n    uses: ./.github/workflows/init-complete.yml\n    # Now runs with updated workflow\n</code></pre>"},{"location":"adr/007-initialization-workflow-bootstrap/#key-design-elements","title":"Key Design Elements","text":"<ol> <li>Self-Updating: Workflow fetches its own latest version before executing</li> <li>Idempotent: Safe to run multiple times, only updates if changes exist  </li> <li>Transparent: Users see workflow update commit in history</li> <li>Secure: Uses same permissions, no external dependencies</li> </ol>"},{"location":"adr/007-initialization-workflow-bootstrap/#consequences","title":"Consequences","text":""},{"location":"adr/007-initialization-workflow-bootstrap/#positive","title":"Positive","text":"<ul> <li>Automatic Fix Distribution: All template improvements immediately available</li> <li>Reduced User Friction: Initialization \"just works\" with latest fixes</li> <li>Simplified Support: No need to maintain fix instructions for old versions</li> <li>Better User Experience: Users always get the best version of initialization</li> <li>Traceable Updates: Git history shows when workflows were updated</li> </ul>"},{"location":"adr/007-initialization-workflow-bootstrap/#negative","title":"Negative","text":"<ul> <li>Additional Complexity: Two-phase initialization adds complexity</li> <li>Extra Commit: Creates an additional commit in repository history</li> <li>Potential Conflicts: If user modifies workflows before initialization completes</li> <li>Dependency on Template: Requires template repository to remain accessible</li> </ul>"},{"location":"adr/007-initialization-workflow-bootstrap/#mitigation-strategies","title":"Mitigation Strategies","text":"<ol> <li>Clear Documentation: Explain the self-update process in initialization issue</li> <li>Error Handling: Graceful fallback if template fetch fails</li> <li>Version Checking: Only update if template version is newer</li> <li>Conflict Prevention: Check for local modifications before updating</li> </ol>"},{"location":"adr/007-initialization-workflow-bootstrap/#success-criteria","title":"Success Criteria","text":"<ul> <li>\u2705 New repositories always use latest initialization workflow</li> <li>\u2705 Critical fixes are immediately available:</li> <li><code>--allow-unrelated-histories</code> for unrelated history errors</li> <li><code>-X theirs</code> for automatic merge conflict resolution</li> <li>PAT token usage for secret creation operations</li> <li>Template file cleanup and repository-specific README generation</li> <li>\u2705 Users don't encounter previously-fixed initialization issues</li> <li>\u2705 Workflow updates are transparent in git history</li> <li>\u2705 Process handles edge cases gracefully (template unavailable, etc.)</li> <li>\u2705 Template documentation is cleaned up after initialization</li> </ul>"},{"location":"adr/007-initialization-workflow-bootstrap/#actual-implementation","title":"Actual Implementation","text":"<p>The bootstrap problem was solved using Local Actions Pattern instead of the workflow self-update approach described above:</p>"},{"location":"adr/007-initialization-workflow-bootstrap/#solution-extracted-local-actions","title":"Solution: Extracted Local Actions","text":"<p>Critical initialization logic was extracted to <code>.github/local-actions/merge-with-theirs-resolution/</code>:</p> <pre><code># .github/local-actions/merge-with-theirs-resolution/action.sh\ngit merge \"$SOURCE_BRANCH\" --allow-unrelated-histories --no-ff -X theirs -m \"$COMMIT_MESSAGE\"\n</code></pre>"},{"location":"adr/007-initialization-workflow-bootstrap/#why-this-works","title":"Why This Works","text":"<ol> <li>Always Available: Local actions are part of the template repository and copied during initialization</li> <li>No Bootstrap Problem: Since the action exists in the initial commit, fixes are automatically available</li> <li>Cleaner Architecture: Reusable action provides better separation than embedded workflow code</li> <li>No External Dependencies: Self-contained within the repository</li> </ol>"},{"location":"adr/007-initialization-workflow-bootstrap/#usage-in-init-completeyml","title":"Usage in init-complete.yml","text":"<pre><code>- name: Complete initialization\n  uses: ./.github/local-actions/merge-with-theirs-resolution\n  with:\n    source_branch: fork_integration\n    target_branch: main\n    commit_message: \"chore: complete repository initialization\"\n</code></pre>"},{"location":"adr/007-initialization-workflow-bootstrap/#benefits-over-self-update-approach","title":"Benefits Over Self-Update Approach","text":"<ul> <li>\u2705 Simpler: No two-phase initialization complexity</li> <li>\u2705 Reliable: No dependency on template repository accessibility</li> <li>\u2705 Clean History: No bootstrap commits</li> <li>\u2705 Testable: Local actions can be tested independently</li> <li>\u2705 Maintainable: Single source of truth in <code>.github/local-actions/</code></li> </ul>"},{"location":"adr/007-initialization-workflow-bootstrap/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-028: Workflow Script Extraction Pattern - Documents the local actions pattern used</li> <li>ADR-012: Template Update Propagation Strategy - How template improvements reach existing forks</li> <li>ADR-006: Two-Workflow Initialization Pattern - This ADR builds upon the two-workflow pattern</li> <li>ADR-003: Template Repository Pattern - Aligns with template-based architecture</li> </ul> <p>\u2190 ADR-006 |  Catalog | ADR-008 \u2192</p>"},{"location":"adr/008-centralized-label-management/","title":"ADR-008: Centralized Label Management Strategy","text":""},{"location":"adr/008-centralized-label-management/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/008-centralized-label-management/#context","title":"Context","text":"<p>The Fork Management Template uses GitHub labels extensively to track workflow states, issue types, and PR statuses across multiple automated workflows. Initially, each workflow created its own labels when first run:</p> <ul> <li><code>sync.yml</code> created sync-related labels</li> <li><code>init.yml</code> created initialization labels</li> <li><code>dependabot-validation.yml</code> created dependency labels</li> <li>The new <code>cascade.yml</code> workflow requires additional state-tracking labels</li> </ul> <p>This distributed approach led to several issues: 1. Labels didn't exist until workflows ran, potentially breaking automation 2. No single source of truth for label definitions 3. Inconsistent label colors and descriptions 4. Difficult to maintain and document label usage 5. New workflows couldn't rely on labels existing</p>"},{"location":"adr/008-centralized-label-management/#decision","title":"Decision","text":"<p>We will implement a centralized label management strategy where:</p> <ol> <li>All system labels are defined in <code>.github/labels.json</code></li> <li>The initialization workflow creates all labels during repository setup</li> <li>Workflows assume labels exist and do not create them</li> <li>Label documentation is maintained in <code>doc/label-strategy.md</code></li> </ol>"},{"location":"adr/008-centralized-label-management/#consequences","title":"Consequences","text":""},{"location":"adr/008-centralized-label-management/#positive","title":"Positive","text":"<ul> <li>Reliability: All labels exist from repository initialization</li> <li>Consistency: Single source of truth for label definitions</li> <li>Maintainability: Easy to add, update, or remove labels</li> <li>Documentation: Clear reference for label usage</li> <li>Automation: Workflows can depend on label existence</li> <li>Visibility: Complete label set visible from day one</li> </ul>"},{"location":"adr/008-centralized-label-management/#negative","title":"Negative","text":"<ul> <li>Initial Setup: Slightly longer initialization process</li> <li>Migration: Existing repositories need manual label sync</li> <li>Coupling: Workflows depend on initialization running first</li> </ul>"},{"location":"adr/008-centralized-label-management/#neutral","title":"Neutral","text":"<ul> <li>Versioning: Label changes tracked in git history</li> <li>Customization: Users can modify labels.json for their needs</li> </ul>"},{"location":"adr/008-centralized-label-management/#implementation","title":"Implementation","text":""},{"location":"adr/008-centralized-label-management/#label-configuration-file","title":"Label Configuration File","text":"<pre><code>{\n  \"labels\": [\n    {\n      \"name\": \"cascade-active\",\n      \"description\": \"Currently processing through cascade pipeline\",\n      \"color\": \"0e8a16\"\n    }\n    // ... more labels\n  ]\n}\n</code></pre>"},{"location":"adr/008-centralized-label-management/#initialization-workflow-update","title":"Initialization Workflow Update","text":"<pre><code>- name: Create all system labels\n  run: |\n    labels=$(cat .github/labels.json | jq -r '.labels[] | @base64')\n    for label in $labels; do\n      # Create each label from configuration\n    done\n</code></pre>"},{"location":"adr/008-centralized-label-management/#workflow-usage-pattern","title":"Workflow Usage Pattern","text":"<pre><code># Workflows now assume labels exist\ngh pr create --label \"cascade-active,upstream-sync\"\n</code></pre>"},{"location":"adr/008-centralized-label-management/#related","title":"Related","text":"<ul> <li>ADR-002: GitHub Actions Workflow Automation</li> <li>ADR-007: Initialization Workflow Bootstrap Process</li> <li>Label Management Strategy</li> <li>Cascade Workflow Specification</li> </ul> <p>\u2190 ADR-007 |  Catalog | ADR-009 \u2192</p>"},{"location":"adr/009-asymmetric-cascade-review-strategy/","title":"ADR-009: Asymmetric Cascade Review Strategy","text":""},{"location":"adr/009-asymmetric-cascade-review-strategy/#status","title":"Status","text":"<p>Accepted  </p>"},{"location":"adr/009-asymmetric-cascade-review-strategy/#context","title":"Context","text":"<p>The cascade workflow moves upstream changes through a three-branch hierarchy: 1. <code>fork_upstream</code> \u2192 <code>fork_integration</code>  2. <code>fork_integration</code> \u2192 <code>main</code></p> <p>With the implementation of human-centric cascade triggering (ADR-019) and issue lifecycle tracking (ADR-022), we needed to balance automation efficiency with safety, ensuring that upstream changes are properly vetted before reaching production while minimizing manual intervention where safe.</p> <p>Key considerations: - Upstream changes are external and potentially breaking - Integration branch serves as a testing ground - Main branch is production and must remain stable - Manual cascade triggering provides explicit human control - Conflict resolution always requires human intervention - Issue tracking provides visibility into review status</p>"},{"location":"adr/009-asymmetric-cascade-review-strategy/#decision","title":"Decision","text":"<p>We will implement an asymmetric review strategy for cascade PRs:</p> <ol> <li>Fork_upstream \u2192 Fork_integration: Human-initiated with comprehensive validation</li> <li>Triggered manually by humans after reviewing upstream sync PR</li> <li>Issue lifecycle tracking provides visibility into integration status</li> <li>Conflicts are most likely to occur here</li> <li>Human judgment needed to assess upstream impact</li> <li>Comprehensive validation: Build, test, and lint checks run on integration branch</li> <li> <p>Validation failures: Block cascade and create detailed failure issues</p> </li> <li> <p>Fork_integration \u2192 Main: Always requires human review  </p> </li> <li>All production PRs require manual approval before merge</li> <li>Ensures final human oversight before changes reach production</li> <li>Changes already validated and proven stable in integration branch</li> <li>Quality gate: Only validated changes that pass all checks reach production</li> </ol>"},{"location":"adr/009-asymmetric-cascade-review-strategy/#consequences","title":"Consequences","text":""},{"location":"adr/009-asymmetric-cascade-review-strategy/#positive","title":"Positive","text":"<ul> <li>Safety First: External changes get human review at entry point</li> <li>Production Safety: All production changes require final human approval</li> <li>Quality Assurance: Comprehensive build, test, and validation on integration branch</li> <li>Early Detection: Integration validation catches issues before production PRs</li> <li>Clear Boundaries: Integration branch serves its purpose as a true validation gate</li> <li>Risk Mitigation: Human oversight and automated validation at both critical decision points</li> <li>Audit Trail: Complete human review history and validation logs for all production deployments</li> <li>Issue Tracking: Detailed failure tracking with error logs and resolution guidance</li> </ul>"},{"location":"adr/009-asymmetric-cascade-review-strategy/#negative","title":"Negative","text":"<ul> <li>Manual Overhead: All production PRs require human review and approval</li> <li>Potential Delays: Manual review may slow deployment of routine updates</li> <li>Review Fatigue: Teams need to review both integration and production PRs</li> </ul>"},{"location":"adr/009-asymmetric-cascade-review-strategy/#neutral","title":"Neutral","text":"<ul> <li>Monitoring Required: Need to track manual review timing and bottlenecks</li> <li>Process Efficiency: Teams can develop patterns for faster routine reviews</li> <li>Flexibility: Emergency procedures can be established for critical fixes</li> </ul>"},{"location":"adr/009-asymmetric-cascade-review-strategy/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/009-asymmetric-cascade-review-strategy/#phase-1-human-initiated-integration-with-validation","title":"Phase 1 (Human-Initiated Integration with Validation)","text":"<pre><code># Humans manually trigger cascade after reviewing sync PR\n# Cascade workflow updates issue tracking\ngh issue edit \"$ISSUE_NUMBER\" \\\n  --remove-label \"human-required\" \\\n  --add-label \"cascade-active\"\n\n# Integration proceeds with merge and comprehensive validation\n# 1. Merge fork_upstream to fork_integration (conflict detection)\n# 2. Run comprehensive validation (build, test, lint)\n# 3. Report validation results to tracking issue\n\n# If conflicts detected OR validation fails:\n#   - Issue updated to cascade-blocked\n#   - Detailed failure issue created with logs and resolution steps\n#   - Cascade to main blocked until resolution\n</code></pre>"},{"location":"adr/009-asymmetric-cascade-review-strategy/#phase-2-production-pr-creation-only-after-validation-passes","title":"Phase 2 (Production PR Creation - Only After Validation Passes)","text":"<pre><code># Production PR only created if integration validation successful\n# Condition: integration_success == 'true' &amp;&amp; conflicts_found == 'false'\n\n# Create production PR from validated fork_integration to main\nRELEASE_BRANCH=\"release/upstream-$(date +%Y%m%d-%H%M%S)\"\nPR_URL=$(gh pr create \\\n  --base main \\\n  --head $RELEASE_BRANCH \\\n  --title \"\ud83d\ude80 Production Release: Upstream Integration - $(date +%Y-%m-%d)\" \\\n  --body \"$PR_BODY\" \\\n  --label \"upstream-sync,human-required\")\n\n# Update tracking issue - production PR created\ngh issue comment \"$TRACKING_ISSUE\" --body \"\ud83c\udfaf **Production PR Created** - $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nIntegration completed successfully! Production PR has been created and is ready for final review.\"\n\n# All production PRs require manual review (implicit)\n</code></pre>"},{"location":"adr/009-asymmetric-cascade-review-strategy/#alternatives-considered","title":"Alternatives Considered","text":"<ol> <li>Fully Automated: Auto-merge at both stages when clean</li> <li> <p>Rejected: Too risky for external changes reaching production</p> </li> <li> <p>Conditional Auto-merge: Auto-merge second stage based on size/changes</p> </li> <li> <p>Rejected: Even clean changes benefit from human oversight before production</p> </li> <li> <p>Reversed Asymmetry: Auto-merge first stage, manual second</p> </li> <li>Rejected: Backwards from a safety perspective</li> </ol>"},{"location":"adr/009-asymmetric-cascade-review-strategy/#related","title":"Related","text":"<ul> <li>ADR-001: Three-Branch Fork Management Strategy</li> <li>ADR-005: Automated Conflict Management Strategy</li> <li>ADR-019: Cascade Monitor Pattern - Human-centric cascade triggering</li> <li>ADR-022: Issue Lifecycle Tracking Pattern - Integration with issue tracking</li> <li>Cascade Workflow Specification</li> </ul> <p>\u2190 ADR-008 |  Catalog | ADR-010 \u2192</p>"},{"location":"adr/010-yaml-safe-shell-scripting/","title":"ADR-010: YAML-Safe Shell Scripting in GitHub Actions","text":""},{"location":"adr/010-yaml-safe-shell-scripting/#status","title":"Status","text":"<p>Accepted - 2025-10-01</p>"},{"location":"adr/010-yaml-safe-shell-scripting/#context","title":"Context","text":"<p>GitHub Actions workflows use YAML syntax to define shell scripts, which creates potential conflicts when shell scripts contain YAML-meaningful characters. During implementation of the initialization completion message system, we encountered YAML parsing errors caused by:</p> <p>Problematic Patterns: - Heredocs with colons: <code>Here's what was set up:</code> interpreted as YAML mapping - Multiline string assignments: Complex heredoc syntax within YAML run blocks - Special characters: Backticks, quotes, and colons within shell variable assignments - Mixed contexts: Shell script syntax nested within YAML string contexts</p> <p>Example of Problematic Code: <pre><code>run: |\n  MANUAL_STEPS=\"## Manual Configuration Required\n\n  Since no GH_TOKEN was provided, please complete these steps:\n\n  ### 1. Branch Protection  \n  - Go to Settings \u2192 Branches\n  - For each branch (`main`, `fork_upstream`, `fork_integration`):\n    - Require pull request reviews before merging\n  \"\n</code></pre></p> <p>YAML Parser Errors: - <code>line 351: could not find expected ':'</code> - <code>line 353: mapping values are not allowed in this context</code></p>"},{"location":"adr/010-yaml-safe-shell-scripting/#decision","title":"Decision","text":"<p>Establish YAML-Safe Shell Scripting Patterns for GitHub Actions workflows:</p>"},{"location":"adr/010-yaml-safe-shell-scripting/#1-avoid-complex-heredocs-in-variable-assignments","title":"1. Avoid Complex Heredocs in Variable Assignments","text":"<p>\u274c Don't: <pre><code>VARIABLE=$(cat &lt;&lt; 'EOF'\nMulti-line content with: colons\nAnd other YAML-meaningful characters\nEOF\n)\n</code></pre></p> <p>\u2705 Do: <pre><code>VARIABLE=\"Simple single-line message without YAML conflicts\"\n</code></pre></p>"},{"location":"adr/010-yaml-safe-shell-scripting/#2-use-external-files-for-complex-content","title":"2. Use External Files for Complex Content","text":"<p>\u274c Don't: Embed complex markdown/text in shell variables</p> <p>\u2705 Do: Store complex content in separate files and reference them</p>"},{"location":"adr/010-yaml-safe-shell-scripting/#3-escape-yaml-meaningful-characters","title":"3. Escape YAML-Meaningful Characters","text":"<p>\u274c Don't: <code>Here's what was set up:</code></p> <p>\u2705 Do: <code>Here is what was set up</code> (avoid apostrophes in workflow text)</p>"},{"location":"adr/010-yaml-safe-shell-scripting/#4-prefer-simple-string-concatenation","title":"4. Prefer Simple String Concatenation","text":"<p>\u274c Don't: Complex multiline assignments within YAML</p> <p>\u2705 Do: Build complex messages using simple string concatenation or external templates</p>"},{"location":"adr/010-yaml-safe-shell-scripting/#5-test-yaml-validity-during-development","title":"5. Test YAML Validity During Development","text":"<p>Required Command: <pre><code>yq eval '.github/workflows/workflow-name.yml' &gt;/dev/null &amp;&amp; echo \"\u2705 YAML is valid\" || echo \"\u274c YAML has errors\"\n</code></pre></p>"},{"location":"adr/010-yaml-safe-shell-scripting/#rationale","title":"Rationale","text":""},{"location":"adr/010-yaml-safe-shell-scripting/#technical-benefits","title":"Technical Benefits","text":"<ol> <li>Reliability: Prevents workflow failures due to YAML parsing errors</li> <li>Maintainability: Simpler patterns easier to debug and modify</li> <li>Predictability: Consistent behavior across different YAML parsers</li> <li>Validation: Easy to validate syntax during development</li> </ol>"},{"location":"adr/010-yaml-safe-shell-scripting/#development-benefits","title":"Development Benefits","text":"<ol> <li>Faster Development: Avoid debugging complex YAML/shell interactions</li> <li>Team Productivity: Clear patterns reduce time spent on syntax issues</li> <li>CI/CD Stability: Prevent workflow failures in critical automation</li> </ol>"},{"location":"adr/010-yaml-safe-shell-scripting/#implementation","title":"Implementation","text":""},{"location":"adr/010-yaml-safe-shell-scripting/#immediate-actions","title":"Immediate Actions","text":"<ol> <li>\u2705 Fixed init-complete.yml with simplified manual steps message</li> <li>\u2705 Established YAML validation as part of development process</li> </ol>"},{"location":"adr/010-yaml-safe-shell-scripting/#going-forward","title":"Going Forward","text":"<ol> <li>Code Review Requirement: All workflow changes must pass YAML validation</li> <li>Pattern Documentation: This ADR serves as reference for team development</li> <li>Template Updates: Apply these patterns to workflow templates</li> </ol>"},{"location":"adr/010-yaml-safe-shell-scripting/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/010-yaml-safe-shell-scripting/#alternative-1-external-template-files","title":"Alternative 1: External Template Files","text":"<p>Pros: Complete separation of complex content from YAML</p> <p>Cons: Additional file management, less self-contained workflows</p>"},{"location":"adr/010-yaml-safe-shell-scripting/#alternative-2-json-encoded-strings","title":"Alternative 2: JSON-Encoded Strings","text":"<p>Pros: Guaranteed YAML compatibility</p> <p>Cons: Reduced readability, complex escaping</p>"},{"location":"adr/010-yaml-safe-shell-scripting/#alternative-3-github-actions-expressions","title":"Alternative 3: GitHub Actions Expressions","text":"<p>Pros: Native GitHub syntax</p> <p>Cons: Limited formatting capabilities, expression complexity</p> <p>Decision: Chose simple string patterns for optimal balance of readability and reliability.</p>"},{"location":"adr/010-yaml-safe-shell-scripting/#consequences","title":"Consequences","text":""},{"location":"adr/010-yaml-safe-shell-scripting/#positive","title":"Positive","text":"<ul> <li>Workflow Reliability: Eliminates YAML parsing errors</li> <li>Development Speed: Clear patterns reduce debugging time</li> <li>Team Knowledge: Establishes best practices for complex workflows</li> </ul>"},{"location":"adr/010-yaml-safe-shell-scripting/#negative","title":"Negative","text":"<ul> <li>Content Limitations: Complex formatted messages require external files</li> <li>Pattern Learning: Team needs to adopt new development patterns</li> </ul>"},{"location":"adr/010-yaml-safe-shell-scripting/#mitigation","title":"Mitigation","text":"<ul> <li>Documentation: This ADR provides clear guidance</li> <li>Validation Tools: YAML checking integrated into development process</li> <li>Examples: Working patterns documented for reference</li> </ul>"},{"location":"adr/010-yaml-safe-shell-scripting/#references","title":"References","text":"<ul> <li>GitHub Actions Documentation: Workflow syntax for GitHub Actions</li> <li>YAML Specification: YAML Ain't Markup Language (YAML\u2122) 1.2</li> <li>Related ADR: ADR-006: Two-Workflow Initialization Pattern</li> </ul> <p>\u2190 ADR-009 |  Catalog | ADR-011 \u2192</p>"},{"location":"adr/011-configuration-driven-template-sync/","title":"ADR-011: Configuration-Driven Template Synchronization","text":""},{"location":"adr/011-configuration-driven-template-sync/#status","title":"Status","text":"<p>Accepted - 2025-10-01</p>"},{"location":"adr/011-configuration-driven-template-sync/#context","title":"Context","text":"<p>The original template repository pattern (ADR-003) created a bootstrap problem: once repositories were created from the template, there was no systematic way to propagate template improvements (workflow updates, security patches, new features) to existing forked repositories without manual intervention or repository recreation.</p> <p>Problems with Static Template Approach:</p> <ul> <li>Template Drift: Forked repositories became outdated as template improved</li> <li>Manual Updates: No automated way to get workflow improvements</li> <li>Inconsistent Infrastructure: Repositories diverged from template over time</li> <li>Security Lag: Security improvements in template didn't reach existing forks</li> <li>Maintenance Burden: Teams had to manually track and apply template changes</li> </ul> <p>Need for Systematic Sync Management:</p> <ul> <li>Define exactly which files should be synchronized between template and forks</li> <li>Distinguish between template-management files and project-essential files</li> <li>Handle cleanup of template-specific content during initialization</li> <li>Provide visibility into what gets synced and why</li> </ul>"},{"location":"adr/011-configuration-driven-template-sync/#decision","title":"Decision","text":"<p>Implement a Configuration-Driven Template Synchronization System using <code>.github/sync-config.json</code> to define:</p>"},{"location":"adr/011-configuration-driven-template-sync/#1-sync-configuration-file-githubsync-configjson","title":"1. Sync Configuration File: <code>.github/sync-config.json</code>","text":"<pre><code>{\n  \"sync_rules\": {\n    \"directories\": [],      // Directories synced entirely\n    \"files\": [],           // Individual files synced\n    \"workflows\": {\n      \"essential\": [],     // Workflows copied to forks\n      \"template_only\": []  // Workflows that stay in template\n    },\n    \"tracking_files\": []   // Auto-managed sync state files\n  },\n  \"cleanup_rules\": {\n    \"directories\": [],     // Directories removed during init\n    \"files\": [],          // Files removed during init\n    \"workflows\": []       // Workflows removed during init\n  },\n  \"exclusions\": []        // Files never synced\n}\n</code></pre>"},{"location":"adr/011-configuration-driven-template-sync/#2-selective-file-synchronization","title":"2. Selective File Synchronization","text":"<ul> <li>Essential Infrastructure: Issue templates, PR templates, security configs, labels</li> <li>Essential Workflows: Sync, validate, build, release, template-sync, dependabot-validation</li> <li>Template-Only Content: Initialization workflows, cascade management, template documentation</li> <li>Cleanup Content: Template-specific files removed during repository initialization</li> </ul>"},{"location":"adr/011-configuration-driven-template-sync/#3-configuration-aware-workflows","title":"3. Configuration-Aware Workflows","text":"<ul> <li><code>init-complete.yml</code>: Uses sync config to copy only essential files during initialization</li> <li><code>template-sync.yml</code>: Uses sync config to determine what files to check for updates</li> <li>Tracking System: <code>.github/.template-sync-commit</code> tracks last synced template version</li> </ul>"},{"location":"adr/011-configuration-driven-template-sync/#rationale","title":"Rationale","text":""},{"location":"adr/011-configuration-driven-template-sync/#benefits-of-configuration-driven-approach","title":"Benefits of Configuration-Driven Approach","text":"<ol> <li>Maintainable: Single source of truth for sync behavior</li> <li>Visible: Clear documentation of what gets synced and why</li> <li>Flexible: Easy to add/remove files from sync process</li> <li>Consistent: All forked repositories get same essential infrastructure</li> <li>Safe: Explicit rules prevent accidental over-syncing or under-syncing</li> <li>Auditable: Changes to sync behavior are tracked in version control</li> </ol>"},{"location":"adr/011-configuration-driven-template-sync/#solving-template-drift-problem","title":"Solving Template Drift Problem","text":"<ol> <li>Automated Propagation: Template improvements automatically reach forks</li> <li>Selective Updates: Only essential files get updated, not project-specific content</li> <li>Conflict Prevention: Clear separation between template and project concerns</li> <li>Version Tracking: Track what template version each fork is synchronized to</li> </ol>"},{"location":"adr/011-configuration-driven-template-sync/#initialization-cleanup-benefits","title":"Initialization Cleanup Benefits","text":"<ol> <li>Clean Forks: Remove template development artifacts from forked repositories</li> <li>Documented Cleanup: Clear reasons for each cleanup rule</li> <li>Consistent Results: All forks have same clean starting state</li> <li>Future-Proof: Easy to adjust cleanup behavior</li> </ol>"},{"location":"adr/011-configuration-driven-template-sync/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/011-configuration-driven-template-sync/#1-manual-sync-documentation","title":"1. Manual Sync Documentation","text":"<ul> <li>Pros: Simple, no automation complexity</li> <li>Cons: Error-prone, time-consuming, rarely followed</li> <li>Decision: Rejected due to poor adoption and consistency</li> </ul>"},{"location":"adr/011-configuration-driven-template-sync/#2-git-subtreesubmodule-for-template","title":"2. Git Subtree/Submodule for Template","text":"<ul> <li>Pros: Native Git functionality</li> <li>Cons: Complex for users, doesn't handle selective syncing</li> <li>Decision: Rejected due to user experience complexity</li> </ul>"},{"location":"adr/011-configuration-driven-template-sync/#3-hardcoded-sync-lists-in-workflows","title":"3. Hardcoded Sync Lists in Workflows","text":"<ul> <li>Pros: Direct, no additional configuration</li> <li>Cons: Difficult to maintain, no documentation of decisions</li> <li>Decision: Rejected due to maintainability concerns</li> </ul>"},{"location":"adr/011-configuration-driven-template-sync/#4-external-sync-service","title":"4. External Sync Service","text":"<ul> <li>Pros: Powerful, could handle complex scenarios</li> <li>Cons: External dependency, additional infrastructure</li> <li>Decision: Rejected due to complexity and dependencies</li> </ul>"},{"location":"adr/011-configuration-driven-template-sync/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/011-configuration-driven-template-sync/#sync-configuration-categories","title":"Sync Configuration Categories","text":""},{"location":"adr/011-configuration-driven-template-sync/#essential-infrastructure-files","title":"Essential Infrastructure Files","text":"<pre><code>{\n  \"directories\": [\n    \".github/ISSUE_TEMPLATE\",\n    \".github/PULL_REQUEST_TEMPLATE\", \n    \".github/actions\"\n  ],\n  \"files\": [\n    \".github/dependabot.yml\",\n    \".github/labels.json\",\n    \".github/branch-protection.json\",\n    \".github/security-on.json\",\n    \".github/security-off.json\",\n    \".github/security-patterns.txt\"\n  ]\n}\n</code></pre>"},{"location":"adr/011-configuration-driven-template-sync/#essential-vs-template-only-workflows","title":"Essential vs Template-Only Workflows","text":"<pre><code>{\n  \"workflows\": {\n    \"essential\": [\n      \".github/workflows/sync.yml\",\n      \".github/workflows/validate.yml\",\n      \".github/workflows/build.yml\", \n      \".github/workflows/release.yml\",\n      \".github/workflows/template-sync.yml\",\n      \".github/workflows/dependabot-validation.yml\"\n    ],\n    \"template_only\": [\n      \".github/workflows/init.yml\",\n      \".github/workflows/init-complete.yml\",\n      \".github/workflows/cascade.yml\",\n      \".github/workflows/cascade-monitor.yml\"\n    ]\n  }\n}\n</code></pre>"},{"location":"adr/011-configuration-driven-template-sync/#initialization-cleanup-rules","title":"Initialization Cleanup Rules","text":"<pre><code>{\n  \"cleanup_rules\": {\n    \"directories\": [\n      {\"path\": \"doc/\", \"reason\": \"Template documentation replaced by upstream project docs\"}\n    ],\n    \"files\": [\n      {\"path\": \".github/copilot-instructions.md\", \"reason\": \"Template-specific AI instructions\"}\n    ],\n    \"workflows\": [\n      {\"path\": \".github/workflows/init.yml\", \"reason\": \"One-time initialization workflow\"},\n      {\"path\": \".github/workflows/init-complete.yml\", \"reason\": \"One-time setup workflow\"}\n    ]\n  }\n}\n</code></pre>"},{"location":"adr/011-configuration-driven-template-sync/#configuration-usage-patterns","title":"Configuration Usage Patterns","text":""},{"location":"adr/011-configuration-driven-template-sync/#during-initialization-init-completeyml","title":"During Initialization (init-complete.yml)","text":"<pre><code># Copy directories that should be synced entirely\nDIRECTORIES=$(jq -r '.sync_rules.directories[] | .path' .github/sync-config.json)\nfor dir in $DIRECTORIES; do\n  git checkout main -- \"$dir/\" || echo \"Directory $dir not found, skipping\"\ndone\n\n# Remove template-specific content using cleanup rules\nCLEANUP_DIRS=$(jq -r '.cleanup_rules.directories[]? | .path' .github/sync-config.json)\nfor dir in $CLEANUP_DIRS; do\n  rm -rf \"$dir\"\ndone\n</code></pre>"},{"location":"adr/011-configuration-driven-template-sync/#during-template-sync-template-syncyml","title":"During Template Sync (template-sync.yml)","text":"<pre><code># Check for changes only in configured sync paths\nSYNC_PATHS=\"\"\nDIRECTORIES=$(jq -r '.sync_rules.directories[] | .path' temp-sync-config.json)\nfor dir in $DIRECTORIES; do\n  SYNC_PATHS=\"$SYNC_PATHS $dir\"\ndone\n\n# Check for changes in the configured paths only\nfor path in $SYNC_PATHS; do\n  CHANGES=$(git diff --name-only $LAST_SYNC_COMMIT..$TEMPLATE_COMMIT template/main -- \"$path\")\ndone\n</code></pre>"},{"location":"adr/011-configuration-driven-template-sync/#consequences","title":"Consequences","text":""},{"location":"adr/011-configuration-driven-template-sync/#positive","title":"Positive","text":"<ul> <li>Eliminates Template Drift: Forked repositories automatically stay current with template</li> <li>Selective Synchronization: Only essential infrastructure gets updated</li> <li>Clean Repository State: Template artifacts automatically removed during initialization</li> <li>Maintainable Sync Logic: Single configuration file controls all sync behavior</li> <li>Transparent Process: Clear documentation of what gets synced and why</li> <li>Version Tracking: Track template synchronization history</li> <li>Conflict Prevention: Clear boundaries between template and project content</li> </ul>"},{"location":"adr/011-configuration-driven-template-sync/#negative","title":"Negative","text":"<ul> <li>Configuration Complexity: Additional configuration file to maintain</li> <li>Bootstrap Dependency: Sync configuration must exist before sync can work</li> <li>Learning Curve: Team needs to understand sync configuration structure</li> <li>JSON Management: Configuration changes require JSON syntax knowledge</li> </ul>"},{"location":"adr/011-configuration-driven-template-sync/#mitigation-strategies","title":"Mitigation Strategies","text":"<ul> <li>Documentation: Comprehensive documentation with examples (doc/sync-configuration.md)</li> <li>Validation: JSON validation during development and in workflows</li> <li>Self-Updating: Configuration file itself is synced, ensuring consistency</li> <li>Clear Examples: Well-documented examples for adding new sync rules</li> </ul>"},{"location":"adr/011-configuration-driven-template-sync/#success-criteria","title":"Success Criteria","text":"<ul> <li>\u2705 Template improvements automatically reach forked repositories</li> <li>\u2705 No manual intervention required for infrastructure updates</li> <li>\u2705 Clear separation between template and project content</li> <li>\u2705 Easy to add new files to sync process</li> <li>\u2705 Forked repositories maintain clean state without template artifacts</li> <li>\u2705 Sync behavior is documented and auditable</li> <li>\u2705 Template drift problem is eliminated</li> </ul>"},{"location":"adr/011-configuration-driven-template-sync/#future-evolution","title":"Future Evolution","text":""},{"location":"adr/011-configuration-driven-template-sync/#potential-enhancements","title":"Potential Enhancements","text":"<ol> <li>Conditional Sync Rules: Sync different files based on project type</li> <li>Conflict Resolution: Automated handling of sync conflicts</li> <li>Sync Analytics: Tracking sync success rates and common issues</li> <li>Custom Sync Schedules: Per-repository sync frequency configuration</li> </ol>"},{"location":"adr/011-configuration-driven-template-sync/#extensibility-design","title":"Extensibility Design","text":"<ul> <li>Modular Configuration: Easy to add new sync rule categories</li> <li>Version Evolution: Configuration schema can evolve with backward compatibility</li> <li>Plugin Architecture: Support for custom sync processors</li> <li>Integration Points: Hooks for additional sync validation or processing</li> </ul>"},{"location":"adr/011-configuration-driven-template-sync/#related-adrs","title":"Related ADRs","text":"<ul> <li>ADR-003: Template Repository Pattern for Self-Configuration (updated by this decision)</li> <li>ADR-006: Two-Workflow Initialization Pattern (enhanced by sync configuration)</li> <li>ADR-012: Template Update Propagation Strategy (depends on this configuration system)</li> </ul> <p>\u2190 ADR-010 |  Catalog | ADR-012 \u2192</p>"},{"location":"adr/012-template-update-propagation-strategy/","title":"ADR-012: Template Update Propagation Strategy","text":""},{"location":"adr/012-template-update-propagation-strategy/#status","title":"Status","text":"<p>Accepted - 2025-10-01  </p>"},{"location":"adr/012-template-update-propagation-strategy/#context","title":"Context","text":"<p>Following the implementation of configuration-driven template synchronization (ADR-011), we needed a strategy for actually propagating template updates to existing forked repositories. The sync configuration defined what should be synchronized, but we needed to define how and when template updates reach forked repositories.</p> <p>Requirements for Template Update System:</p> <ul> <li>Automatic Updates: Template improvements should reach forks without manual intervention</li> <li>Selective Syncing: Only template infrastructure should be updated, not project-specific content</li> <li>Change Visibility: Teams should see exactly what template changes are being applied</li> <li>Review Process: Updates should go through pull request review before being applied</li> <li>Conflict Handling: System should detect and handle potential conflicts gracefully</li> <li>Version Tracking: Track which template version each fork is synchronized to</li> </ul> <p>Challenges to Address:</p> <ul> <li>Bootstrap Problem: How do forked repositories get the template sync capability initially?</li> <li>Change Detection: How to identify which template changes are relevant to forks?</li> <li>Update Scheduling: When should template updates be checked and applied?</li> <li>Conflict Resolution: How to handle cases where template changes conflict with local modifications?</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#decision","title":"Decision","text":"<p>Implement Template Update Propagation through a dedicated <code>template-sync.yml</code> workflow that:</p>"},{"location":"adr/012-template-update-propagation-strategy/#1-template-sync-workflow-template-syncyml","title":"1. Template Sync Workflow: <code>template-sync.yml</code>","text":"<ul> <li>Triggers: Daily schedule (8 AM UTC) + manual dispatch</li> <li>Function: Detects template changes and creates update PRs</li> <li>Scope: Only files defined in sync configuration (ADR-011)</li> <li>Output: Pull requests with AI-enhanced descriptions of changes</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#2-two-repository-architecture","title":"2. Two-Repository Architecture","text":"<ul> <li>Template Repository: Source of truth for infrastructure improvements</li> <li>Fork Repositories: Receive template updates via template-sync workflow</li> <li>Separation: Template management stays in template, project automation goes to forks</li> <li>Human-Centric Flow: Template updates include instructions for manual cascade triggering</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#3-change-detection-and-propagation","title":"3. Change Detection and Propagation","text":"<pre><code># Track last synced template commit\n.github/.template-sync-commit\n\n# Compare template changes since last sync\ngit diff $LAST_SYNC_COMMIT..$TEMPLATE_COMMIT template/main -- [sync_paths]\n\n# Create PR for template updates\nPR: \"\ud83d\udd04 Sync template updates YYYY-MM-DD\"\n</code></pre>"},{"location":"adr/012-template-update-propagation-strategy/#4-intelligent-sync-scope","title":"4. Intelligent Sync Scope","text":"<ul> <li>Configuration-Driven: Uses <code>.github/sync-config.json</code> to determine what to sync</li> <li>Selective Updates: Only syncs files defined in sync rules</li> <li>Change-Based: Only creates PRs when relevant template changes exist</li> <li>Self-Updating: The sync configuration itself can be updated via template sync</li> <li>Manual Integration Instructions: Sync creates issues with explicit cascade trigger guidance</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#rationale","title":"Rationale","text":""},{"location":"adr/012-template-update-propagation-strategy/#solving-the-template-drift-problem","title":"Solving the Template Drift Problem","text":"<ol> <li>Automatic Propagation: No manual work required to get template improvements</li> <li>Consistent Infrastructure: All forks maintain current template infrastructure</li> <li>Security Updates: Security improvements in template automatically reach forks</li> <li>Feature Adoption: New workflow features automatically available to teams</li> </ol>"},{"location":"adr/012-template-update-propagation-strategy/#pull-request-based-update-process","title":"Pull Request-Based Update Process","text":"<ol> <li>Review Opportunity: Teams can review template changes before accepting</li> <li>Change Visibility: Clear documentation of what's being updated and why</li> <li>Conflict Detection: PR process reveals any conflicts with local modifications</li> <li>Rollback Capability: Changes can be reverted if they cause issues</li> </ol>"},{"location":"adr/012-template-update-propagation-strategy/#weekly-schedule-benefits","title":"Weekly Schedule Benefits","text":"<ol> <li>Predictable Updates: Teams know when to expect template update PRs</li> <li>Batched Changes: Multiple template improvements delivered together</li> <li>Non-Disruptive: Updates arrive at consistent, predictable times</li> <li>Manual Override: Can run template sync manually when needed</li> </ol>"},{"location":"adr/012-template-update-propagation-strategy/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/012-template-update-propagation-strategy/#template-sync-workflow-structure","title":"Template Sync Workflow Structure","text":""},{"location":"adr/012-template-update-propagation-strategy/#trigger-configuration","title":"Trigger Configuration","text":"<pre><code>on:\n  schedule:\n    - cron: '0 8 * * *'  # Daily at 8 AM UTC\n  workflow_dispatch:      # Manual trigger available\n</code></pre>"},{"location":"adr/012-template-update-propagation-strategy/#change-detection-process","title":"Change Detection Process","text":"<pre><code>- name: Check for template updates\n  run: |\n    # Get the latest commit from template main branch\n    TEMPLATE_COMMIT=$(git rev-parse template/main)\n\n    # Check last synced commit\n    LAST_SYNC_COMMIT=$(cat .github/.template-sync-commit)\n\n    # Get sync configuration from template\n    git show template/main:.github/sync-config.json &gt; temp-sync-config.json\n\n    # Build list of paths to check for changes\n    SYNC_PATHS=$(jq -r '.sync_rules.directories[] | .path' temp-sync-config.json)\n\n    # Check for changes in configured paths\n    CHANGES=$(git diff --name-only $LAST_SYNC_COMMIT..$TEMPLATE_COMMIT template/main -- $SYNC_PATHS)\n</code></pre>"},{"location":"adr/012-template-update-propagation-strategy/#selective-file-synchronization","title":"Selective File Synchronization","text":"<pre><code>- name: Sync template files\n  run: |\n    # Sync directories\n    DIRECTORIES=$(jq -r '.sync_rules.directories[] | .path' temp-sync-config.json)\n    for dir in $DIRECTORIES; do\n      if [[ changes detected in $dir ]]; then\n        rm -rf \"$dir\"\n        git archive template/main \"$dir\" | tar -x\n        git add \"$dir\"\n      fi\n    done\n\n    # Sync individual files\n    FILES=$(jq -r '.sync_rules.files[] | .path' temp-sync-config.json)\n    for file in $FILES; do\n      if [[ changes detected in $file ]]; then\n        git show template/main:\"$file\" &gt; \"$file\"\n        git add \"$file\"\n      fi\n    done\n\n    # Sync essential workflows\n    WORKFLOWS=$(jq -r '.sync_rules.workflows.essential[] | .path' temp-sync-config.json)\n    for workflow in $WORKFLOWS; do\n      if [[ changes detected in $workflow ]]; then\n        git show template/main:\"$workflow\" &gt; \"$workflow\"\n        git add \"$workflow\"\n      fi\n    done\n</code></pre>"},{"location":"adr/012-template-update-propagation-strategy/#issue-creation-with-manual-instructions","title":"Issue Creation with Manual Instructions","text":"<pre><code># Template updates now create tracking issues similar to upstream sync\n- name: Create template update notification\n  run: |\n    NOTIFICATION_BODY=\"## \ud83d\udccb Template Updates Ready for Review\n\n    New template infrastructure updates are available for integration.\n\n    **Update Details:**\n    - **PR:** $PR_URL\n    - **Template Version:** $TEMPLATE_COMMIT\n    - **Changed Files:** $(git diff --name-only main...$SYNC_BRANCH | wc -l) files\n    - **Changes:** Template infrastructure improvements\n\n    **Next Steps:**\n    1. \ud83d\udd0d **Review the template update PR** for infrastructure changes\n    2. \u2705 **Merge the PR** when satisfied with the updates\n    3. \ud83d\ude80 **Manually trigger 'Cascade Integration' workflow** if changes affect workflows\n    4. \ud83d\udcca **Monitor integration progress** in Actions tab\n\n    **Timeline:**\n    - Template sync detected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n    - Action required: Human review, merge, and potential cascade trigger\"\n\n    gh issue create \\\n      --title \"\ud83d\udccb Template Updates Ready for Review - $(date +%Y-%m-%d)\" \\\n      --body \"$NOTIFICATION_BODY\" \\\n      --label \"template-sync,human-required\"\n</code></pre>"},{"location":"adr/012-template-update-propagation-strategy/#bootstrap-strategy","title":"Bootstrap Strategy","text":""},{"location":"adr/012-template-update-propagation-strategy/#initial-template-sync-capability","title":"Initial Template Sync Capability","text":"<ul> <li>Template sync workflow included in essential workflows (ADR-011)</li> <li>Copied during repository initialization via <code>init-complete.yml</code></li> <li>Self-updating capability - template sync can update itself</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#auto-bootstrap-for-existing-repositories","title":"Auto-Bootstrap for Existing Repositories","text":"<p>Problem: Repositories created before template sync implementation lack tracking files.</p> <p>Solution: Auto-bootstrap detection and initialization:</p> <pre><code># Detect missing or empty tracking file\nif [ -f \"$LAST_SYNC_FILE\" ] &amp;&amp; [ -s \"$LAST_SYNC_FILE\" ]; then\n  LAST_SYNC_COMMIT=$(cat \"$LAST_SYNC_FILE\")\nelse\n  # Auto-bootstrap: find earliest .github commit as baseline\n  BASELINE_COMMIT=$(git log template/main --reverse --oneline -- .github/ | head -1 | cut -d' ' -f1)\n\n  # Create tracking file immediately\n  echo \"$BASELINE_COMMIT\" &gt; .github/.template-sync-commit\n  LAST_SYNC_COMMIT=\"$BASELINE_COMMIT\"\nfi\n</code></pre> <p>Benefits:</p> <ul> <li>Seamless Migration: Existing repositories can adopt template sync without manual intervention</li> <li>Smart Baseline: Uses earliest template infrastructure commit, not arbitrary date</li> <li>Immediate Tracking: Creates tracking file during detection to prevent future bootstrap issues</li> <li>Comprehensive Updates: First sync includes all template improvements since baseline</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#template-repository-configuration","title":"Template Repository Configuration","text":"<pre><code>{\n  \"sync_rules\": {\n    \"workflows\": {\n      \"essential\": [\n        \".github/workflows/template-sync.yml\"  // Included in essential workflows\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"adr/012-template-update-propagation-strategy/#version-tracking-system","title":"Version Tracking System","text":""},{"location":"adr/012-template-update-propagation-strategy/#commit-tracking-file","title":"Commit Tracking File","text":"<pre><code># .github/.template-sync-commit contains SHA of last synced template commit\necho \"$TEMPLATE_COMMIT\" &gt; .github/.template-sync-commit\ngit add .github/.template-sync-commit\n</code></pre>"},{"location":"adr/012-template-update-propagation-strategy/#template-version-references","title":"Template Version References","text":"<ul> <li>Each sync PR documents template commit range</li> <li>Git history shows template update progression</li> <li>Easy to identify which template features are available</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#duplicate-prevention-pattern","title":"Duplicate Prevention Pattern","text":"<p>Following the same architectural pattern as upstream sync (ADR-024), template-sync implements duplicate prevention to avoid creating multiple open PRs for template updates (detailed in ADR-031):</p>"},{"location":"adr/012-template-update-propagation-strategy/#problem-addressed","title":"Problem Addressed","text":"<p>Without duplicate prevention, the daily template-sync schedule creates a new PR every day when changes exist, even if a previous PR is still open. This results in: - Multiple open template-sync PRs simultaneously (6+ PRs in production) - Repository clutter and notification fatigue - Confusion about which PR contains the latest changes</p>"},{"location":"adr/012-template-update-propagation-strategy/#solution-implementation","title":"Solution Implementation","text":"<ul> <li>PR Detection: Checks for existing open PRs with <code>template-sync</code> label targeting <code>main</code> branch</li> <li>Branch Reuse: Updates existing sync branches instead of creating new ones</li> <li>Force Push Strategy: Force-pushes updates to existing branches when template advances</li> <li>PR Updates: Updates PR title to show \"(Updated YYYY-MM-DD)\", regenerates description, adds update comments</li> <li>Single Active PR: Only one template-sync PR open at any time</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#decision-matrix","title":"Decision Matrix","text":"<pre><code>| Existing PR | Template Changed | Action                    |\n|-------------|------------------|---------------------------|\n| No          | Yes              | Create new PR             |\n| Yes         | No               | No action needed          |\n| Yes         | Yes              | Update existing branch/PR |\n| No          | No               | No action needed          |\n</code></pre>"},{"location":"adr/012-template-update-propagation-strategy/#benefits","title":"Benefits","text":"<ul> <li>Eliminates duplicate PRs - Core problem solved</li> <li>Consistent pattern - Same approach as upstream sync</li> <li>Clean repository - No accumulation of stale PRs</li> <li>Reduced noise - Single PR per template update cycle</li> <li>Clear progression - Updated PRs show complete history</li> </ul> <p>See ADR-031: Template Sync Duplicate Prevention Pattern for complete implementation details.</p>"},{"location":"adr/012-template-update-propagation-strategy/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/012-template-update-propagation-strategy/#1-push-based-updates-from-template","title":"1. Push-Based Updates from Template","text":"<ul> <li>Pros: Immediate propagation, centralized control</li> <li>Cons: Requires write access to all forks, security concerns</li> <li>Decision: Rejected due to security and access complexity</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#2-manual-update-process","title":"2. Manual Update Process","text":"<ul> <li>Pros: Full control, simple implementation</li> <li>Cons: Relies on teams remembering to update, inconsistent adoption</li> <li>Decision: Rejected due to poor adoption rates</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#3-webhook-based-real-time-updates","title":"3. Webhook-Based Real-Time Updates","text":"<ul> <li>Pros: Immediate updates when template changes</li> <li>Cons: Complex setup, potential for update spam</li> <li>Decision: Rejected in favor of predictable scheduled updates</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#4-git-submodule-for-template-infrastructure","title":"4. Git Submodule for Template Infrastructure","text":"<ul> <li>Pros: Native Git functionality</li> <li>Cons: Complex for teams, doesn't handle selective syncing</li> <li>Decision: Rejected due to user experience complexity</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#5-daily-template-sync-schedule","title":"5. Daily Template Sync Schedule","text":"<ul> <li>Pros: More frequent updates</li> <li>Cons: Potential for too many PRs, disruption to team workflow</li> <li>Decision: Rejected in favor of weekly schedule</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#consequences","title":"Consequences","text":""},{"location":"adr/012-template-update-propagation-strategy/#positive","title":"Positive","text":"<ul> <li>Automatic Template Benefits: Teams automatically get template improvements</li> <li>Reduced Maintenance: Minimal manual work required to stay current with template</li> <li>Consistent Infrastructure: All repositories maintain current best practices</li> <li>Security Currency: Security improvements automatically propagate</li> <li>Feature Adoption: New capabilities automatically available to teams</li> <li>Change Visibility: Clear PRs and issues showing exactly what's being updated</li> <li>Review Process: Teams can review and test template changes before merging</li> <li>Human Control: Explicit guidance on when workflow changes need cascade integration</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#negative","title":"Negative","text":"<ul> <li>Additional PRs and Issues: Daily template update PRs and tracking issues require team attention</li> <li>Manual Integration Steps: Workflow changes may require manual cascade triggering</li> <li>Potential Conflicts: Template changes might conflict with local modifications</li> <li>Update Lag: Template improvements take up to a day to reach all forks</li> <li>Dependency on Template: Forks depend on template repository being available</li> <li>Learning Curve: Teams need to understand when template changes require cascade integration</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#mitigation-strategies","title":"Mitigation Strategies","text":"<ul> <li>AI-Enhanced Descriptions: Clear PR descriptions explain what's changing and why</li> <li>Explicit Instructions: Issues provide clear guidance on when cascade integration is needed</li> <li>Selective Syncing: Only essential infrastructure updated, not project code</li> <li>Manual Override: Can run template sync immediately when critical updates needed</li> <li>Conflict Detection: PR process reveals conflicts before they're merged</li> <li>Documentation: Clear guidance on handling template update PRs and cascade integration</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#success-criteria","title":"Success Criteria","text":"<ul> <li>\u2705 Template improvements reach all forked repositories within one week</li> <li>\u2705 Teams receive clear, actionable PR descriptions for template updates</li> <li>\u2705 No manual intervention required for routine template updates</li> <li>\u2705 Template update PRs have high merge rate (&gt;90%)</li> <li>\u2705 Security updates propagate to forks within 24 hours (manual trigger)</li> <li>\u2705 Teams can easily review and understand template changes</li> <li>\u2705 Template drift problem is eliminated across all repositories</li> <li>\u2705 Existing repositories auto-bootstrap template sync without manual setup</li> <li>\u2705 Auto-bootstrap creates comprehensive update PRs covering all missing template features</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#monitoring-and-analytics","title":"Monitoring and Analytics","text":""},{"location":"adr/012-template-update-propagation-strategy/#template-update-metrics","title":"Template Update Metrics","text":"<ul> <li>Sync Success Rate: Percentage of successful template sync PRs</li> <li>Update Lag Time: Time from template change to fork merge</li> <li>Conflict Rate: Frequency of template update conflicts</li> <li>Adoption Rate: Percentage of template update PRs that get merged</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#health-indicators","title":"Health Indicators","text":"<ul> <li>Template Sync Workflow Failures: Alert on sync workflow failures</li> <li>Large Sync Gaps: Alert when forks fall behind template by significant margin</li> <li>Conflict Trends: Monitor increasing conflict rates as indicator of template design issues</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#future-evolution","title":"Future Evolution","text":""},{"location":"adr/012-template-update-propagation-strategy/#potential-enhancements","title":"Potential Enhancements","text":"<ol> <li>Smart Scheduling: Adjust sync frequency based on template change rate</li> <li>Priority Updates: Immediate sync for security-critical template changes</li> <li>Conflict Resolution: Automated conflict resolution for common scenarios</li> <li>Selective Sync: Per-repository customization of which template features to sync</li> <li>Rollback Capability: Automated rollback of problematic template updates</li> </ol>"},{"location":"adr/012-template-update-propagation-strategy/#integration-opportunities","title":"Integration Opportunities","text":"<ul> <li>Security Scanning: Integration with security tools to prioritize security-related template updates</li> <li>Testing Integration: Automated testing of template updates before creating PRs</li> <li>Analytics Dashboard: Visibility into template update health across organization</li> </ul>"},{"location":"adr/012-template-update-propagation-strategy/#related-adrs","title":"Related ADRs","text":"<ul> <li>ADR-011: Configuration-Driven Template Synchronization (provides the foundation for this strategy)</li> <li>ADR-013: Reusable GitHub Actions Pattern (enables consistent PR creation)</li> <li>ADR-031: Template Sync Duplicate Prevention Pattern (prevents duplicate template-sync PRs)</li> <li>ADR-024: Sync Workflow Duplicate Prevention Architecture (upstream sync pattern that inspired ADR-031)</li> <li>ADR-003: Template Repository Pattern (original template architecture, extended by this decision)</li> </ul> <p>\u2190 ADR-011 |  Catalog | ADR-013 \u2192</p>"},{"location":"adr/013-reusable-github-actions-pattern/","title":"ADR-013: Reusable GitHub Actions Pattern for PR Creation","text":""},{"location":"adr/013-reusable-github-actions-pattern/#status","title":"Status","text":"<p>Accepted - 2025-10-01</p>"},{"location":"adr/013-reusable-github-actions-pattern/#context","title":"Context","text":"<p>During implementation of template synchronization workflows (ADR-011, ADR-012), we identified significant code duplication in PR creation logic across multiple workflows. Each workflow that created pull requests had to implement:</p> <p>Duplicated PR Creation Logic:</p> <ul> <li>LLM Detection: Check for available Azure Foundry API keys</li> <li>aipr Integration: Generate AI-enhanced PR descriptions when possible</li> <li>Fallback Handling: Use provided description when AI generation fails</li> <li>Diff Size Management: Skip AI generation for large diffs to avoid token limits</li> <li>PR Creation: Create GitHub pull request with proper parameters</li> <li>Output Management: Return PR URL and number for further processing</li> </ul> <p>Workflows with Similar PR Creation Needs:</p> <ul> <li><code>sync.yml</code>: Creates upstream synchronization PRs with vulnerability analysis</li> <li><code>template-sync.yml</code>: Creates template update PRs with change summaries  </li> <li>Future workflows: Additional automation requiring AI-enhanced PR descriptions</li> </ul> <p>Problems with Code Duplication:</p> <ul> <li>Maintenance Burden: Changes to PR creation logic required updates in multiple places</li> <li>Inconsistency Risk: Implementations could drift apart over time</li> <li>Testing Complexity: Each workflow implementation needed separate testing</li> <li>Feature Lag: Improvements to one workflow didn't benefit others</li> </ul>"},{"location":"adr/013-reusable-github-actions-pattern/#decision","title":"Decision","text":"<p>Implement Reusable GitHub Actions Pattern for common PR creation functionality:</p>"},{"location":"adr/013-reusable-github-actions-pattern/#1-custom-composite-action-githubactionscreate-enhanced-practionyml","title":"1. Custom Composite Action: <code>.github/actions/create-enhanced-pr/action.yml</code>","text":"<ul> <li>Centralized Logic: Single implementation of PR creation with AI enhancement</li> <li>Configurable Parameters: Flexible inputs for different use cases</li> <li>Consistent Interface: Standardized inputs and outputs across workflows</li> <li>AI Integration: Built-in aipr integration with Azure Foundry</li> </ul>"},{"location":"adr/013-reusable-github-actions-pattern/#2-standardized-ai-enhancement-pipeline","title":"2. Standardized AI Enhancement Pipeline","text":"<pre><code># Automatic LLM detection and configuration\n- Azure Foundry (primary)\n- Template fallback when Azure unavailable\n\n# Intelligent diff size management\n- Skip AI generation for diffs &gt;20,000 lines\n- Configurable diff size limits\n- Graceful degradation to fallback content\n</code></pre>"},{"location":"adr/013-reusable-github-actions-pattern/#3-flexible-configuration-interface","title":"3. Flexible Configuration Interface","text":"<pre><code>uses: ./.github/actions/create-enhanced-pr\nwith:\n  github-token: ${{ secrets.GH_TOKEN }}\n  base-branch: main\n  head-branch: feature-branch\n  pr-title: \"feat: add new feature\"\n  fallback-description: \"Basic PR description\"\n  use-vulns-flag: 'true'  # Enable security analysis\n  additional-description: \"Extra content to append\"\n</code></pre>"},{"location":"adr/013-reusable-github-actions-pattern/#4-comprehensive-output-interface","title":"4. Comprehensive Output Interface","text":"<pre><code>outputs:\n  pr-url: \"https://github.com/owner/repo/pull/123\"\n  pr-number: \"123\"\n  used-aipr: \"true\"  # Indicates if AI enhancement was used\n</code></pre>"},{"location":"adr/013-reusable-github-actions-pattern/#rationale","title":"Rationale","text":""},{"location":"adr/013-reusable-github-actions-pattern/#benefits-of-reusable-actions-pattern","title":"Benefits of Reusable Actions Pattern","text":"<ol> <li>DRY Principle: Single implementation eliminates code duplication</li> <li>Consistent Behavior: All workflows use identical PR creation logic</li> <li>Centralized Improvements: Enhancements benefit all consuming workflows</li> <li>Easier Testing: Single action to test instead of multiple workflow implementations</li> <li>Reduced Maintenance: Changes only need to be made in one place</li> <li>Standardized Interface: Common parameters and behavior across workflows</li> </ol>"},{"location":"adr/013-reusable-github-actions-pattern/#ai-enhancement-centralization","title":"AI Enhancement Centralization","text":"<ol> <li>Consistent AI Integration: Same aipr configuration across all workflows</li> <li>Azure Foundry Primary: Standardized on Azure Foundry with template fallback</li> <li>Configuration Management: Centralized handling of API keys and parameters</li> <li>Error Handling: Unified approach to AI generation failures</li> <li>Performance Optimization: Shared diff size management and token limit handling</li> </ol>"},{"location":"adr/013-reusable-github-actions-pattern/#workflow-simplification","title":"Workflow Simplification","text":"<ol> <li>Reduced Complexity: Workflows focus on their core logic, not PR creation details</li> <li>Clear Separation: PR creation concerns separated from business logic</li> <li>Easier Debugging: Issues with PR creation isolated to single action</li> <li>Improved Readability: Workflows more focused and easier to understand</li> </ol>"},{"location":"adr/013-reusable-github-actions-pattern/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/013-reusable-github-actions-pattern/#action-interface-design","title":"Action Interface Design","text":""},{"location":"adr/013-reusable-github-actions-pattern/#required-inputs","title":"Required Inputs","text":"<pre><code>inputs:\n  github-token:        # GitHub token for API access\n  base-branch:         # Target branch for PR\n  head-branch:         # Source branch for PR\n  pr-title:           # Title for the PR\n  fallback-description: # Description to use if AI generation fails\n</code></pre>"},{"location":"adr/013-reusable-github-actions-pattern/#optional-inputs","title":"Optional Inputs","text":"<pre><code>inputs:\n  azure-api-key:       # Azure Foundry API key\n  azure-api-base:      # Azure Foundry endpoint\n  azure-api-version:   # Azure Foundry API version\n  max-diff-lines:      # Maximum diff size for AI processing (default: 20000)\n  use-vulns-flag:      # Enable vulnerability analysis (default: true)\n  target-branch-for-aipr: # Branch for aipr analysis (defaults to base-branch)\n  additional-description: # Extra content to append to description\n</code></pre>"},{"location":"adr/013-reusable-github-actions-pattern/#comprehensive-outputs","title":"Comprehensive Outputs","text":"<pre><code>outputs:\n  pr-url:              # Complete URL to created PR\n  pr-number:           # PR number for further processing\n  used-aipr:           # Boolean indicating if AI enhancement was used\n</code></pre>"},{"location":"adr/013-reusable-github-actions-pattern/#llm-provider-detection","title":"LLM Provider Detection","text":""},{"location":"adr/013-reusable-github-actions-pattern/#provider-detection-logic","title":"Provider Detection Logic","text":"<pre><code># Provider detection\n1. Azure Foundry (if AZURE_API_KEY and AZURE_API_BASE provided)\n2. Template fallback when Azure unavailable\n</code></pre>"},{"location":"adr/013-reusable-github-actions-pattern/#model-configuration","title":"Model Configuration","text":"<pre><code># Model configuration\nAzure: \"azure\"  # aipr model identifier for Azure Foundry\n</code></pre>"},{"location":"adr/013-reusable-github-actions-pattern/#action-implementation-pattern","title":"Action Implementation Pattern","text":""},{"location":"adr/013-reusable-github-actions-pattern/#composite-action-structure","title":"Composite Action Structure","text":"<pre><code>runs:\n  using: 'composite'\n  steps:\n    - name: Detect available LLM\n    - name: Check diff size and generate description  \n    - name: Create PR\n</code></pre>"},{"location":"adr/013-reusable-github-actions-pattern/#error-handling-strategy","title":"Error Handling Strategy","text":"<pre><code># Graceful degradation approach\n1. Try AI generation with detected LLM\n2. If AI generation fails, log warning and continue\n3. Use fallback description provided by caller\n4. Create PR successfully regardless of AI generation outcome\n</code></pre>"},{"location":"adr/013-reusable-github-actions-pattern/#usage-patterns-in-workflows","title":"Usage Patterns in Workflows","text":""},{"location":"adr/013-reusable-github-actions-pattern/#sync-workflow-limitation","title":"Sync Workflow Limitation","text":"<p>Important: The reusable action pattern cannot be used in the sync workflow (<code>sync.yml</code>) because: - Sync workflow runs from <code>fork_upstream</code> branch (contains only upstream code) - <code>create-enhanced-pr</code> action only exists on <code>main</code> branch (template infrastructure) - GitHub Actions cannot access actions from different branches</p> <p>Solution: Embed PR creation logic directly in sync workflow instead of using reusable action.</p> <pre><code># \u274c This DOES NOT work in sync.yml (action not available on fork_upstream branch)\n- name: Create enhanced sync PR\n  uses: ./.github/actions/create-enhanced-pr  # Action doesn't exist on fork_upstream\n\n# \u2705 This works in sync.yml (embedded logic)\n- name: Create enhanced sync PR\n  env:\n    GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n  run: |\n    # Detect available LLM provider and generate PR description\n    # [embedded logic as implemented in sync.yml]\n</code></pre>"},{"location":"adr/013-reusable-github-actions-pattern/#template-sync-workflow-usage","title":"Template Sync Workflow Usage","text":"<pre><code>- name: Create enhanced template sync PR\n  uses: ./.github/actions/create-enhanced-pr\n  with:\n    base-branch: main\n    head-branch: ${{ env.SYNC_BRANCH }}\n    pr-title: \"\ud83d\udd04 Sync template updates $(date +%Y-%m-%d)\"\n    fallback-description: ${{ env.FALLBACK_DESCRIPTION }}\n    use-vulns-flag: 'false'  # Disable security analysis for template PRs\n    target-branch-for-aipr: main\n</code></pre>"},{"location":"adr/013-reusable-github-actions-pattern/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/013-reusable-github-actions-pattern/#1-shared-shell-functions","title":"1. Shared Shell Functions","text":"<ul> <li>Pros: Lightweight, easy to understand</li> <li>Cons: Limited parameter handling, no type safety, harder to test</li> <li>Decision: Rejected due to limited flexibility and maintainability</li> </ul>"},{"location":"adr/013-reusable-github-actions-pattern/#2-external-action-from-marketplace","title":"2. External Action from Marketplace","text":"<ul> <li>Pros: Maintained by community, potentially more features</li> <li>Cons: External dependency, less control, may not fit our specific needs</li> <li>Decision: Rejected due to specific requirements for aipr integration</li> </ul>"},{"location":"adr/013-reusable-github-actions-pattern/#3-copy-paste-with-documentation","title":"3. Copy-Paste with Documentation","text":"<ul> <li>Pros: Simple, no abstraction complexity</li> <li>Cons: Maintenance burden, inconsistency risk, violates DRY principle</li> <li>Decision: Rejected due to long-term maintenance concerns</li> </ul>"},{"location":"adr/013-reusable-github-actions-pattern/#4-workflow-templates","title":"4. Workflow Templates","text":"<ul> <li>Pros: GitHub native, reusable across repositories</li> <li>Cons: Can't be used within same repository, less flexible</li> <li>Decision: Rejected due to within-repository usage requirements</li> </ul>"},{"location":"adr/013-reusable-github-actions-pattern/#5-npm-package-for-pr-creation","title":"5. NPM Package for PR Creation","text":"<ul> <li>Pros: Version management, external reusability</li> <li>Cons: External dependency, requires Node.js setup in workflows</li> <li>Decision: Rejected due to complexity and external dependencies</li> </ul>"},{"location":"adr/013-reusable-github-actions-pattern/#consequences","title":"Consequences","text":""},{"location":"adr/013-reusable-github-actions-pattern/#positive","title":"Positive","text":"<ul> <li>Eliminated Code Duplication: 80+ lines of PR creation logic now in single action</li> <li>Consistent AI Enhancement: All PRs use identical AI generation logic</li> <li>Easier Maintenance: Single place to update PR creation behavior</li> <li>Improved Testing: Can test PR creation logic independently</li> <li>Better Error Handling: Centralized error handling with graceful degradation</li> <li>Enhanced Flexibility: Easy to add new parameters or features</li> <li>Workflow Simplification: Workflows focus on business logic, not PR creation</li> </ul>"},{"location":"adr/013-reusable-github-actions-pattern/#negative","title":"Negative","text":"<ul> <li>Additional Abstraction: Extra layer between workflows and GitHub API</li> <li>Learning Curve: Team needs to understand action interface</li> <li>Local Development: Harder to test workflows locally</li> <li>Action Complexity: Composite action has multiple steps and conditional logic</li> <li>Branch Dependency Limitation: Actions cannot be used by workflows running from different branches</li> </ul>"},{"location":"adr/013-reusable-github-actions-pattern/#mitigation-strategies","title":"Mitigation Strategies","text":"<ul> <li>Comprehensive Documentation: Clear examples and parameter documentation</li> <li>Integration Testing: Test action behavior in actual workflow contexts</li> <li>Backward Compatibility: Maintain stable interface as action evolves</li> <li>Error Logging: Clear logging to help debug action issues</li> <li>Branch-Aware Design: Document which workflows can/cannot use the action pattern</li> </ul>"},{"location":"adr/013-reusable-github-actions-pattern/#branch-dependency-limitation","title":"Branch Dependency Limitation","text":"<p>Key Discovery: GitHub Actions can only reference actions that exist on the same branch where the workflow is running.</p>"},{"location":"adr/013-reusable-github-actions-pattern/#when-to-use-reusable-action","title":"When to Use Reusable Action","text":"<p>\u2705 Use action for workflows that run from <code>main</code> branch: - <code>template-sync.yml</code> - runs from main, action available - <code>build.yml</code> - runs from main, action available - <code>validate.yml</code> - runs from main, action available - Future workflows on main branch</p>"},{"location":"adr/013-reusable-github-actions-pattern/#when-to-embed-logic-directly","title":"When to Embed Logic Directly","text":"<p>\u274c Embed logic for workflows that run from other branches: - <code>sync.yml</code> - runs from <code>fork_upstream</code> branch, action not available - Any workflows triggered to run on feature branches - Workflows that checkout different branches before running</p>"},{"location":"adr/013-reusable-github-actions-pattern/#implementation-strategy","title":"Implementation Strategy","text":"<ul> <li>Primary Pattern: Use reusable action where possible (main branch workflows)</li> <li>Fallback Pattern: Embed logic directly when branch limitations prevent action usage</li> <li>Consistency: Maintain same AI enhancement logic in both patterns</li> </ul>"},{"location":"adr/013-reusable-github-actions-pattern/#success-criteria","title":"Success Criteria","text":"<ul> <li>\u26a0\ufe0f Code Duplication Reduced: Most PR creation logic centralized in reusable action (limited by branch dependencies)</li> <li>\u2705 Consistent Behavior: All PRs created with identical enhancement logic (action + embedded patterns)</li> <li>\u2705 Easy Integration: New main-branch workflows can easily adopt enhanced PR creation</li> <li>\u2705 Maintained Functionality: All existing PR creation features preserved</li> <li>\u26a0\ufe0f Improved Maintainability: Changes to PR creation logic require updates in action + sync workflow</li> <li>\u2705 Enhanced Flexibility: Easy to customize PR creation for specific use cases</li> <li>\u2705 Branch-Aware Design: Clear guidance on when to use action vs embedded logic</li> </ul>"},{"location":"adr/013-reusable-github-actions-pattern/#future-evolution","title":"Future Evolution","text":""},{"location":"adr/013-reusable-github-actions-pattern/#potential-enhancements","title":"Potential Enhancements","text":"<ol> <li>Additional LLM Providers: Support for new AI services as they become available</li> <li>Custom Templates: Support for PR description templates based on workflow type</li> <li>Advanced Validation: Pre-flight checks for PR creation requirements</li> <li>Metrics Collection: Built-in tracking of AI generation success rates</li> <li>Caching: Cache AI-generated descriptions for similar changes</li> </ol>"},{"location":"adr/013-reusable-github-actions-pattern/#reusability-expansion","title":"Reusability Expansion","text":"<ul> <li>Cross-Repository Usage: Package action for use in other template repositories</li> <li>Marketplace Publication: Make action available to broader GitHub community</li> <li>Plugin Architecture: Support for custom PR enhancement plugins</li> <li>Template Library: Built-in support for common PR description patterns</li> </ul>"},{"location":"adr/013-reusable-github-actions-pattern/#testing-strategy","title":"Testing Strategy","text":""},{"location":"adr/013-reusable-github-actions-pattern/#unit-testing","title":"Unit Testing","text":"<ul> <li>Mock GitHub API: Test PR creation logic without actual API calls</li> <li>LLM Provider Testing: Test provider detection and fallback logic</li> <li>Error Handling: Test graceful degradation scenarios</li> </ul>"},{"location":"adr/013-reusable-github-actions-pattern/#integration-testing","title":"Integration Testing","text":"<ul> <li>Workflow Testing: Test action integration in actual workflow contexts</li> <li>API Key Scenarios: Test behavior with different combinations of API keys</li> <li>Large Diff Testing: Test diff size management and fallback behavior</li> </ul>"},{"location":"adr/013-reusable-github-actions-pattern/#performance-testing","title":"Performance Testing","text":"<ul> <li>AI Generation Time: Monitor time for AI-enhanced description generation</li> <li>Fallback Performance: Ensure fast fallback when AI generation fails</li> <li>Resource Usage: Monitor action resource consumption</li> </ul>"},{"location":"adr/013-reusable-github-actions-pattern/#related-adrs","title":"Related ADRs","text":"<ul> <li>ADR-011: Configuration-Driven Template Synchronization (benefits from consistent PR creation)</li> <li>ADR-012: Template Update Propagation Strategy (uses this action for template sync PRs)</li> <li>ADR-014: AI-Enhanced Development Workflow Integration (implements AI capabilities used by this action)</li> </ul> <p>\u2190 ADR-012 |  Catalog | ADR-014 \u2192</p>"},{"location":"adr/014-ai-enhanced-development-workflow/","title":"ADR-014: AI-Enhanced Development Workflow Integration","text":""},{"location":"adr/014-ai-enhanced-development-workflow/#status","title":"Status","text":"<p>Accepted - 2025-10-01</p>"},{"location":"adr/014-ai-enhanced-development-workflow/#context","title":"Context","text":"<p>Modern development workflows can benefit significantly from AI assistance, particularly in areas like code analysis, security scanning, and documentation generation. As we developed the fork management template system, we identified opportunities to integrate AI capabilities that would enhance the development experience while maintaining workflow reliability.</p> <p>AI Integration Opportunities:</p> <ul> <li>Pull Request Enhancement: Generate comprehensive PR descriptions using AI analysis of code changes</li> <li>Security Analysis: AI-powered triage of vulnerability scans to provide actionable insights</li> <li>Change Summarization: Intelligent summaries of template updates and upstream changes</li> <li>Documentation Generation: AI-assisted creation of commit messages and change logs</li> </ul> <p>Requirements for AI Integration:</p> <ul> <li>Optional Enhancement: AI should enhance workflows without being required for basic functionality</li> <li>Azure Foundry Primary: Standardize on Azure Foundry as the primary AI provider</li> <li>Graceful Degradation: Workflows must function normally when AI services are unavailable</li> <li>Cost Management: Intelligent usage patterns to control API costs</li> <li>Security: Safe handling of API keys and sensitive data</li> </ul> <p>Technical Challenges:</p> <ul> <li>Environment Consistency: AI tools need consistent environments across GitHub Actions</li> <li>API Key Management: Secure handling of multiple AI provider credentials</li> <li>Error Handling: Robust fallback when AI services fail or are unavailable</li> </ul>"},{"location":"adr/014-ai-enhanced-development-workflow/#decision","title":"Decision","text":"<p>Implement AI-Enhanced Development Workflow Integration with the following architecture:</p>"},{"location":"adr/014-ai-enhanced-development-workflow/#1-azure-foundry-integration","title":"1. Azure Foundry Integration","text":"<ul> <li>Primary Provider: Azure Foundry for enterprise compliance and Microsoft ecosystem integration</li> <li>Provider Detection: Automatic detection based on available Azure API keys</li> <li>Fallback Strategy: Graceful degradation to structured templates when Azure is unavailable</li> </ul>"},{"location":"adr/014-ai-enhanced-development-workflow/#2-ai-pr-generator-aipr-integration","title":"2. AI PR Generator (aipr) Integration","text":"<pre><code># Install AI PR generator\npip install pr-generator-agent&gt;=1.4.0\n\n# Generate PR description with vulnerability analysis\naipr generate --from upstream/main \\\n  --vulns --max-lines 20000 \\\n  --context \"upstream sync\"\n</code></pre>"},{"location":"adr/014-ai-enhanced-development-workflow/#3-workflow-enhancement-points","title":"3. Workflow Enhancement Points","text":"<ul> <li>Upstream Sync: AI-generated PR descriptions for upstream changes</li> <li>Template Sync: Intelligent analysis of template updates</li> <li>Security Triage: Vulnerability scan analysis and prioritization</li> <li>Commit Generation: Conventional commit messages from changesets</li> </ul>"},{"location":"adr/014-ai-enhanced-development-workflow/#4-provider-configuration","title":"4. Provider Configuration","text":"<pre><code>env:\n  # Azure Foundry Configuration (Required for AI features)\n  AZURE_API_KEY: ${{ secrets.AZURE_API_KEY }}\n  AZURE_API_BASE: ${{ secrets.AZURE_API_BASE }}\n  AZURE_API_VERSION: ${{ secrets.AZURE_API_VERSION }}\n</code></pre>"},{"location":"adr/014-ai-enhanced-development-workflow/#5-fallback-mechanisms","title":"5. Fallback Mechanisms","text":"<ul> <li>Structured Templates: Pre-defined PR templates when AI is unavailable</li> <li>Base64 Encoding: Large content fallback for template PRs</li> <li>Manual Override: Human-editable descriptions for all AI-generated content</li> </ul>"},{"location":"adr/014-ai-enhanced-development-workflow/#implementation","title":"Implementation","text":""},{"location":"adr/014-ai-enhanced-development-workflow/#ai-provider-detection-logic","title":"AI Provider Detection Logic","text":"<pre><code>USE_LLM=false\nLLM_MODEL=\"\"\n\n# Check for Azure Foundry API key\nif [[ -n \"$AZURE_API_KEY\" ]] &amp;&amp; [[ -n \"$AZURE_API_BASE\" ]]; then\n  USE_LLM=true\n  LLM_MODEL=\"azure\"\n  echo \"Using Azure Foundry for PR description generation\"\nelse\n  echo \"No Azure Foundry configured - using fallback templates\"\nfi\n</code></pre>"},{"location":"adr/014-ai-enhanced-development-workflow/#workflow-integration-pattern","title":"Workflow Integration Pattern","text":"<pre><code>- name: Generate AI-Enhanced PR Description\n  if: env.USE_LLM == 'true'\n  run: |\n    aipr generate \\\n      --from ${{ github.base_ref }} \\\n      --vulns \\\n      --max-lines 20000 \\\n      --context \"upstream synchronization\" \\\n      &gt; pr_description.md\n\n- name: Use Fallback Template\n  if: env.USE_LLM != 'true'\n  run: |\n    cat &gt; pr_description.md &lt;&lt; 'EOF'\n    ## Upstream Synchronization\n\n    This PR synchronizes changes from the upstream repository.\n\n    ### Changes\n    - Updated from upstream commit: ${{ env.UPSTREAM_SHA }}\n    - Diff size: ${{ env.DIFF_SIZE }} lines\n\n    ### Review Checklist\n    - [ ] Changes reviewed for compatibility\n    - [ ] Tests passing\n    - [ ] No security issues identified\n    EOF\n</code></pre>"},{"location":"adr/014-ai-enhanced-development-workflow/#consequences","title":"Consequences","text":""},{"location":"adr/014-ai-enhanced-development-workflow/#positive","title":"Positive","text":"<ul> <li>Enhanced PR Quality: AI-generated descriptions provide comprehensive change analysis</li> <li>Reduced Manual Work: Automated generation of conventional commits and PR descriptions</li> <li>Security Insights: AI-powered vulnerability triage provides actionable recommendations</li> <li>Enterprise Integration: Azure Foundry provides compliance and Microsoft ecosystem alignment</li> <li>Cost Control: Usage limits and fallback mechanisms control API costs</li> </ul>"},{"location":"adr/014-ai-enhanced-development-workflow/#negative","title":"Negative","text":"<ul> <li>API Dependencies: Requires Azure Foundry API keys for full functionality</li> <li>Single Provider: Standardization on Azure means no fallback to other AI providers</li> <li>Cost Considerations: AI API usage incurs costs that need monitoring</li> <li>Maintenance: AI tools and models require regular updates</li> </ul>"},{"location":"adr/014-ai-enhanced-development-workflow/#mitigations","title":"Mitigations","text":"<ul> <li>Graceful Degradation: All AI features have structured template fallbacks</li> <li>Template Quality: Non-AI fallbacks provide comprehensive base descriptions</li> <li>Usage Monitoring: Track API usage to control costs</li> <li>Documentation: Clear Azure Foundry setup guides</li> </ul>"},{"location":"adr/014-ai-enhanced-development-workflow/#references","title":"References","text":"<ul> <li>AI PR Generator Documentation</li> <li>Azure Foundry Service</li> </ul> <p>\u2190 ADR-013 |  Catalog | ADR-015 \u2192</p>"},{"location":"adr/015-template-workflows-separation-pattern/","title":"ADR-015: Template-Workflows Separation Pattern","text":""},{"location":"adr/015-template-workflows-separation-pattern/#status","title":"Status","text":"<p>Accepted - 2025-10-01</p>"},{"location":"adr/015-template-workflows-separation-pattern/#context","title":"Context","text":"<p>During implementation of the initialization workflows, we discovered a fundamental architectural challenge with workflow distribution in GitHub template repositories:</p> <p>The Workflow Pollution Problem:</p> <p>GitHub template repositories need two distinct types of workflows:</p> <ol> <li>Template Development Workflows: For managing the template itself (init, testing, releases)</li> <li>Fork Production Workflows: For the repositories created from the template (sync, build, validate)</li> </ol> <p>Previous Approach Issues:</p> <ul> <li>All workflows stored in <code>.github/workflows/</code> caused fork repositories to inherit template development workflows</li> <li>Template-specific workflows (like <code>init.yml</code>) would appear in production forks where they serve no purpose</li> <li>No clear separation between template infrastructure and fork functionality</li> <li>Difficult to maintain and test template workflows without affecting fork behavior</li> </ul> <p>GitHub App Workflow Permissions Discovery:</p> <p>During initialization testing, we encountered a critical permission issue:</p> <ul> <li>GitHub Apps (including <code>GITHUB_TOKEN</code>) cannot create or modify workflow files without explicit <code>workflows</code> permission</li> <li>Error: <code>refusing to allow a GitHub App to create or update workflow .github/workflows/build.yml without workflows permission</code></li> <li>Solution required using Personal Access Token (PAT) with workflows scope as <code>GH_TOKEN</code></li> </ul> <p>Template Bootstrap Pattern Limitation:</p> <p>The existing bootstrap pattern (ADR-007) addressed workflow version updates but didn't solve workflow distribution segregation.</p>"},{"location":"adr/015-template-workflows-separation-pattern/#decision","title":"Decision","text":"<p>Implement a Template-Workflows Separation Pattern that cleanly separates template development from fork production workflows:</p>"},{"location":"adr/015-template-workflows-separation-pattern/#directory-structure","title":"Directory Structure","text":"<pre><code>.github/\n\u251c\u2500\u2500 workflows/                    # Template development workflows\n\u2502   \u251c\u2500\u2500 init.yml                  # Repository initialization\n\u2502   \u251c\u2500\u2500 init-complete.yml         # Repository setup\n\u2502   \u251c\u2500\u2500 dev-ci.yml               # Template testing\n\u2502   \u251c\u2500\u2500 dev-test.yml             # Template validation\n\u2502   \u2514\u2500\u2500 dev-release.yml          # Template releases\n\u2514\u2500\u2500 template-workflows/           # Fork production workflows  \n    \u251c\u2500\u2500 sync.yml                  # Upstream synchronization\n    \u251c\u2500\u2500 validate.yml              # PR validation\n    \u251c\u2500\u2500 build.yml                 # Project builds\n    \u251c\u2500\u2500 release.yml               # Semantic releases\n    \u251c\u2500\u2500 cascade.yml               # Multi-repo cascade\n    \u251c\u2500\u2500 cascade-monitor.yml       # Cascade monitoring\n    \u251c\u2500\u2500 sync-template.yml         # Template updates\n    \u2514\u2500\u2500 dependabot-validation.yml # Dependency automation\n</code></pre>"},{"location":"adr/015-template-workflows-separation-pattern/#initialization-copy-process","title":"Initialization Copy Process","text":"<p>During repository initialization, workflows are copied from <code>template-workflows/</code> to <code>workflows/</code> in the fork:</p> <pre><code># Copy fork workflows from template repository\ngit checkout template/main -- .github/template-workflows/\nmkdir -p .github/workflows\ncp .github/template-workflows/*.yml .github/workflows/\n</code></pre>"},{"location":"adr/015-template-workflows-separation-pattern/#rationale","title":"Rationale","text":""},{"location":"adr/015-template-workflows-separation-pattern/#clear-separation-of-concerns","title":"Clear Separation of Concerns","text":"<ol> <li>Template Development: All template-specific workflows stay in <code>.github/workflows/</code></li> <li>Fork Production: All production workflows stored in <code>.github/template-workflows/</code></li> <li>No Pollution: Forks only receive relevant production workflows</li> <li>Maintainable: Easy to identify and maintain each workflow type</li> </ol>"},{"location":"adr/015-template-workflows-separation-pattern/#security-and-permissions-benefits","title":"Security and Permissions Benefits","text":"<ol> <li>Controlled Distribution: Only intended workflows reach fork repositories</li> <li>Permission Management: Template workflows can have different permission requirements</li> <li>Security Isolation: Template development workflows don't expose fork repositories to unnecessary permissions</li> </ol>"},{"location":"adr/015-template-workflows-separation-pattern/#development-and-testing-advantages","title":"Development and Testing Advantages","text":"<ol> <li>Independent Testing: Template workflows can be tested without affecting fork behavior</li> <li>Clear Ownership: Template developers vs. fork developers have clear workflow boundaries</li> <li>Version Control: Template and fork workflows can evolve independently</li> <li>Documentation: Clear documentation of what gets copied vs. what stays in template</li> </ol>"},{"location":"adr/015-template-workflows-separation-pattern/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/015-template-workflows-separation-pattern/#1-git-submodules-for-workflow-distribution","title":"1. Git Submodules for Workflow Distribution","text":"<ul> <li>Pros: External workflow repository, version pinning</li> <li>Cons: Complex setup, external dependency, requires Git submodule knowledge</li> <li>Decision: Rejected - Adds unnecessary complexity</li> </ul>"},{"location":"adr/015-template-workflows-separation-pattern/#2-workflow-generation-scripts","title":"2. Workflow Generation Scripts","text":"<ul> <li>Pros: Dynamic workflow creation, highly flexible</li> <li>Cons: Complex maintenance, harder to test, less transparent</li> <li>Decision: Rejected - Over-engineering for current needs</li> </ul>"},{"location":"adr/015-template-workflows-separation-pattern/#3-multiple-template-repositories","title":"3. Multiple Template Repositories","text":"<ul> <li>Pros: Complete separation, independent versioning</li> <li>Cons: Maintenance overhead, user confusion, complex updates</li> <li>Decision: Rejected - Breaks single template simplicity</li> </ul>"},{"location":"adr/015-template-workflows-separation-pattern/#4-conditional-workflow-logic","title":"4. Conditional Workflow Logic","text":"<ul> <li>Pros: Single workflow files with template vs. fork behavior</li> <li>Cons: Complex conditions, harder to maintain, poor separation</li> <li>Decision: Rejected - Violates separation of concerns principle</li> </ul>"},{"location":"adr/015-template-workflows-separation-pattern/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/015-template-workflows-separation-pattern/#initialization-process","title":"Initialization Process","text":"<pre><code># init-complete.yml workflow excerpt\nsteps:\n  - name: Copy fork workflows from template repository\n    run: |\n      # Add template remote and fetch\n      git remote add template \"$TEMPLATE_REPO_URL\" || true\n      git fetch template main --depth=1\n\n      # Copy template-workflows directory\n      git checkout template/main -- .github/template-workflows/\n\n      # Ensure workflows directory exists and copy files\n      mkdir -p .github/workflows\n      cp .github/template-workflows/*.yml .github/workflows/\n\n      # Clean up template-workflows directory (no longer needed)\n      rm -rf .github/template-workflows/\n</code></pre>"},{"location":"adr/015-template-workflows-separation-pattern/#sync-configuration-integration","title":"Sync Configuration Integration","text":"<p>Template-workflows are referenced in <code>.github/sync-config.json</code>:</p> <pre><code>{\n  \"sync_rules\": {\n    \"workflows\": {\n      \"template_workflows\": [\n        {\n          \"path\": \".github/template-workflows/sync.yml\",\n          \"description\": \"Upstream repository synchronization\"\n        },\n        {\n          \"path\": \".github/template-workflows/validate.yml\", \n          \"description\": \"PR validation and commit message checks\"\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"adr/015-template-workflows-separation-pattern/#authentication-requirements","title":"Authentication Requirements","text":"<p>Due to GitHub App workflow permission limitations:</p> <ul> <li>Required: Personal Access Token (PAT) with <code>workflows</code> permission as <code>GH_TOKEN</code> secret</li> <li>Fallback: Clear error message if <code>GH_TOKEN</code> not available</li> <li>Process: Checkout action uses <code>${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}</code></li> </ul>"},{"location":"adr/015-template-workflows-separation-pattern/#consequences","title":"Consequences","text":""},{"location":"adr/015-template-workflows-separation-pattern/#positive","title":"Positive","text":"<ul> <li>Clean Fork Repositories: Only production workflows copied, no template pollution</li> <li>Clear Maintenance: Template developers know exactly which workflows affect forks</li> <li>Security Isolation: Template development workflows don't expose forks to unnecessary permissions</li> <li>Better Testing: Template workflows can be tested independently</li> <li>User Experience: Fork repositories have only relevant, functional workflows</li> <li>Version Control: Independent evolution of template vs. fork workflows</li> </ul>"},{"location":"adr/015-template-workflows-separation-pattern/#negative","title":"Negative","text":"<ul> <li>Directory Duplication: Template-workflows must be kept in sync with intended behavior</li> <li>Authentication Complexity: Requires PAT setup for workflow permissions</li> <li>Documentation Overhead: Need to maintain clear documentation of what goes where</li> <li>Migration Impact: Existing documentation needs updates to reflect new pattern</li> </ul>"},{"location":"adr/015-template-workflows-separation-pattern/#mitigation-strategies","title":"Mitigation Strategies","text":"<ol> <li>Clear Documentation: Comprehensive documentation of directory structure and purposes</li> <li>Sync Configuration: Automated tracking of which workflows should be copied</li> <li>Testing Strategy: Validate both template and copied workflows function correctly</li> <li>Migration Guide: Clear instructions for updating existing repositories</li> </ol>"},{"location":"adr/015-template-workflows-separation-pattern/#success-criteria","title":"Success Criteria","text":"<ul> <li>\u2705 Fork repositories contain only production workflows (no init, dev, or template workflows)</li> <li>\u2705 Template repository maintains separation between development and production workflows</li> <li>\u2705 Initialization process successfully copies workflows from template-workflows to workflows</li> <li>\u2705 Authentication works with both GITHUB_TOKEN and GH_TOKEN approaches</li> <li>\u2705 Documentation clearly explains workflow distribution strategy</li> <li>\u2705 Testing validates that copied workflows function correctly in fork repositories</li> </ul>"},{"location":"adr/015-template-workflows-separation-pattern/#testing-and-validation","title":"Testing and Validation","text":""},{"location":"adr/015-template-workflows-separation-pattern/#template-testing","title":"Template Testing","text":"<ol> <li>Template Workflow Testing: Validate init, dev, and release workflows in template repository</li> <li>Copy Process Testing: Ensure template-workflows are correctly copied during initialization</li> <li>Permission Testing: Validate both GITHUB_TOKEN and GH_TOKEN authentication paths</li> </ol>"},{"location":"adr/015-template-workflows-separation-pattern/#fork-testing","title":"Fork Testing","text":"<ol> <li>Production Workflow Testing: Validate copied workflows function in fork repositories</li> <li>No Pollution Testing: Ensure no template development workflows appear in forks</li> <li>Update Testing: Validate template-sync can update production workflows</li> </ol>"},{"location":"adr/015-template-workflows-separation-pattern/#implementation-timeline","title":"Implementation Timeline","text":"<ol> <li>\u2705 Phase 1: Implement template-workflows directory structure</li> <li>\u2705 Phase 2: Update initialization workflow to copy from template-workflows</li> <li>\u2705 Phase 3: Resolve GitHub App workflow permission issues</li> <li>\ud83d\udd04 Phase 4: Update documentation to reflect new pattern</li> <li>\ud83d\udccb Phase 5: Validate with test repositories and gather feedback</li> </ol>"},{"location":"adr/015-template-workflows-separation-pattern/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-006: Two-Workflow Initialization Pattern - This pattern builds on the initialization architecture</li> <li>ADR-007: Initialization Workflow Bootstrap Pattern - This addresses workflow distribution rather than versioning</li> <li>ADR-013: Reusable GitHub Actions Pattern - Complements this with shared action components</li> </ul>"},{"location":"adr/015-template-workflows-separation-pattern/#future-considerations","title":"Future Considerations","text":"<ol> <li>Automatic Sync Validation: Ensure template-workflows stay in sync with intended behavior</li> <li>Workflow Templates: Support for customizable workflow templates per fork type</li> <li>Multi-Environment Support: Different workflow sets for different deployment environments</li> <li>Advanced Permissions: Fine-grained workflow permission management</li> <li>Workflow Analytics: Tracking which workflows are most/least used across forks</li> </ol>"},{"location":"adr/015-template-workflows-separation-pattern/#migration-guide","title":"Migration Guide","text":""},{"location":"adr/015-template-workflows-separation-pattern/#for-template-maintainers","title":"For Template Maintainers","text":"<ol> <li>Move Production Workflows: Move fork-intended workflows from <code>.github/workflows/</code> to <code>.github/template-workflows/</code></li> <li>Update Sync Config: Add template-workflows to <code>.github/sync-config.json</code> </li> <li>Test Initialization: Validate that new repositories get correct workflow set</li> <li>Update Documentation: Reflect new structure in README and architecture docs</li> </ol>"},{"location":"adr/015-template-workflows-separation-pattern/#for-fork-maintainers","title":"For Fork Maintainers","text":"<ol> <li>No Action Required: Existing forks continue to work with current workflows</li> <li>Optional Migration: Can adopt new template-sync workflow for ongoing updates</li> <li>Clean Slate: New forks automatically get clean workflow set</li> </ol>"},{"location":"adr/015-template-workflows-separation-pattern/#references","title":"References","text":"<ul> <li>GitHub Actions Workflow Syntax</li> <li>GitHub App Permissions</li> <li>Template Repository Documentation</li> </ul> <p>\u2190 ADR-014 |  Catalog | ADR-016 \u2192</p>"},{"location":"adr/016-initialization-security-handling/","title":"ADR-016: Initialization Security Handling","text":""},{"location":"adr/016-initialization-security-handling/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/016-initialization-security-handling/#context","title":"Context","text":"<p>Many upstream repositories contain secrets or sensitive data in their git history. GitHub's push protection feature blocks these commits from being pushed, which prevents the initialization workflow from creating the <code>fork_upstream</code> branch during repository setup.</p> <p>Additionally, organizations can enforce push protection at the organization level, which cannot be overridden by repository-level settings.</p>"},{"location":"adr/016-initialization-security-handling/#decision","title":"Decision","text":"<p>We will implement a multi-layered approach to handle push protection during initialization:</p> <ol> <li>Detection: Check for both repository-level and organization-level push protection</li> <li>Mitigation: Attempt to disable push protection at the repository level</li> <li>Alternative Strategies: If disabling fails, try alternative push strategies</li> <li>Clear Guidance: Provide detailed instructions for manual resolution when automated approaches fail</li> </ol>"},{"location":"adr/016-initialization-security-handling/#implementation","title":"Implementation","text":""},{"location":"adr/016-initialization-security-handling/#1-enhanced-security-detection","title":"1. Enhanced Security Detection","text":"<pre><code># Check organization-level push protection status first\nORG_NAME=$(echo \"${{ github.repository }}\" | cut -d'/' -f1)\nORG_PUSH_PROTECTION=\"unknown\"\n\nif ORG_SETTINGS=$(gh api \"/orgs/$ORG_NAME\" 2&gt;/dev/null); then\n  ORG_PUSH_PROTECTION=$(echo \"$ORG_SETTINGS\" | jq -r '.security_and_analysis.secret_scanning_push_protection.status // \"unknown\"')\n  echo \"::notice::Organization-level push protection: $ORG_PUSH_PROTECTION\"\nfi\n\n# Attempt to disable at repository level\ngh api --method PATCH \"/repos/${{ github.repository }}\" \\\n  --input .github/security-off.json\n\n# Verify settings were applied\nREPO_SETTINGS=$(gh api \"/repos/${{ github.repository }}\")\nPUSH_PROTECTION_STATUS=$(echo \"$REPO_SETTINGS\" | jq -r '.security_and_analysis.secret_scanning_push_protection.status // \"unknown\"')\n</code></pre>"},{"location":"adr/016-initialization-security-handling/#2-alternative-push-strategy","title":"2. Alternative Push Strategy","text":"<p>When the initial push fails due to push protection: <pre><code># Create a minimal branch first\ngit checkout -b temp_upstream upstream/$DEFAULT_BRANCH\ngit reset --soft HEAD~1000 2&gt;/dev/null || git reset --soft $(git rev-list --max-parents=0 HEAD)\ngit commit -m \"chore: initial upstream reference\"\n\nif git push -u origin temp_upstream; then\n  # Try to update to full history\n  git checkout -b fork_upstream upstream/$DEFAULT_BRANCH\n  git push -u origin fork_upstream --force\nfi\n</code></pre></p>"},{"location":"adr/016-initialization-security-handling/#3-enhanced-error-handling","title":"3. Enhanced Error Handling","text":"<p>When push protection cannot be bypassed: - Extract secret allowlist URLs from the error output - Create a detailed issue with multiple resolution options - Provide clear instructions for each resolution path</p>"},{"location":"adr/016-initialization-security-handling/#consequences","title":"Consequences","text":""},{"location":"adr/016-initialization-security-handling/#positive","title":"Positive","text":"<ul> <li>Handles both repository-level and organization-level push protection</li> <li>Provides multiple fallback strategies</li> <li>Creates actionable issues with clear resolution steps</li> <li>Automatically extracts and presents secret allowlist URLs</li> <li>Maintains security for all future operations</li> </ul>"},{"location":"adr/016-initialization-security-handling/#negative","title":"Negative","text":"<ul> <li>More complex implementation</li> <li>May require manual intervention for organization-level protection</li> <li>Alternative push strategy might not work in all cases</li> </ul>"},{"location":"adr/016-initialization-security-handling/#security-considerations","title":"Security Considerations","text":"<ul> <li>The temporary disable only affects the initialization process</li> <li>Organization-level protection is respected and not bypassed</li> <li>Users are guided to use GitHub's official secret allowlist mechanism</li> <li>All future operations have full security protection enabled</li> </ul>"},{"location":"adr/016-initialization-security-handling/#manual-resolution-options","title":"Manual Resolution Options","text":"<p>When automated approaches fail, users have three options:</p> <ol> <li>Secret Allowlist URLs: Use GitHub's official mechanism to allow specific secrets</li> <li>Organization Admin Action: Temporarily disable push protection at the organization level</li> <li>Manual Initialization: Clone locally and use <code>git push --no-verify</code> with appropriate permissions</li> </ol>"},{"location":"adr/016-initialization-security-handling/#alternatives-considered","title":"Alternatives Considered","text":"<ol> <li>Simple retry logic: Insufficient for organization-level protection</li> <li>History rewriting: Would break synchronization with upstream</li> <li>Forking without history: Would lose valuable commit history</li> <li>Requiring pre-initialization setup: Would complicate the user experience</li> </ol> <p>The chosen approach balances automation with respect for security policies while providing clear paths for resolution when manual intervention is required.</p> <p>\u2190 ADR-015 |  Catalog | ADR-017 \u2192</p>"},{"location":"adr/017-mcp-server-integration-pattern/","title":"ADR-017: MCP Server Integration Pattern","text":""},{"location":"adr/017-mcp-server-integration-pattern/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/017-mcp-server-integration-pattern/#context","title":"Context","text":"<p>GitHub Copilot Agent can be extended with Model Context Protocol (MCP) servers to provide specialized tools and capabilities. For OSDU fork repositories managed by this template, there's a specific need for AI-enhanced Maven dependency management, security scanning, and version control.</p> <p>The Maven MCP Server provides tools specifically designed for Java/Maven projects, which are common in the OSDU ecosystem. This creates an opportunity to enhance the AI development workflow for fork repositories.</p>"},{"location":"adr/017-mcp-server-integration-pattern/#requirements","title":"Requirements","text":"<ol> <li>Automatic MCP Configuration: Fork repositories should have MCP servers configured automatically during initialization</li> <li>Template Consistency: All fork instances should have the same MCP capabilities</li> <li>Template Updates: MCP configuration should be updatable through template synchronization</li> <li>Security: MCP server integration must follow security best practices</li> <li>Documentation: Clear guidance for users on MCP capabilities and usage</li> </ol>"},{"location":"adr/017-mcp-server-integration-pattern/#current-limitations","title":"Current Limitations","text":"<ul> <li>Manual MCP configuration is error-prone and inconsistent</li> <li>No standardized way to provide MCP capabilities across fork instances</li> <li>Template updates don't include MCP enhancements</li> <li>Limited documentation for AI-enhanced dependency management workflows</li> </ul>"},{"location":"adr/017-mcp-server-integration-pattern/#decision","title":"Decision","text":"<p>We will implement an MCP Configuration Template Pattern that:</p> <ol> <li>Stores MCP configuration in fork-resources: Place <code>mcp-config.json</code> in <code>.github/fork-resources/</code> for automatic deployment</li> <li>Automatically deploys during initialization: Copy MCP configuration to fork repositories during initialization workflow</li> <li>Includes in template synchronization: Allow MCP configuration updates through template sync workflow</li> <li>Provides comprehensive documentation: Include setup instructions and usage examples</li> <li>Uses read-only, security-focused MCP servers: Start with Maven MCP Server which provides read-only dependency analysis</li> </ol>"},{"location":"adr/017-mcp-server-integration-pattern/#implementation-details","title":"Implementation Details","text":"<pre><code>{\n  \"mcpServers\": {\n    \"mvn-mcp-server\": {\n      \"command\": \"uvx\",\n      \"args\": [\"mvn-mcp-server\"]\n    }\n  }\n}\n</code></pre>"},{"location":"adr/017-mcp-server-integration-pattern/#workflow-integration","title":"Workflow Integration","text":"<ul> <li>Initialization: <code>init-complete.yml</code> copies MCP configuration from fork-resources to <code>.github/mcp-config.json</code></li> <li>Template Sync: Future template updates can modify MCP configuration</li> <li>Documentation: Comprehensive guide in <code>doc/mcp-integration.md</code></li> </ul>"},{"location":"adr/017-mcp-server-integration-pattern/#consequences","title":"Consequences","text":""},{"location":"adr/017-mcp-server-integration-pattern/#positive","title":"Positive","text":"<ul> <li>Consistent AI Capabilities: All fork instances have the same MCP server tools</li> <li>Enhanced Dependency Management: AI agents can perform version checking, security scanning, and batch dependency analysis</li> <li>Reduced Setup Friction: No manual MCP configuration required</li> <li>Template Evolution: MCP capabilities can be enhanced across all fork instances</li> <li>Security Focus: Read-only MCP servers minimize security risks</li> <li>Documentation Coverage: Clear guidance for AI-enhanced workflows</li> </ul>"},{"location":"adr/017-mcp-server-integration-pattern/#negative","title":"Negative","text":"<ul> <li>Additional Complexity: Template includes another configuration layer</li> <li>Dependency on External MCP Server: Relies on external repository for MCP server code</li> <li>Network Requirements: MCP server requires network access to Maven Central</li> <li>Python Runtime Dependency: MCP server requires Python 3.12+ and UV package manager</li> </ul>"},{"location":"adr/017-mcp-server-integration-pattern/#risk-mitigation","title":"Risk Mitigation","text":"<ul> <li>MCP Server Validation: Use pinned versions and verify MCP server repository integrity</li> <li>Fallback Behavior: GitHub Copilot Agent works normally without MCP servers if they fail</li> <li>Documentation: Clear troubleshooting guide for MCP-related issues</li> <li>Security Review: Regular review of MCP server capabilities and permissions</li> </ul>"},{"location":"adr/017-mcp-server-integration-pattern/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/017-mcp-server-integration-pattern/#1-manual-mcp-configuration","title":"1. Manual MCP Configuration","text":"<p>Rejected: Inconsistent setup, prone to errors, doesn't scale with template updates</p>"},{"location":"adr/017-mcp-server-integration-pattern/#2-external-mcp-configuration-service","title":"2. External MCP Configuration Service","text":"<p>Rejected: Adds unnecessary complexity and external dependencies</p>"},{"location":"adr/017-mcp-server-integration-pattern/#3-embedded-mcp-tools","title":"3. Embedded MCP Tools","text":"<p>Rejected: Would require maintaining MCP server code within template</p>"},{"location":"adr/017-mcp-server-integration-pattern/#4-no-mcp-integration","title":"4. No MCP Integration","text":"<p>Rejected: Misses opportunity for AI-enhanced dependency management</p>"},{"location":"adr/017-mcp-server-integration-pattern/#implementation-plan","title":"Implementation Plan","text":"<ol> <li>\u2705 Create MCP configuration template in fork-resources</li> <li>\u2705 Update initialization workflow to deploy MCP configuration</li> <li>\u2705 Add comprehensive documentation</li> <li>\u2705 Update completion messages to mention MCP setup</li> <li>\ud83d\udd04 Update Copilot instructions to include MCP context</li> <li>\ud83d\udccb Test MCP integration in fork repository</li> <li>\ud83d\udccb Add MCP configuration to template sync workflow</li> </ol>"},{"location":"adr/017-mcp-server-integration-pattern/#related-adrs","title":"Related ADRs","text":"<ul> <li>ADR-014: AI-Enhanced Development Workflow - Establishes AI-first development patterns</li> <li>ADR-002: GitHub Actions Automation - Provides workflow automation foundation</li> <li>ADR-007: Initialization Workflow Bootstrap - Defines repository setup patterns</li> </ul>"},{"location":"adr/017-mcp-server-integration-pattern/#references","title":"References","text":"<ul> <li>GitHub Copilot MCP Documentation</li> <li>Maven MCP Server Repository</li> <li>Model Context Protocol Specification</li> <li>Template MCP Integration Documentation</li> </ul> <p>\u2190 ADR-016 |  Catalog | ADR-018 \u2192</p>"},{"location":"adr/018-fork-resources-staging-pattern/","title":"ADR-018: Fork-Resources Staging Pattern for Specialized Template Deployment","text":""},{"location":"adr/018-fork-resources-staging-pattern/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/018-fork-resources-staging-pattern/#context","title":"Context","text":"<p>As the Fork Management Template evolved, we discovered a need for template resources that require specialized deployment handling beyond simple file sync or directory copying. Several scenarios emerged:</p> <ol> <li>Issue Templates: Templates that should exist in fork repositories but not be overwritten by regular template sync</li> <li>AI/Copilot Configurations: Settings that need to be deployed to specific locations (<code>.vscode/</code>, <code>.github/</code>) with custom handling</li> <li>Prompt Files: AI prompts that need to be copied to <code>.github/prompts/</code> directory structure</li> <li>Security Configurations: Copilot firewall settings that require variable configuration</li> </ol> <p>The existing sync mechanisms (ADR-011, ADR-012) handle two scenarios well:</p> <ul> <li>Direct sync: Files that are copied as-is to the same location</li> <li>Workflow templates: Files in <code>template-workflows/</code> that are copied to <code>.github/workflows/</code></li> </ul> <p>However, these don't address resources that need:</p> <ul> <li>Multi-target deployment: Single source copied to different final locations</li> <li>Conditional processing: Resources deployed only during initialization or sync updates</li> <li>Cleanup requirements: Staging directories that shouldn't exist in fork repositories</li> <li>Special handling: Files requiring custom deployment logic</li> </ul>"},{"location":"adr/018-fork-resources-staging-pattern/#decision","title":"Decision","text":"<p>We will establish <code>.github/fork-resources/</code> as a staging area pattern for template resources requiring specialized deployment handling.</p>"},{"location":"adr/018-fork-resources-staging-pattern/#architecture","title":"Architecture","text":"<pre><code>Template Repository:\n\u251c\u2500\u2500 .github/\n\u2502   \u251c\u2500\u2500 fork-resources/              # Staging area (template only)\n\u2502   \u2502   \u251c\u2500\u2500 ISSUE_TEMPLATE/          # \u2192 copied to .github/ISSUE_TEMPLATE/\n\u2502   \u2502   \u251c\u2500\u2500 copilot-instructions.md  # \u2192 copied to .github/copilot-instructions.md\n\u2502   \u2502   \u251c\u2500\u2500 copilot-firewall-config.json # \u2192 copied to .github/ + variables\n\u2502   \u2502   \u251c\u2500\u2500 triage.prompt.md         # \u2192 copied to .github/prompts/\n\u2502   \u2502   \u2514\u2500\u2500 .vscode/                 # \u2192 copied to .vscode/\n\u2502   \u2514\u2500\u2500 sync-config.json             # Includes fork-resources in sync rules\n\nFork Repository (after deployment):\n\u251c\u2500\u2500 .github/\n\u2502   \u251c\u2500\u2500 ISSUE_TEMPLATE/              # Final location\n\u2502   \u251c\u2500\u2500 copilot-instructions.md     # Final location\n\u2502   \u251c\u2500\u2500 prompts/                     # Final location\n\u2502   \u2514\u2500\u2500 (no fork-resources/)        # Staging area removed\n\u251c\u2500\u2500 .vscode/                         # Final location\n</code></pre>"},{"location":"adr/018-fork-resources-staging-pattern/#deployment-mechanisms","title":"Deployment Mechanisms","text":"<ol> <li>Initialization Deployment (<code>init-complete.yml</code>):</li> <li>Copy fork-resources contents to final locations during repository setup</li> <li> <p>Remove fork-resources directory after copying</p> </li> <li> <p>Update Deployment (<code>sync-template.yml</code>):</p> </li> <li>Sync fork-resources directory when it changes in template</li> <li>Copy updated resources to final locations</li> <li> <p>Remove fork-resources directory after copying</p> </li> <li> <p>Sync Configuration (<code>sync-config.json</code>):</p> </li> <li>Include <code>.github/fork-resources</code> as a synced directory</li> <li>Enable automatic detection of fork-resources changes</li> </ol>"},{"location":"adr/018-fork-resources-staging-pattern/#pattern-rules","title":"Pattern Rules","text":"<ol> <li>Staging Only: Fork-resources directory exists only in template repository, never in forks</li> <li>Specialized Logic: Each resource type can have custom deployment logic</li> <li>Cleanup Required: Deployment workflows must remove fork-resources after processing</li> <li>Sync Integration: Changes to fork-resources trigger template sync workflow</li> </ol>"},{"location":"adr/018-fork-resources-staging-pattern/#rationale","title":"Rationale","text":""},{"location":"adr/018-fork-resources-staging-pattern/#why-staging-area-pattern","title":"Why Staging Area Pattern?","text":"<p>Alternative 1: Direct Sync</p> <ul> <li>\u274c Issue templates would be overwritten by every sync update</li> <li>\u274c No way to handle multi-target deployment (<code>.vscode/</code>, <code>.github/prompts/</code>)</li> <li>\u274c Cannot implement conditional or custom deployment logic</li> </ul> <p>Alternative 2: Hardcoded Deployment</p> <ul> <li>\u274c Not extensible for future template resources</li> <li>\u274c Would require workflow changes for each new resource type</li> <li>\u274c Difficult to maintain consistency across different resource types</li> </ul> <p>Alternative 3: Fork-Resources Staging \u2705</p> <ul> <li>\u2705 Provides flexibility for specialized deployment</li> <li>\u2705 Extensible pattern for future template resources</li> <li>\u2705 Maintains clean separation between template staging and fork deployment</li> <li>\u2705 Integrates with existing sync mechanisms</li> </ul>"},{"location":"adr/018-fork-resources-staging-pattern/#benefits","title":"Benefits","text":"<ol> <li>Extensibility: Easy to add new types of specialized template resources</li> <li>Consistency: Standardized pattern for all resources requiring special handling</li> <li>Maintainability: Clear separation between staging (template) and deployment (forks)</li> <li>Integration: Works seamlessly with existing sync and initialization workflows</li> </ol>"},{"location":"adr/018-fork-resources-staging-pattern/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/018-fork-resources-staging-pattern/#sync-configuration-extension","title":"Sync Configuration Extension","text":"<pre><code>{\n  \"sync_rules\": {\n    \"directories\": [\n      {\n        \"path\": \".github/fork-resources\",\n        \"sync_all\": true,\n        \"description\": \"Fork-specific templates and configuration that get copied during sync updates\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"adr/018-fork-resources-staging-pattern/#deployment-logic-pattern","title":"Deployment Logic Pattern","text":"<pre><code># Copy templates to final locations\nif [ -d \".github/fork-resources/ISSUE_TEMPLATE\" ]; then\n  mkdir -p \".github/ISSUE_TEMPLATE\"\n  cp -r \".github/fork-resources/ISSUE_TEMPLATE/\"* \".github/ISSUE_TEMPLATE/\"\n  git add \".github/ISSUE_TEMPLATE/\"\nfi\n\n# Remove staging area after deployment\nrm -rf \".github/fork-resources\"\n</code></pre>"},{"location":"adr/018-fork-resources-staging-pattern/#consequences","title":"Consequences","text":""},{"location":"adr/018-fork-resources-staging-pattern/#positive","title":"Positive","text":"<ul> <li>Flexible Template Deployment: Enables sophisticated template resource handling</li> <li>Clean Fork Repositories: No staging artifacts in fork repositories</li> <li>Extensible Pattern: Easy to add new specialized template resources</li> <li>Maintains Sync Integration: Leverages existing template sync mechanisms</li> </ul>"},{"location":"adr/018-fork-resources-staging-pattern/#negative","title":"Negative","text":"<ul> <li>Added Complexity: More complex than direct file sync</li> <li>Deployment Logic Required: Each resource type needs specific deployment handling</li> <li>Two-Stage Process: Resources must be maintained in staging area, not final location</li> </ul>"},{"location":"adr/018-fork-resources-staging-pattern/#risks","title":"Risks","text":"<ul> <li>Inconsistent Deployment: Risk of different deployment logic for similar resources</li> <li>Cleanup Dependency: Deployment workflows must properly remove staging areas</li> </ul>"},{"location":"adr/018-fork-resources-staging-pattern/#compliance","title":"Compliance","text":"<p>This ADR extends:</p> <ul> <li>ADR-011: Adds fork-resources to configuration-driven sync rules</li> <li>ADR-012: Incorporates specialized deployment into template update propagation</li> <li>ADR-017: Generalizes the MCP integration pattern for all specialized resources</li> </ul>"},{"location":"adr/018-fork-resources-staging-pattern/#examples","title":"Examples","text":""},{"location":"adr/018-fork-resources-staging-pattern/#current-fork-resources","title":"Current Fork-Resources","text":"<ol> <li>Issue Templates: <code>ISSUE_TEMPLATE/triage.md</code> \u2192 <code>.github/ISSUE_TEMPLATE/triage.md</code></li> <li>Copilot Config: <code>copilot-instructions.md</code> \u2192 <code>.github/copilot-instructions.md</code></li> <li>MCP Config: <code>.vscode/mcp.json</code> \u2192 <code>.vscode/mcp.json</code></li> <li>AI Prompts: <code>triage.prompt.md</code> \u2192 <code>.github/prompts/triage.prompt.md</code></li> <li>Security Config: <code>copilot-firewall-config.json</code> \u2192 <code>.github/</code> + repository variables</li> </ol>"},{"location":"adr/018-fork-resources-staging-pattern/#future-extensions","title":"Future Extensions","text":"<ul> <li>GitHub App Settings: Templates for GitHub App configurations</li> <li>Documentation Templates: Project-specific documentation that needs custom deployment</li> <li>Development Tools: Additional development environment configurations</li> </ul> <p>This ADR establishes the architectural foundation for specialized template deployment, enabling the Fork Management Template to handle sophisticated resource distribution while maintaining clean separation between template staging and fork deployment.</p> <p>\u2190 ADR-017 |  Catalog | ADR-019 \u2192</p>"},{"location":"adr/019-cascade-monitor-pattern/","title":"ADR-019: Cascade Monitor Pattern","text":""},{"location":"adr/019-cascade-monitor-pattern/#status","title":"Status","text":"<p>Accepted - 2025-10-01  </p>"},{"location":"adr/019-cascade-monitor-pattern/#context","title":"Context","text":"<p>The cascade workflow needs to be triggered when upstream changes are merged into the <code>fork_upstream</code> branch. However, experience has shown that automatic triggering creates reliability and usability issues:</p> <ol> <li>Event Trigger Limitations: <code>pull_request_target</code> events require workflows to exist on the target branch (<code>fork_upstream</code>), but this branch is a pure mirror without workflow files</li> <li>Human Control: Teams want explicit control over when integration happens, not automatic triggering</li> <li>Timing Control: Humans may want to batch multiple changes or time integrations appropriately</li> <li>Visibility Requirements: Clear audit trails and progress tracking are needed throughout the cascade lifecycle</li> <li>Error Recovery: Failed or missed triggers need reliable detection and recovery mechanisms</li> </ol> <p>The original approach assumed automatic triggering was preferred, but this created:</p> <ul> <li>Unreliable triggering due to workflow file availability issues</li> <li>Lack of human control over integration timing</li> <li>Poor visibility into cascade progress and state</li> <li>Complex error handling for edge cases</li> <li>No comprehensive tracking of issue lifecycle</li> </ul>"},{"location":"adr/019-cascade-monitor-pattern/#decision","title":"Decision","text":"<p>Implement a Human-Centric Cascade Pattern with monitor-based safety net:</p> <ol> <li>Primary Path - Manual Triggering: Humans manually trigger cascade integration after reviewing and merging sync PRs</li> <li>Safety Net - Monitor Detection: <code>cascade-monitor.yml</code> detects missed triggers and automatically initiates cascades as fallback</li> <li>Issue Lifecycle Tracking: Comprehensive tracking of cascade state through GitHub issues with label management</li> <li>cascade.yml: Enhanced with issue tracking and progress updates throughout the cascade process</li> <li>Human-in-the-Loop: Explicit human control points with clear instructions and visibility</li> </ol>"},{"location":"adr/019-cascade-monitor-pattern/#rationale","title":"Rationale","text":""},{"location":"adr/019-cascade-monitor-pattern/#human-control-and-visibility","title":"Human Control and Visibility","text":"<ul> <li>Explicit Human Decisions: Humans control when integration happens after reviewing changes</li> <li>Clear Instructions: sync.yml provides explicit steps for manual cascade triggering</li> <li>Issue Lifecycle Tracking: Complete audit trail from sync detection to production deployment</li> <li>Progress Visibility: Real-time updates on cascade state through issue comments</li> </ul>"},{"location":"adr/019-cascade-monitor-pattern/#reliable-safety-net","title":"Reliable Safety Net","text":"<ul> <li>Monitor as Backup: Detects when humans forget to trigger cascades</li> <li>Automatic Recovery: Safety net triggers missed cascades with clear documentation</li> <li>Git-based Detection: Uses reliable branch comparison to detect pending changes</li> <li>No Event Dependencies: Not dependent on GitHub event triggering limitations</li> </ul>"},{"location":"adr/019-cascade-monitor-pattern/#comprehensive-state-management","title":"Comprehensive State Management","text":"<ul> <li>Label-based Tracking: Issue labels track cascade state progression</li> <li>Comment-based Updates: Detailed progress updates in tracking issues  </li> <li>Error State Handling: Automated failure detection and recovery workflows</li> <li>Completion Tracking: Issues closed when changes reach production</li> <li>Self-Healing Recovery: Automatic retry system based on human intervention signals</li> </ul>"},{"location":"adr/019-cascade-monitor-pattern/#improved-team-experience","title":"Improved Team Experience","text":"<ul> <li>Predictable Process: Teams know exactly when and how to trigger cascades</li> <li>Better Timing Control: Can batch changes or time integrations appropriately</li> <li>Clear Error Recovery: Obvious next steps when things go wrong</li> <li>Reduced Surprises: No unexpected automatic triggers</li> </ul>"},{"location":"adr/019-cascade-monitor-pattern/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/019-cascade-monitor-pattern/#1-direct-push-triggers","title":"1. Direct Push Triggers","text":"<p><pre><code># In cascade.yml\non:\n  push:\n    branches: [fork_upstream]\n</code></pre> Pros: Simple, immediate triggering Cons: Fires on all pushes, not just sync merges; no way to filter by intent Decision: Rejected due to unwanted triggers</p>"},{"location":"adr/019-cascade-monitor-pattern/#2-combined-pr-and-push-triggers","title":"2. Combined PR and Push Triggers","text":"<pre><code># In cascade.yml (original approach)\non:\n  push:\n    branches: [fork_upstream, fork_integration]\n  pull_request:\n    types: [closed]\n    branches: [fork_upstream, fork_integration]\n</code></pre> <p>Pros: Handles various trigger scenarios Cons: Complex conditional logic; hard to debug; no error handling Decision: Rejected due to complexity and reliability issues</p>"},{"location":"adr/019-cascade-monitor-pattern/#3-external-webhook-system","title":"3. External Webhook System","text":"<p>Pros: Maximum flexibility, external control Cons: Additional infrastructure; more complex setup; maintenance overhead Decision: Rejected due to complexity for minimal benefit</p>"},{"location":"adr/019-cascade-monitor-pattern/#4-scheduled-polling","title":"4. Scheduled Polling","text":"<pre><code>on:\n  schedule:\n    - cron: '*/5 * * * *'  # Every 5 minutes\n</code></pre> <p>Pros: Guaranteed to catch changes eventually Cons: Up to 5-minute delay; inefficient; doesn't scale well Decision: Rejected as primary approach (kept as backup in monitor)</p>"},{"location":"adr/019-cascade-monitor-pattern/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/019-cascade-monitor-pattern/#sync-workflow-instructions","title":"Sync Workflow Instructions","text":"<pre><code># In sync.yml notification\n**Next Steps:**\n1. \ud83d\udd0d **Review the sync PR** for any breaking changes or conflicts\n2. \u2705 **Merge the PR** when satisfied with the changes  \n3. \ud83d\ude80 **Manually trigger 'Cascade Integration' workflow** to integrate changes\n4. \ud83d\udcca **Monitor cascade progress** in Actions tab\n</code></pre>"},{"location":"adr/019-cascade-monitor-pattern/#monitor-safety-net-structure","title":"Monitor Safety Net Structure","text":"<pre><code>name: Cascade Monitor\n\non:\n  schedule:\n    - cron: '0 */6 * * *'  # Safety net detection every 6 hours\n  workflow_dispatch:        # Manual health checking\n\njobs:\n  detect-missed-cascade:\n    steps:\n      - name: Check for missed cascade triggers\n        run: |\n          # Check if fork_upstream has commits that fork_integration doesn't\n          UPSTREAM_COMMITS=$(git rev-list --count origin/fork_integration..origin/fork_upstream)\n\n          if [ \"$UPSTREAM_COMMITS\" -gt 0 ]; then\n            # Find tracking issue using improved label search\n            ISSUE_NUMBER=$(gh issue list \\\n              --label \"upstream-sync\" \\\n              --state open \\\n              --limit 1 \\\n              --json number \\\n              --jq '.[0].number // empty')\n\n            if [ -n \"$ISSUE_NUMBER\" ]; then\n              # Comment on issue and auto-trigger cascade as safety net\n              gh workflow run \"Cascade Integration\" \\\n                --repo ${{ github.repository }} \\\n                -f issue_number=\"$ISSUE_NUMBER\"\n            fi\n          fi\n</code></pre>"},{"location":"adr/019-cascade-monitor-pattern/#issue-lifecycle-tracking","title":"Issue Lifecycle Tracking","text":"<pre><code># Cascade workflow uses provided issue number for tracking\n\n# Issue number passed as workflow input\nISSUE_NUMBER=\"${{ github.event.inputs.issue_number }}\"\n\n# When cascade starts\ngh issue edit \"$ISSUE_NUMBER\" \\\n  --remove-label \"human-required\" \\\n  --add-label \"cascade-active\"\n\ngh issue comment \"$ISSUE_NUMBER\" --body \"\ud83d\ude80 **Cascade Integration Started** - $(date -u +%Y-%m-%dT%H:%M:%SZ)\nIntegration workflow has been triggered and is now processing upstream changes.\"\n\n# When conflicts detected\ngh issue edit \"$ISSUE_NUMBER\" \\\n  --remove-label \"cascade-active\" \\\n  --add-label \"cascade-blocked\"\n\n# When production PR created\ngh issue edit \"$ISSUE_NUMBER\" \\\n  --remove-label \"cascade-active\" \\\n  --add-label \"production-ready\"\n\ngh issue comment \"$ISSUE_NUMBER\" --body \"\ud83c\udfaf **Production PR Created** - $(date -u +%Y-%m-%dT%H:%M:%SZ)\nIntegration completed successfully! Production PR has been created and is ready for final review.\"\n</code></pre>"},{"location":"adr/019-cascade-monitor-pattern/#health-monitoring-integration","title":"Health Monitoring Integration","text":"<p>The monitor also includes periodic health checks:</p> <ul> <li>Stale Conflict Detection: Find conflicts older than 48 hours</li> <li>Pipeline Health Reports: Overall cascade pipeline status</li> <li>Escalation Management: Automatic escalation of long-running issues</li> </ul>"},{"location":"adr/019-cascade-monitor-pattern/#consequences","title":"Consequences","text":""},{"location":"adr/019-cascade-monitor-pattern/#positive","title":"Positive","text":"<ul> <li>Human Control: Teams have explicit control over integration timing</li> <li>Reliability: No dependency on GitHub event triggering edge cases</li> <li>Visibility: Complete audit trail through issue lifecycle tracking</li> <li>Error Recovery: Clear path to resolution when things go wrong</li> <li>Predictability: Consistent, documented process for all team members</li> <li>Safety Net: Automatic detection and recovery of missed triggers</li> <li>Flexibility: Can batch changes or time integrations appropriately</li> </ul>"},{"location":"adr/019-cascade-monitor-pattern/#negative","title":"Negative","text":"<ul> <li>Manual Step Required: Humans must remember to trigger cascades</li> <li>Potential Delays: Up to 6 hours delay if manual trigger is forgotten</li> <li>Additional Complexity: Issue lifecycle tracking adds workflow complexity</li> <li>Learning Curve: Team needs to understand manual trigger process</li> <li>Monitor Dependency: Safety net relies on monitor workflow functioning</li> </ul>"},{"location":"adr/019-cascade-monitor-pattern/#neutral","title":"Neutral","text":"<ul> <li>File Count: Adds one additional workflow file</li> <li>Maintenance: Two simpler workflows vs. one complex workflow</li> <li>Testing: Need to test both trigger detection and cascade execution</li> </ul>"},{"location":"adr/019-cascade-monitor-pattern/#integration-points","title":"Integration Points","text":""},{"location":"adr/019-cascade-monitor-pattern/#with-sync-workflow","title":"With Sync Workflow","text":"<ul> <li>Sync workflow creates PRs with <code>upstream-sync</code> label</li> <li>Sync workflow creates tracking issues with explicit manual trigger instructions</li> <li>Humans review, merge PR, and manually trigger cascade</li> </ul>"},{"location":"adr/019-cascade-monitor-pattern/#with-cascade-workflow","title":"With Cascade Workflow","text":"<ul> <li>Cascade runs on <code>workflow_dispatch</code> (manual or monitor-triggered)</li> <li>Cascade updates tracking issue labels and comments throughout process</li> <li>Cascade handles conflicts, integration, and production PR creation</li> <li>Error states tracked through issue labels and comments</li> </ul>"},{"location":"adr/019-cascade-monitor-pattern/#with-label-management-adr-008","title":"With Label Management (ADR-008)","text":"<ul> <li>Uses predefined labels: <code>upstream-sync</code>, <code>cascade-trigger-failed</code>, <code>human-required</code></li> <li>Leverages existing label-based notification system</li> <li>Maintains consistency with other workflow patterns</li> </ul>"},{"location":"adr/019-cascade-monitor-pattern/#monitoring-and-alerting","title":"Monitoring and Alerting","text":""},{"location":"adr/019-cascade-monitor-pattern/#success-metrics","title":"Success Metrics","text":"<ul> <li>Manual Trigger Adoption: % of sync merges followed by manual cascade triggers</li> <li>Safety Net Effectiveness: % of missed triggers caught by monitor</li> <li>Issue Lifecycle Completeness: % of cascades with complete issue tracking</li> <li>Human Response Time: Time between sync completion and manual trigger</li> <li>Error Recovery: Time to resolve cascade conflicts and issues</li> </ul>"},{"location":"adr/019-cascade-monitor-pattern/#failure-modes","title":"Failure Modes","text":"<ol> <li>Forgotten Manual Trigger: Monitor safety net detects and auto-triggers</li> <li>Monitor Workflow Failure: Manual cascade trigger still available</li> <li>Issue Tracking Failure: Cascade proceeds but with reduced visibility</li> <li>Cascade Integration Conflicts: Clear conflict resolution workflow with SLA</li> </ol>"},{"location":"adr/019-cascade-monitor-pattern/#health-checks","title":"Health Checks","text":"<ul> <li>Daily Pipeline Status: Monitor generates health reports</li> <li>Stale Issue Detection: Automatically escalates old problems</li> <li>Cascade Pipeline Monitoring: Overall system health visibility</li> </ul>"},{"location":"adr/019-cascade-monitor-pattern/#future-enhancements","title":"Future Enhancements","text":""},{"location":"adr/019-cascade-monitor-pattern/#planned-improvements","title":"Planned Improvements","text":"<ol> <li>Batch Triggering: Group multiple rapid changes into single cascade</li> <li>Priority Queuing: Handle urgent vs. routine upstream changes differently</li> <li>Smart Scheduling: Avoid triggers during maintenance windows</li> <li>Cross-Repository Coordination: Coordinate cascades across multiple forks</li> </ol>"},{"location":"adr/019-cascade-monitor-pattern/#extensibility-points","title":"Extensibility Points","text":"<ul> <li>Custom Trigger Logic: Easy to add new trigger conditions</li> <li>External Integrations: Webhook support for external systems</li> <li>Advanced Error Handling: Sophisticated retry and recovery strategies</li> <li>Metrics Collection: Detailed analytics on trigger patterns</li> </ul>"},{"location":"adr/019-cascade-monitor-pattern/#automated-failure-recovery-pattern","title":"Automated Failure Recovery Pattern","text":"<p>The monitor implements a sophisticated failure recovery system that enables self-healing cascade workflows:</p>"},{"location":"adr/019-cascade-monitor-pattern/#failure-state-management","title":"Failure State Management","text":"<pre><code># Normal cascade state progression\nupstream-sync \u2192 cascade-active \u2192 validated\n\n# Failure state progression  \nupstream-sync \u2192 cascade-active \u2192 cascade-failed + human-required\n</code></pre>"},{"location":"adr/019-cascade-monitor-pattern/#recovery-detection-logic","title":"Recovery Detection Logic","text":"<pre><code>detect-recovery-ready:\n  name: \"\ud83d\udd04 Automatic Recovery - Detect Ready Retries\"\n  steps:\n    - name: Check for recovery-ready issues\n      run: |\n        # Find issues with cascade-failed but NOT human-required\n        RECOVERY_ISSUES=$(gh issue list \\\n          --label \"cascade-failed\" \\\n          --state open \\\n          --jq '.[] | select(.labels | contains([\"cascade-failed\"]) and (contains([\"human-required\"]) | not))')\n\n        # For each recovery-ready issue\n        echo \"$RECOVERY_ISSUES\" | jq -r '.number' | while read ISSUE_NUMBER; do\n          # Update labels: cascade-failed \u2192 cascade-active\n          gh issue edit \"$ISSUE_NUMBER\" \\\n            --remove-label \"cascade-failed\" \\\n            --add-label \"cascade-active\"\n\n          # Trigger cascade retry\n          gh workflow run \"Cascade Integration\" \\\n            --repo ${{ github.repository }} \\\n            -f issue_number=\"$ISSUE_NUMBER\"\n        done\n</code></pre>"},{"location":"adr/019-cascade-monitor-pattern/#human-recovery-workflow","title":"Human Recovery Workflow","text":"<ol> <li>Failure Occurs: Cascade fails, tracking issue gets <code>cascade-failed + human-required</code></li> <li>Failure Issue Created: Technical details in separate high-priority issue</li> <li>Human Investigation: Developer reviews failure issue and makes fixes</li> <li>Signal Resolution: Human removes <code>human-required</code> label from tracking issue</li> <li>Automatic Retry: Monitor detects label removal and retries cascade</li> <li>Success/Failure: Either completes successfully or creates new failure issue</li> </ol>"},{"location":"adr/019-cascade-monitor-pattern/#benefits-of-label-based-recovery","title":"Benefits of Label-Based Recovery","text":"<ul> <li>Self-Healing: No manual workflow triggering required</li> <li>Clear Handoff: Labels signal automation \u2194 human transitions</li> <li>Audit Trail: Complete failure/recovery history in tracking issues</li> <li>Robust Error Handling: Multiple failure attempts tracked separately</li> <li>Predictable Process: Developers know exactly how to signal resolution</li> </ul>"},{"location":"adr/019-cascade-monitor-pattern/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-001: Three-Branch Fork Management Strategy - Defines the cascade target branches</li> <li>ADR-005: Automated Conflict Management Strategy - Conflict handling within cascades</li> <li>ADR-008: Centralized Label Management Strategy - Label-based state management</li> <li>ADR-009: Asymmetric Cascade Review Strategy - Review requirements for cascades</li> </ul>"},{"location":"adr/019-cascade-monitor-pattern/#success-criteria","title":"Success Criteria","text":"<ul> <li>90%+ of sync merges followed by manual cascade triggers within 2 hours</li> <li>100% of missed manual triggers detected by safety net within 6 hours</li> <li>Complete issue lifecycle tracking for 95%+ of cascades</li> <li>Conflict resolution SLA: 48 hours with automatic escalation</li> <li>Zero unexpected cascade triggers (only manual or safety net)</li> <li>Clear audit trail for all cascade decisions through issue tracking</li> <li>Team adoption: 100% of team members comfortable with manual trigger process</li> </ul> <p>\u2190 ADR-018 |  Catalog | ADR-020 \u2192</p>"},{"location":"adr/020-human-required-label-strategy/","title":"ADR-020: Human-Required Label Strategy","text":""},{"location":"adr/020-human-required-label-strategy/#status","title":"Status","text":"<p>Accepted - 2025-10-01  </p>"},{"location":"adr/020-human-required-label-strategy/#context","title":"Context","text":"<p>GitHub workflows often need to create issues and pull requests that require human attention. The traditional approach is to assign these items to specific users using the <code>--assignee</code> flag in GitHub CLI commands. However, this approach has several significant problems:</p> <ol> <li>Username Resolution Issues: GitHub's GraphQL API requires exact usernames, and organization names cannot be assigned to issues</li> <li>Dynamic User Context: Different workflows run in different contexts (different triggering users, repository owners)</li> <li>API Failures: Invalid usernames cause workflow failures with cryptic GraphQL errors like \"Could not resolve to a User with the login of 'organization-name'\"</li> <li>Maintenance Overhead: Hardcoded usernames become stale and need constant updates</li> <li>Cross-Repository Complexity: Template repositories used across multiple instances need flexible assignment</li> </ol> <p>The original implementation used patterns like:</p> <pre><code>--assignee \"${{ github.repository_owner }}\"  # Organization name (invalid)\n--assignee \"hardcoded-username\"              # Brittle and unmaintainable\n</code></pre> <p>This led to workflow failures that blocked critical automation processes.</p>"},{"location":"adr/020-human-required-label-strategy/#decision","title":"Decision","text":"<p>Replace assignee-based task management with a Human-Required Label Strategy that uses GitHub's label system for task visibility and workflow management:</p> <ol> <li>Eliminate Assignees: Remove all <code>--assignee</code> flags from automated workflows</li> <li>Human-Required Label: Use <code>human-required</code> label to mark items needing attention</li> <li>Label-Based Filtering: Team members can filter on labels to find work</li> <li>Robust Labeling: Labels never fail - no username resolution required</li> <li>Flexible Organization: Different label combinations for different priority/types</li> </ol>"},{"location":"adr/020-human-required-label-strategy/#rationale","title":"Rationale","text":""},{"location":"adr/020-human-required-label-strategy/#reliability-benefits","title":"Reliability Benefits","text":"<ul> <li>No Username Resolution: Labels don't require user validation</li> <li>Never Fail: Invalid labels are ignored, not workflow-blocking errors</li> <li>Universal Compatibility: Works across all repositories and contexts</li> <li>Template-Friendly: No hardcoded usernames in template repositories</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#workflow-management-benefits","title":"Workflow Management Benefits","text":"<ul> <li>Better Filtering: Teams can create custom views using label combinations</li> <li>Priority Systems: Multiple priority labels (<code>high-priority</code>, <code>emergency</code>) </li> <li>Type Classification: Label-based categorization (<code>conflict</code>, <code>sync-failed</code>, <code>escalation</code>)</li> <li>Automated Processing: Workflows can query and act on labels reliably</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#organizational-benefits","title":"Organizational Benefits","text":"<ul> <li>Team Flexibility: Any team member can work on <code>human-required</code> items</li> <li>Load Balancing: No single person overwhelmed with assignments</li> <li>Scalable Process: Works regardless of team size or structure</li> <li>Clear Ownership: Labels indicate type and urgency without specific assignment</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/020-human-required-label-strategy/#core-labels-used","title":"Core Labels Used","text":"<p>From <code>.github/labels.json</code> (managed by ADR-008): <pre><code>{\n  \"name\": \"human-required\",\n  \"description\": \"Requires human intervention or review\",\n  \"color\": \"D73A49\"\n}\n</code></pre></p>"},{"location":"adr/020-human-required-label-strategy/#supporting-labels","title":"Supporting Labels","text":"<ul> <li><code>high-priority</code>: Urgent items requiring immediate attention</li> <li><code>conflict</code>: Merge conflicts requiring manual resolution</li> <li><code>escalation</code>: Issues that have exceeded SLA timeouts</li> <li><code>sync-failed</code>: Failed synchronization operations</li> <li><code>cascade-trigger-failed</code>: Failed cascade workflow triggers</li> <li><code>human-required</code>: Items that need human review/action</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#issue-lifecycle-labels-adr-022","title":"Issue Lifecycle Labels (ADR-022)","text":"<ul> <li><code>upstream-sync</code>: Issues related to upstream synchronization</li> <li><code>cascade-active</code>: Cascade integration currently in progress</li> <li><code>cascade-blocked</code>: Cascade blocked by conflicts or issues</li> <li><code>validated</code>: Integration complete, validation successful</li> <li><code>template-sync</code>: Issues related to template updates</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#workflow-implementation-pattern","title":"Workflow Implementation Pattern","text":"<p>Before (Problematic):</p> <pre><code># Validate assignee before creating issue\nASSIGNEE=\"${{ github.actor }}\"\nif gh api users/\"$ASSIGNEE\" &gt;/dev/null 2&gt;&amp;1; then\n  ASSIGNEE_FLAG=\"--assignee $ASSIGNEE\"\nelse\n  ASSIGNEE_FLAG=\"\"\nfi\n\ngh issue create \\\n  --title \"Issue requiring attention\" \\\n  --body \"Issue details...\" \\\n  --label \"some-label\" \\\n  $ASSIGNEE_FLAG\n</code></pre> <p>After (Robust with Lifecycle Tracking):</p> <pre><code># Simple, reliable issue creation with lifecycle tracking\ngh issue create \\\n  --title \"\ud83d\udce5 Upstream Sync Ready for Review - $(date +%Y-%m-%d)\" \\\n  --body \"$NOTIFICATION_BODY\" \\\n  --label \"upstream-sync,human-required\"\n\n# Dynamic label updates during cascade lifecycle\ngh issue edit \"$ISSUE_NUMBER\" \\\n  --remove-label \"human-required\" \\\n  --add-label \"cascade-active\"\n</code></pre>"},{"location":"adr/020-human-required-label-strategy/#team-workflow-integration","title":"Team Workflow Integration","text":"<p>GitHub Issue Filters:</p> <pre><code># Find all items requiring human attention\nlabel:human-required\n\n# High priority items only\nlabel:human-required label:high-priority\n\n# Conflicts needing resolution\nlabel:human-required label:conflict\n\n# Failed automation items\nlabel:human-required label:sync-failed\n\n# Cascade lifecycle tracking\nlabel:upstream-sync label:human-required     # Needs manual cascade trigger\nlabel:upstream-sync label:cascade-active     # Integration in progress\nlabel:upstream-sync label:cascade-blocked    # Blocked by conflicts\nlabel:upstream-sync label:production-ready   # Ready for production merge\n</code></pre> <p>GitHub Project Automation:</p> <pre><code># Project board rules\n- label:human-required \u2192 \"Needs Attention\" column\n- label:high-priority \u2192 \"Urgent\" column  \n- label:conflict \u2192 \"Conflicts\" column\n</code></pre>"},{"location":"adr/020-human-required-label-strategy/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/020-human-required-label-strategy/#1-enhanced-user-validation","title":"1. Enhanced User Validation","text":"<pre><code># Complex validation logic\nif gh api users/\"${{ github.actor }}\" &gt;/dev/null 2&gt;&amp;1; then\n  ASSIGNEE_FLAG=\"--assignee ${{ github.actor }}\"\nelif gh api users/\"${{ github.repository_owner }}\" &gt;/dev/null 2&gt;&amp;1; then\n  ASSIGNEE_FLAG=\"--assignee ${{ github.repository_owner }}\"\nelse\n  ASSIGNEE_FLAG=\"--assignee $(gh api /repos/:owner/:repo/collaborators --jq '.[0].login')\"\nfi\n</code></pre> <p>Pros: Maintains assignment approach</p> <p>Cons: Complex, fragile, still fails in edge cases, API rate limiting</p> <p>Decision: Rejected due to complexity and unreliability</p>"},{"location":"adr/020-human-required-label-strategy/#2-configuration-based-assignment","title":"2. Configuration-Based Assignment","text":"<p><pre><code># Store usernames in repository variables\n--assignee \"${{ vars.DEFAULT_ASSIGNEE }}\"\n</code></pre> Pros: Configurable per repository</p> <p>Cons: Still requires username validation; manual setup; maintenance overhead</p> <p>Decision: Rejected due to maintenance burden</p>"},{"location":"adr/020-human-required-label-strategy/#3-external-assignment-service","title":"3. External Assignment Service","text":"<p>Pros: Could handle complex assignment logic</p> <p>Cons: Additional infrastructure; complexity; single point of failure</p> <p>Decision: Rejected as over-engineering</p>"},{"location":"adr/020-human-required-label-strategy/#4-hybrid-approach-assignment-labels","title":"4. Hybrid Approach (Assignment + Labels)","text":"<pre><code># Try assignment, fall back to labels\nif [[ -n \"${{ vars.DEFAULT_ASSIGNEE }}\" ]]; then\n  --assignee \"${{ vars.DEFAULT_ASSIGNEE }}\"\nfi\n--label \"human-required\"\n</code></pre> <p>Pros: Best of both worlds</p> <p>Cons: Still susceptible to assignment failures; increased complexity</p> <p>Decision: Rejected in favor of label-only simplicity</p>"},{"location":"adr/020-human-required-label-strategy/#migration-strategy","title":"Migration Strategy","text":""},{"location":"adr/020-human-required-label-strategy/#phase-1-add-labels-completed","title":"Phase 1: Add Labels (Completed)","text":"<ul> <li>Add <code>human-required</code> label to all new issue/PR creation</li> <li>Keep existing assignee logic temporarily</li> <li>Monitor for assignment failures</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#phase-2-remove-assignees-completed","title":"Phase 2: Remove Assignees (Completed)","text":"<ul> <li>Remove all <code>--assignee</code> flags from workflows</li> <li>Simplify issue/PR creation logic</li> <li>Update error handling to remove validation</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#phase-3-team-adoption","title":"Phase 3: Team Adoption","text":"<ul> <li>Update team documentation for label-based workflows</li> <li>Create GitHub saved searches for common queries</li> <li>Configure project boards with label-based automation</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#phase-4-enhanced-labeling","title":"Phase 4: Enhanced Labeling","text":"<ul> <li>Add priority and category labels as needed</li> <li>Implement advanced filtering strategies</li> <li>Automate label lifecycle management</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#consequences","title":"Consequences","text":""},{"location":"adr/020-human-required-label-strategy/#positive","title":"Positive","text":"<ul> <li>Reliability: Workflows never fail due to username issues</li> <li>Simplicity: Cleaner, simpler workflow code</li> <li>Flexibility: Teams can organize work however they prefer</li> <li>Scalability: Works across any size team or organization</li> <li>Maintainability: No hardcoded usernames to maintain</li> <li>Template-Friendly: Works identically across all repository instances</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#negative","title":"Negative","text":"<ul> <li>No Direct Assignment: Individual accountability requires discipline</li> <li>Team Process Change: Teams must adapt to label-based workflows</li> <li>Notification Changes: No automatic assignment notifications</li> <li>Filter Learning: Team members need to learn effective label filtering</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#neutral","title":"Neutral","text":"<ul> <li>Different Workflow: Change in process, not necessarily better/worse</li> <li>GitHub Native: Uses GitHub features rather than external solutions</li> <li>Audit Trail: Labels provide visibility into issue classification</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#team-workflow-recommendations","title":"Team Workflow Recommendations","text":""},{"location":"adr/020-human-required-label-strategy/#individual-workflows","title":"Individual Workflows","text":"<pre><code># Daily work queue - check for high priority items\nhttps://github.com/org/repo/issues?q=is:open+label:human-required+label:high-priority\n\n# Weekly triage - review all human-required items  \nhttps://github.com/org/repo/issues?q=is:open+label:human-required\n\n# Conflict resolution focus\nhttps://github.com/org/repo/issues?q=is:open+label:conflict+label:human-required\n</code></pre>"},{"location":"adr/020-human-required-label-strategy/#project-board-setup","title":"Project Board Setup","text":"<ul> <li>Column: \"Needs Attention\" \u2192 <code>label:human-required</code></li> <li>Column: \"High Priority\" \u2192 <code>label:high-priority</code></li> <li>Column: \"Conflicts\" \u2192 <code>label:conflict</code></li> <li>Column: \"In Progress\" \u2192 Remove <code>human-required</code> when started</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#notification-setup","title":"Notification Setup","text":"<pre><code># Team notification rules\n- Watch repository for issues with specific labels\n- Slack/Teams integration based on label filters\n- Email notifications for high-priority items\n</code></pre>"},{"location":"adr/020-human-required-label-strategy/#integration-with-existing-systems","title":"Integration with Existing Systems","text":""},{"location":"adr/020-human-required-label-strategy/#label-management-adr-008","title":"Label Management (ADR-008)","text":"<ul> <li>Leverages centralized label definitions</li> <li>New labels added to <code>.github/labels.json</code> during initialization</li> <li>Consistent across all repository instances</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#workflow-patterns","title":"Workflow Patterns","text":"<ul> <li>Sync workflow: Uses <code>upstream-sync,human-required</code> for manual cascade triggering with duplicate prevention</li> <li>Cascade workflow: Uses lifecycle labels (<code>cascade-active</code>, <code>cascade-blocked</code>, <code>production-ready</code>)</li> <li>Monitor workflow: Uses <code>human-required</code> for trigger failures</li> <li>Template sync: Uses <code>template-sync,human-required</code> for template updates</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#external-integrations","title":"External Integrations","text":"<ul> <li>Project Boards: Automatic card movement based on labels</li> <li>Slack/Teams: Filter notifications by label combinations</li> <li>GitHub Apps: Query issues by label patterns</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#monitoring-and-success-metrics","title":"Monitoring and Success Metrics","text":""},{"location":"adr/020-human-required-label-strategy/#key-metrics","title":"Key Metrics","text":"<ul> <li>Issue Resolution Time: Time to close <code>human-required</code> issues</li> <li>Label Distribution: Frequency of different label combinations</li> <li>Team Engagement: Number of team members working on labeled issues</li> <li>Escalation Rate: <code>human-required</code> items that become <code>high-priority</code></li> </ul>"},{"location":"adr/020-human-required-label-strategy/#success-indicators","title":"Success Indicators","text":"<ul> <li>Zero workflow failures due to assignment issues</li> <li>Consistent issue resolution times</li> <li>Team adoption of label-based filtering</li> <li>Reduced manual workflow maintenance</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#failure-detection","title":"Failure Detection","text":"<ul> <li>Issues with <code>human-required</code> label open &gt; 7 days</li> <li>High accumulation of <code>high-priority</code> items</li> <li>Team members not engaging with labeled items</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#future-enhancements","title":"Future Enhancements","text":""},{"location":"adr/020-human-required-label-strategy/#planned-improvements","title":"Planned Improvements","text":"<ol> <li>Smart Labeling: Automatic priority assignment based on issue content</li> <li>SLA Automation: Automatic escalation when items exceed time thresholds</li> <li>Load Balancing: Round-robin assignment simulation via label metadata</li> <li>Advanced Filtering: Saved searches for common workflow patterns</li> </ol>"},{"location":"adr/020-human-required-label-strategy/#integration-opportunities","title":"Integration Opportunities","text":"<ul> <li>GitHub Projects: Enhanced automation based on label patterns</li> <li>External Tools: Integration with ticketing systems via labels</li> <li>Analytics: Dashboards showing team workflow efficiency</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-008: Centralized Label Management Strategy - Defines how labels are managed</li> <li>ADR-019: Cascade Monitor Pattern - Uses human-required labels for trigger failures</li> <li>ADR-022: Issue Lifecycle Tracking Pattern - Defines lifecycle label usage</li> <li>Sync Workflow Updates - Implements label-based task management</li> <li>Cascade Workflow Updates - Uses labels for conflict management</li> </ul>"},{"location":"adr/020-human-required-label-strategy/#success-criteria","title":"Success Criteria","text":"<ul> <li>100% workflow reliability (no assignment-related failures)</li> <li>Team adopts label-based filtering within 2 weeks</li> <li>Average resolution time for <code>human-required</code> issues \u2264 48 hours</li> <li>Zero maintenance overhead for user assignment management</li> <li>Template repository works identically across all instances</li> <li>Clear audit trail for all automated task creation</li> </ul> <p>\u2190 ADR-019 |  Catalog | ADR-021 \u2192</p>"},{"location":"adr/021-pull-request-target-trigger-pattern/","title":"ADR-021: Pull Request Target Trigger Pattern","text":""},{"location":"adr/021-pull-request-target-trigger-pattern/#status","title":"Status","text":"<p>Accepted - 2025-10-01</p>"},{"location":"adr/021-pull-request-target-trigger-pattern/#context","title":"Context","text":"<p>The cascade-monitor workflow needs to trigger when pull requests are merged into the <code>fork_upstream</code> branch to automatically start the cascade integration process. However, the original implementation using the <code>pull_request</code> event has a critical limitation:</p> <ol> <li>Missing YAML Problem: The <code>pull_request</code> event requires the workflow file to exist on the target branch (<code>fork_upstream</code>), but our workflow files only exist on the <code>main</code> branch</li> <li>PAT Token Dependency: Current workaround uses <code>gh workflow run</code> with a PAT token to trigger cascade, adding complexity</li> <li>Multiple Failure Points: The indirect triggering approach can fail at multiple points</li> <li>Maintenance Overhead: Two separate workflows (monitor + cascade) increase complexity</li> </ol> <p>The community feedback highlighted that <code>pull_request_target</code> is the canonical solution for this exact scenario.</p>"},{"location":"adr/021-pull-request-target-trigger-pattern/#decision","title":"Decision","text":"<p>Replace the <code>pull_request</code> event with <code>pull_request_target</code> in the cascade-monitor workflow:</p> <pre><code>on:\n  pull_request_target:\n    types: [closed]\n    branches: [fork_upstream]\n</code></pre> <p>This single change solves the missing YAML problem because <code>pull_request_target</code> always reads the workflow definition from the default branch (<code>main</code>) while still providing access to the pull request event payload.</p>"},{"location":"adr/021-pull-request-target-trigger-pattern/#rationale","title":"Rationale","text":""},{"location":"adr/021-pull-request-target-trigger-pattern/#why-pull_request_target-is-superior","title":"Why pull_request_target is Superior","text":"<ol> <li>Workflow Location: Always reads from <code>main</code> branch, eliminating the missing YAML issue</li> <li>Same Security Model: Runs with base repository permissions, identical to current PAT approach</li> <li>Atomic Operation: Direct event handling without intermediate steps</li> <li>Simpler Architecture: No need for complex workarounds or auxiliary issues</li> <li>GitHub's Intended Solution: This is exactly what <code>pull_request_target</code> was designed for</li> </ol>"},{"location":"adr/021-pull-request-target-trigger-pattern/#comparison-with-alternatives","title":"Comparison with Alternatives","text":"Approach Pros Cons pull_request_target \u2022 Reads from main\u2022 Direct trigger\u2022 Simple \u2022 Elevated permissions (same as PAT) Copy YAML to fork_upstream \u2022 Standard trigger \u2022 Duplicate files\u2022 Maintenance burden workflow_run \u2022 Works from main \u2022 Fires before merge\u2022 Complex logic Issue-close pattern \u2022 Works from main \u2022 Extra complexity\u2022 Manual cleanup repository_dispatch \u2022 Explicit control \u2022 Requires PAT\u2022 More moving parts"},{"location":"adr/021-pull-request-target-trigger-pattern/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/021-pull-request-target-trigger-pattern/#minimal-changes-required","title":"Minimal Changes Required","text":"<p>Only two lines need to change in cascade-monitor.yml:</p> <ol> <li> <p>Change the event trigger:    <pre><code># Before\npull_request:\n\n# After\npull_request_target:\n</code></pre></p> </li> <li> <p>Update the job condition:    <pre><code># Before\ngithub.event_name == 'pull_request'\n\n# After\ngithub.event_name == 'pull_request_target'\n</code></pre></p> </li> </ol>"},{"location":"adr/021-pull-request-target-trigger-pattern/#security-considerations","title":"Security Considerations","text":"<p><code>pull_request_target</code> runs with write permissions to the base repository, but this is identical to our current approach using PAT tokens. The workflow already includes appropriate safeguards:</p> <ul> <li>Only triggers on closed PRs</li> <li>Checks for merged status</li> <li>Validates specific labels</li> <li>Limited to fork_upstream branch</li> </ul>"},{"location":"adr/021-pull-request-target-trigger-pattern/#consequences","title":"Consequences","text":""},{"location":"adr/021-pull-request-target-trigger-pattern/#positive","title":"Positive","text":"<ul> <li>Reliability: Eliminates the missing YAML problem completely</li> <li>Simplicity: Removes complex workarounds and reduces failure points</li> <li>Maintainability: Single clear trigger mechanism</li> <li>Performance: Direct event handling without intermediate steps</li> <li>Compatibility: Works with existing sync-template distribution</li> </ul>"},{"location":"adr/021-pull-request-target-trigger-pattern/#negative","title":"Negative","text":"<ul> <li>Learning Curve: Team needs to understand <code>pull_request_target</code> vs <code>pull_request</code></li> <li>Security Awareness: Must be careful with untrusted PR content (already handled)</li> </ul>"},{"location":"adr/021-pull-request-target-trigger-pattern/#neutral","title":"Neutral","text":"<ul> <li>Same Security Model: No change from current PAT-based approach</li> <li>Workflow Count: Still using cascade-monitor + cascade separation</li> <li>Distribution: Sync-template handles propagation automatically</li> </ul>"},{"location":"adr/021-pull-request-target-trigger-pattern/#migration-strategy","title":"Migration Strategy","text":"<ol> <li>Update cascade-monitor.yml: Change to <code>pull_request_target</code> (completed)</li> <li>Test in Template Repository: Verify trigger works correctly</li> <li>Document Change: Update workflow documentation</li> <li>Automatic Distribution: Let sync-template propagate to all forks</li> <li>Monitor Rollout: Watch for successful cascade triggers</li> </ol>"},{"location":"adr/021-pull-request-target-trigger-pattern/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-019: Cascade Monitor Pattern - Original monitor pattern</li> <li>ADR-001: Three-Branch Fork Management Strategy - Branch structure</li> <li>ADR-020: Human-Required Label Strategy - Label-based triggers</li> </ul>"},{"location":"adr/021-pull-request-target-trigger-pattern/#success-criteria","title":"Success Criteria","text":"<ul> <li>Cascade triggers fire 100% reliably when sync PRs merge</li> <li>No missing YAML errors in workflow logs</li> <li>Existing functionality preserved (health checks, error handling)</li> <li>Smooth rollout via sync-template to all repositories</li> <li>Clear audit trail in workflow logs</li> </ul>"},{"location":"adr/021-pull-request-target-trigger-pattern/#references","title":"References","text":"<ul> <li>GitHub Docs: pull_request_target</li> <li>GitHub Security: pull_request_target</li> <li>Community feedback on fork management patterns</li> </ul> <p>\u2190 ADR-020 |  Catalog | ADR-022 \u2192</p>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/","title":"ADR-022: Issue Lifecycle Tracking Pattern","text":""},{"location":"adr/022-issue-lifecycle-tracking-pattern/#status","title":"Status","text":"<p>Accepted - 2025-10-01</p>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#context","title":"Context","text":"<p>The fork management template's three-branch cascade strategy (ADR-001) and human-centric cascade pattern (ADR-019) require comprehensive visibility into the state and progress of upstream integration workflows. Teams need to understand:</p> <ol> <li>Current State: Where is a particular upstream changeset in the integration pipeline?</li> <li>Progress Tracking: What stage of the cascade process is currently executing?</li> <li>Error Visibility: When conflicts or failures occur, how are they communicated?</li> <li>Human Actions Required: When do humans need to intervene and what actions should they take?</li> <li>Audit Trail: Complete history of how upstream changes flowed through the system</li> </ol> <p>Challenges Without Issue Tracking:</p> <ul> <li>Poor Visibility: No central place to see cascade status</li> <li>Lost Context: Hard to understand what changes are being integrated</li> <li>Error Isolation: Failures buried in workflow logs</li> <li>Action Ambiguity: Unclear when human intervention is needed</li> <li>Audit Gaps: Difficult to trace upstream changeset history</li> </ul> <p>Requirements for Issue Lifecycle System:</p> <ul> <li>Single Source of Truth: One issue tracks entire cascade lifecycle</li> <li>Real-time Updates: Issue reflects current cascade state</li> <li>Clear Actions: Obvious next steps for humans</li> <li>Error Tracking: Conflicts and failures prominently displayed</li> <li>Label-based State: Machine-readable state management via GitHub labels</li> <li>Comment-based Progress: Human-readable progress updates</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#decision","title":"Decision","text":"<p>Implement Issue Lifecycle Tracking Pattern that creates and maintains GitHub issues throughout the cascade process:</p>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#1-issue-creation-syncyml-creates-tracking-issue-with-duplicate-prevention","title":"1. Issue Creation: sync.yml creates tracking issue with duplicate prevention","text":"<pre><code># When upstream sync detects changes (prevents duplicates)\ngh issue create \\\n  --title \"\ud83d\udce5 Upstream Sync Ready for Review - $(date +%Y-%m-%d)\" \\\n  --body \"Sync Details: PR #X, N commits, manual cascade required\" \\\n  --label \"upstream-sync,human-required\"\n</code></pre>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#2-state-transitions-cascadeyml-updates-issue-labels-and-comments","title":"2. State Transitions: cascade.yml updates issue labels and comments","text":"<pre><code># Human-required \u2192 cascade-active\ngh issue edit \"$ISSUE_NUMBER\" \\\n  --remove-label \"human-required\" \\\n  --add-label \"cascade-active\"\n\n# cascade-active \u2192 cascade-blocked (on conflicts)\ngh issue edit \"$ISSUE_NUMBER\" \\\n  --remove-label \"cascade-active\" \\\n  --add-label \"cascade-blocked\"\n\n# cascade-active \u2192 production-ready (success)\ngh issue edit \"$ISSUE_NUMBER\" \\\n  --remove-label \"cascade-active\" \\\n  --add-label \"production-ready\"\n</code></pre>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#3-progress-comments-detailed-updates-at-each-stage","title":"3. Progress Comments: Detailed updates at each stage","text":"<pre><code>gh issue comment \"$ISSUE_NUMBER\" --body \"\ud83d\ude80 **Cascade Integration Started**\nIntegration workflow has been triggered and is now processing upstream changes.\n**Status:** Merging \\`fork_upstream\\` \u2192 \\`fork_integration\\` \u2192 \\`main\\`\"\n</code></pre>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#4-safety-net-integration-monitor-comments-on-auto-triggers","title":"4. Safety Net Integration: Monitor comments on auto-triggers","text":"<pre><code>gh issue comment \"$ISSUE_NUMBER\" --body \"\ud83e\udd16 **Auto-Cascade Initiated**\nSafety net detected missed manual trigger and automatically initiated cascade.\"\n</code></pre>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#issue-state-machine","title":"Issue State Machine","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; created: sync.yml detects changes\n    created --&gt; human_required: Issue created with upstream-sync label\n    human_required --&gt; cascade_active: Human triggers cascade\n    human_required --&gt; cascade_active: Monitor auto-triggers (safety net)\n    cascade_active --&gt; cascade_blocked: Conflicts detected\n    cascade_active --&gt; cascade_failed: Integration failed\n    cascade_active --&gt; validated: Integration successful\n    cascade_blocked --&gt; cascade_active: Conflicts resolved\n    cascade_failed --&gt; cascade_active: Human resolves + monitor retries\n    validated --&gt; [*]: Production PR merged, issue closed</code></pre>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#label-strategy","title":"Label Strategy","text":"Label Meaning Human Action Next State <code>upstream-sync, human-required</code> Upstream sync complete, awaiting manual cascade trigger Review sync PR, merge, trigger cascade <code>cascade-active</code> <code>upstream-sync, cascade-active</code> Cascade integration in progress Monitor progress, wait for completion <code>validated</code>, <code>cascade-blocked</code>, or <code>cascade-failed</code> <code>upstream-sync, cascade-blocked</code> Conflicts detected, manual resolution needed Resolve conflicts, commit fixes <code>cascade-active</code> <code>upstream-sync, cascade-failed, human-required</code> Integration failed, human intervention required Review failure issue, fix problems, remove <code>human-required</code> label <code>cascade-active</code> (automatic retry) <code>upstream-sync, validated</code> Production PR created, ready for final review Review and merge production PR Issue closed"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/022-issue-lifecycle-tracking-pattern/#cascade-workflow-integration","title":"Cascade Workflow Integration","text":"<p>The cascade workflow accepts an <code>issue_number</code> input parameter that directly links to the tracking issue:</p> <pre><code># In cascade.yml workflow dispatch inputs\nissue_number:\n  description: 'GitHub issue number for the upstream sync (e.g., 123)'\n  required: true\n  type: 'string'\n</code></pre> <p>This eliminates the need for complex issue searching logic and ensures precise tracking throughout the cascade process.</p>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#issue-creation-pattern","title":"Issue Creation Pattern","text":"<pre><code># In sync.yml after PR creation\nNOTIFICATION_BODY=\"## \ud83d\udce5 Upstream Sync Ready for Review\n\nNew upstream changes are available and ready for review.\n\n**Sync Details:**\n\n- **PR:** $PR_URL  \n- **Upstream Version:** $UPSTREAM_VERSION\n- **Commits:** $COMMIT_COUNT new commits from upstream\n- **Branch:** \\`$SYNC_BRANCH\\` \u2192 \\`fork_upstream\\`\n\n**Next Steps:**\n\n1. \ud83d\udd0d **Review the sync PR** for any breaking changes or conflicts\n2. \u2705 **Merge the PR** when satisfied with the changes  \n3. \ud83d\ude80 **Manually trigger 'Cascade Integration' workflow** to integrate changes\n4. \ud83d\udcca **Monitor cascade progress** in Actions tab\n\n**Timeline:**\n\n- Sync detected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n- Action required: Human review, merge, and cascade trigger\"\n\ngh issue create \\\n  --title \"\ud83d\udce5 Upstream Sync Ready for Review - $(date +%Y-%m-%d)\" \\\n  --body \"$NOTIFICATION_BODY\" \\\n  --label \"upstream-sync,human-required\"\n</code></pre>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#issue-update-pattern","title":"Issue Update Pattern","text":"<pre><code># In cascade.yml - Use provided issue number directly\nISSUE_NUMBER=\"${{ github.event.inputs.issue_number }}\"\n\nif [ -n \"$ISSUE_NUMBER\" ]; then\n  # Update labels\n  gh issue edit \"$ISSUE_NUMBER\" \\\n    --remove-label \"human-required\" \\\n    --add-label \"cascade-active\"\n\n  # Add progress comment\n  gh issue comment \"$ISSUE_NUMBER\" --body \"\ud83d\ude80 **Cascade Integration Started** - $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\n  Integration workflow has been triggered and is now processing upstream changes.\n\n  **Status:** Merging \\`fork_upstream\\` \u2192 \\`fork_integration\\` \u2192 \\`main\\`\n  **Workflow:** [View Progress](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\"\nfi\n</code></pre>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#conflict-handling-pattern","title":"Conflict Handling Pattern","text":"<pre><code># When conflicts detected in cascade.yml - use provided issue number\nTRACKING_ISSUE=\"${{ github.event.inputs.issue_number }}\"\nif [ -n \"$TRACKING_ISSUE\" ]; then\n  gh issue edit \"$TRACKING_ISSUE\" \\\n    --remove-label \"cascade-active\" \\\n    --add-label \"cascade-blocked\"\n\n  gh issue comment \"$TRACKING_ISSUE\" --body \"\ud83d\udea8 **Conflicts Detected** - $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\n  Merge conflicts were detected during integration. A separate conflict resolution issue has been created.\n\n  **Status:** Cascade blocked - manual conflict resolution required\n  **SLA:** 48 hours for resolution\"\nfi\n</code></pre>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#production-ready-pattern","title":"Production Ready Pattern","text":"<pre><code># When production PR created in cascade.yml - use provided issue number\nTRACKING_ISSUE=\"${{ github.event.inputs.issue_number }}\"\nif [ -n \"$TRACKING_ISSUE\" ]; then\n  gh issue edit \"$TRACKING_ISSUE\" \\\n    --remove-label \"cascade-active\" \\\n    --add-label \"production-ready\"\n\n  gh issue comment \"$TRACKING_ISSUE\" --body \"\ud83c\udfaf **Production PR Created** - $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\n  Integration completed successfully! Production PR has been created and is ready for final review.\n\n  **Production PR:** $PR_URL\n  **Auto-merge:** $([ \"$BREAKING_CHANGES\" == \"false\" ] &amp;&amp; echo \"\u2705 Enabled\" || echo \"\u274c Manual review required\")\n\n  **Final Steps:**\n  1. Review and merge the production PR\n  2. This issue will be closed when changes reach main\"\nfi\n</code></pre>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#rationale","title":"Rationale","text":""},{"location":"adr/022-issue-lifecycle-tracking-pattern/#single-source-of-truth","title":"Single Source of Truth","text":"<ul> <li>Centralized Tracking: One GitHub issue per upstream changeset provides single place to check status</li> <li>Cross-Reference: Issue links to all related PRs, workflow runs, and conflict issues</li> <li>Searchable History: GitHub issue search provides easy access to historical cascade information</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#real-time-state-management","title":"Real-time State Management","text":"<ul> <li>Label-based State: Machine-readable state via GitHub labels enables automation</li> <li>Comment-based Progress: Human-readable updates provide detailed context</li> <li>Workflow Integration: Cascade workflows automatically update issue state</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#human-centric-design","title":"Human-Centric Design","text":"<ul> <li>Clear Next Actions: Each state clearly indicates what humans should do next</li> <li>Progress Visibility: Teams can see cascade progress without checking workflow logs</li> <li>Error Prominence: Conflicts and failures are prominently displayed in issue</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#audit-trail-benefits","title":"Audit Trail Benefits","text":"<ul> <li>Complete History: Issue comments provide complete record of cascade progression</li> <li>Decision Points: Clear record of when humans intervened and why</li> <li>Timing Information: Timestamps show how long each stage took</li> <li>Troubleshooting: Historical issues help debug similar problems</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/022-issue-lifecycle-tracking-pattern/#1-workflow-only-tracking","title":"1. Workflow-only Tracking","text":"<ul> <li>Pros: No additional GitHub resources needed</li> <li>Cons: Poor visibility, hard to track across multiple workflow runs</li> <li>Decision: Rejected due to poor user experience</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#2-multiple-issues-per-stage","title":"2. Multiple Issues per Stage","text":"<ul> <li>Pros: Very detailed tracking, clear separation of concerns</li> <li>Cons: Issue proliferation, hard to follow overall story</li> <li>Decision: Rejected due to complexity</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#3-external-tracking-system","title":"3. External Tracking System","text":"<ul> <li>Pros: More powerful tracking capabilities</li> <li>Cons: Additional infrastructure, not integrated with GitHub</li> <li>Decision: Rejected due to complexity and integration concerns</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#4-pr-based-tracking-only","title":"4. PR-based Tracking Only","text":"<ul> <li>Pros: Uses existing PR infrastructure</li> <li>Cons: Sync PR gets closed, losing tracking capability for integration</li> <li>Decision: Rejected because sync PR lifecycle doesn't match cascade lifecycle</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#5-project-board-tracking","title":"5. Project Board Tracking","text":"<ul> <li>Pros: Kanban-style visualization</li> <li>Cons: Requires manual movement, less automated than label-based approach</li> <li>Decision: Rejected in favor of automated label management</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#consequences","title":"Consequences","text":""},{"location":"adr/022-issue-lifecycle-tracking-pattern/#positive","title":"Positive","text":"<ul> <li>Excellent Visibility: Teams can see cascade status at a glance</li> <li>Clear Action Items: Obvious next steps for humans at each stage</li> <li>Complete Audit Trail: Full history of how upstream changes flowed through system</li> <li>Error Prominence: Conflicts and failures are highly visible</li> <li>Search Capability: Easy to find information about specific upstream changes</li> <li>Integration: Works seamlessly with existing GitHub workflows and tooling</li> <li>Automation Friendly: Labels enable automated tooling and reporting</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#negative","title":"Negative","text":"<ul> <li>Additional GitHub Resources: Creates more issues in repository</li> <li>Maintenance Complexity: Workflow changes require issue tracking updates</li> <li>Potential for Stale Issues: Issues might not be closed if workflows fail</li> <li>Label Management: Need to maintain consistent label strategy across workflows</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#mitigation-strategies","title":"Mitigation Strategies","text":"<ul> <li>Issue Templates: Standardized issue creation reduces variation</li> <li>Cleanup Jobs: Monitor workflows can detect and close stale issues</li> <li>Label Standardization: Centralized label strategy (ADR-020) ensures consistency</li> <li>Documentation: Clear guidance on issue lifecycle for team members</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#integration-points","title":"Integration Points","text":""},{"location":"adr/022-issue-lifecycle-tracking-pattern/#with-human-centric-cascade-pattern-adr-019","title":"With Human-Centric Cascade Pattern (ADR-019","text":"<ul> <li>Manual Trigger Integration: Issues provide clear instructions for manual cascade triggering</li> <li>Safety Net Coordination: Monitor workflow updates issues when auto-triggering cascades</li> <li>Error Handling: Both manual and automatic error scenarios tracked through issues</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#with-label-management-strategy-adr-020","title":"With Label Management Strategy (ADR-020)","text":"<ul> <li>Consistent Labels: Uses predefined label strategy for state management</li> <li>Label Combinations: Defines specific label combinations for cascade states</li> <li>Automated Label Management: Workflows automatically apply and remove labels</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#with-conflict-management-strategy-adr-005","title":"With Conflict Management Strategy (ADR-005)","text":"<ul> <li>Conflict Visibility: Issues prominently display conflict status</li> <li>Resolution Tracking: Clear indication when conflicts are resolved</li> <li>SLA Management: 48-hour conflict resolution SLA tracked through issue updates</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#success-criteria","title":"Success Criteria","text":"<ul> <li>100% Issue Creation: Every upstream sync creates tracking issue (no duplicates due to duplicate prevention system)</li> <li>95% State Accuracy: Issue labels accurately reflect cascade state</li> <li>&lt; 2 hour Update Lag: Issue updates within 2 hours of state changes</li> <li>90% Human Adoption: Teams actively use issues for cascade tracking</li> <li>Zero Stale Issues: All issues closed within 30 days of creation</li> <li>Complete Audit Trail: 100% of cascade decisions documented in issue comments</li> <li>Error Visibility: 100% of conflicts and failures visible in issue tracking</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#monitoring-and-alerting","title":"Monitoring and Alerting","text":""},{"location":"adr/022-issue-lifecycle-tracking-pattern/#health-metrics","title":"Health Metrics","text":"<ul> <li>Issue Lifecycle Completeness: % of cascades with complete issue tracking</li> <li>State Transition Accuracy: % of correct label transitions</li> <li>Human Response Time: Time from issue creation to human action</li> <li>Issue Resolution Time: Time from creation to closure</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#failure-detection","title":"Failure Detection","text":"<ul> <li>Stale Issue Detection: Issues in same state for &gt; 48 hours</li> <li>Missing State Transitions: Cascades without corresponding issue updates</li> <li>Label Inconsistency: Issues with invalid label combinations</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#future-enhancements","title":"Future Enhancements","text":""},{"location":"adr/022-issue-lifecycle-tracking-pattern/#potential-improvements","title":"Potential Improvements","text":"<ol> <li>Automated Issue Closure: Close issues automatically when production PRs merge</li> <li>Cross-Repository Tracking: Track cascades across multiple related repositories</li> <li>Metrics Dashboard: Visualization of cascade performance metrics</li> <li>Smart Notifications: Targeted notifications based on issue state and team preferences</li> <li>Template Customization: Allow teams to customize issue templates for their needs</li> </ol>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#integration-opportunities","title":"Integration Opportunities","text":"<ul> <li>Slack Integration: Post issue updates to team Slack channels</li> <li>Email Notifications: Automated email updates for critical state changes</li> <li>Metrics Integration: Feed issue data into organizational metrics systems</li> <li>AI Enhancement: Use AI to generate better issue descriptions and status updates</li> </ul>"},{"location":"adr/022-issue-lifecycle-tracking-pattern/#related-adrs","title":"Related ADRs","text":"<ul> <li>ADR-001: Three-Branch Fork Management Strategy - Defines cascade process being tracked</li> <li>ADR-019: Cascade Monitor Pattern - Human-centric cascade approach that this supports</li> <li>ADR-020: Human-Required Label Strategy - Label management strategy used for state tracking</li> <li>ADR-005: Automated Conflict Management Strategy - Conflict handling that this tracks</li> </ul> <p>\u2190 ADR-021 |  Catalog | ADR-023 \u2192</p>"},{"location":"adr/023-meta-commit-strategy-for-release-please/","title":"ADR-023: Meta Commit Strategy for Release Please Integration","text":""},{"location":"adr/023-meta-commit-strategy-for-release-please/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#context","title":"Context","text":"<p>Fork management requires synchronizing upstream commits that don't follow conventional commit format with Release Please automation that requires conventional commits for versioning decisions. This creates a fundamental conflict between preserving upstream commit history and maintaining automated release management.</p>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#problem-analysis","title":"Problem Analysis","text":"<ul> <li>Upstream Reality: OSDU and other upstream repositories use varied commit message formats</li> <li>Release Please Requirement: Needs conventional commits (<code>feat:</code>, <code>fix:</code>, etc.) for semantic versioning</li> <li>History Preservation: Enterprise debugging requires complete commit attribution and traceability</li> <li>Validation Conflict: Conventional commit validation fails on non-conventional upstream commits</li> </ul>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#solutions-considered","title":"Solutions Considered","text":"<ol> <li>Squash Merge: Combine all upstream changes into single conventional commit</li> <li>Commit Message Transformation: Rewrite upstream commit messages to conventional format</li> <li>Meta Commit Strategy: Preserve upstream commits + add conventional meta commit for Release Please</li> <li>Manual Release Management: Bypass automation for upstream changes</li> </ol>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#decision","title":"Decision","text":"<p>Implement Meta Commit Strategy using AIPR 1.4.0's commit range analysis capability.</p>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#implementation-approach","title":"Implementation Approach","text":"<ol> <li>Preserve Upstream History: Merge upstream commits with <code>--no-edit</code> to maintain original attribution</li> <li>Generate Meta Commit: Use AI to analyze upstream changes and create conventional commit</li> <li>Release Please Integration: Meta commit drives versioning decisions while history remains intact</li> <li>Robust Fallback: Default to <code>feat:</code> if AI analysis fails</li> </ol>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#technical-implementation","title":"Technical Implementation","text":"<pre><code># Capture state before sync\nBEFORE_SHA=$(git rev-parse fork_upstream)\n\n# Complete merge preserving upstream history\ngit merge upstream/$DEFAULT_BRANCH -X theirs --no-edit\n\n# Generate conventional meta commit with AI analysis\nMETA_COMMIT_MSG=$(aipr commit --from $BEFORE_SHA --context \"upstream sync\")\n\n# Add meta commit for Release Please\ngit commit --allow-empty -m \"$META_COMMIT_MSG\"\n</code></pre>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#rationale","title":"Rationale","text":""},{"location":"adr/023-meta-commit-strategy-for-release-please/#why-meta-commit-strategy-is-optimal","title":"Why Meta Commit Strategy is Optimal","text":"<p>Enterprise Requirements Met:</p> <ul> <li>\u2705 Complete OSDU commit history preserved for debugging</li> <li>\u2705 Full git blame/bisect capability maintained  </li> <li>\u2705 Regulatory audit trail compliance</li> <li>\u2705 Individual commit attribution intact</li> </ul> <p>Automation Requirements Met:</p> <ul> <li>\u2705 Release Please works seamlessly with meta commits</li> <li>\u2705 Accurate conventional commit categorization via AI</li> <li>\u2705 Automated semantic versioning continues</li> <li>\u2705 Changelog generation remains functional</li> </ul> <p>Technical Advantages:</p> <ul> <li>\u2705 Simple 4-step implementation</li> <li>\u2705 No complex git history rewriting</li> <li>\u2705 Robust error handling with fallbacks</li> <li>\u2705 Uses AIPR exactly as designed</li> </ul>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#why-not-other-solutions","title":"Why Not Other Solutions","text":"<p>Squash Merge Rejected:</p> <ul> <li>\u274c Loses granular OSDU history critical for debugging</li> <li>\u274c Makes cherry-picking and selective reverts impossible</li> <li>\u274c Breaks enterprise traceability requirements</li> </ul> <p>Commit Transformation Rejected:</p> <ul> <li>\u274c Complex implementation with high failure risk</li> <li>\u274c May break git signatures and upstream attribution</li> <li>\u274c Difficult to maintain reliability across edge cases</li> </ul> <p>Manual Release Rejected:</p> <ul> <li>\u274c Loses automation benefits</li> <li>\u274c Introduces human error potential</li> <li>\u274c Doesn't scale with frequent upstream syncs</li> </ul>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/023-meta-commit-strategy-for-release-please/#ai-integration","title":"AI Integration","text":"<ul> <li>Tool: AIPR 1.4.0+ with <code>--from &lt;SHA&gt;</code> capability</li> <li>Analysis Scope: Changes between last sync point and current HEAD</li> <li>Context: \"upstream sync\" helps AI categorize appropriately</li> <li>Timeout: 60 seconds to prevent workflow hanging</li> </ul>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#error-handling-strategy","title":"Error Handling Strategy","text":"<pre><code># Comprehensive fallback chain\nif timeout 60s aipr commit --from $BEFORE_SHA --context \"upstream sync\"; then\n  # Use AI-generated conventional commit\nelse\n  # Fallback to conservative feat: message\n  META_COMMIT_MSG=\"feat: sync upstream changes from $UPSTREAM_VERSION\"\nfi\n</code></pre>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#validation-requirements","title":"Validation Requirements","text":"<ul> <li>Conventional commit format: <code>type: description</code> with non-empty description</li> <li>Supported types: <code>feat|fix|chore|docs|style|refactor|perf|test|build|ci</code></li> <li>Minimum description length validation</li> <li>Graceful handling of AI service outages</li> </ul>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#consequences","title":"Consequences","text":""},{"location":"adr/023-meta-commit-strategy-for-release-please/#positive","title":"Positive","text":"<ul> <li>Reliable Automation: Release Please integration works consistently</li> <li>Preserved History: Complete upstream commit attribution maintained</li> <li>Enterprise Compliance: Audit trail requirements satisfied</li> <li>AI Enhancement: Intelligent categorization when services available</li> <li>Fallback Reliability: Workflow never fails due to AI issues</li> </ul>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#negative","title":"Negative","text":"<ul> <li>Mixed Commit History: Developers see conventional + non-conventional commits</li> <li>Additional Complexity: Meta commit logic adds workflow steps</li> <li>AI Dependency: Optimal categorization requires external AI services</li> </ul>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#neutral","title":"Neutral","text":"<ul> <li>Release Please Behavior: Functions exactly as designed for mixed commit repositories</li> <li>Git History Size: Minimal increase due to empty meta commits</li> <li>Performance Impact: Negligible overhead from additional commit</li> </ul>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#monitoring-and-success-criteria","title":"Monitoring and Success Criteria","text":""},{"location":"adr/023-meta-commit-strategy-for-release-please/#success-metrics","title":"Success Metrics","text":"<ul> <li>Release Please correctly versions based on meta commits</li> <li>No workflow failures due to conventional commit validation</li> <li>AI analysis success rate &gt; 80% (with graceful fallback)</li> <li>Complete upstream history preservation verified</li> </ul>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#monitoring-points","title":"Monitoring Points","text":"<ul> <li>AIPR success/failure rates in workflow logs</li> <li>Release Please version bumping accuracy</li> <li>Meta commit format compliance</li> <li>Upstream sync completion times</li> </ul>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#future-evolution","title":"Future Evolution","text":""},{"location":"adr/023-meta-commit-strategy-for-release-please/#potential-enhancements","title":"Potential Enhancements","text":"<ul> <li>Enhanced AI context with upstream repository analysis</li> <li>Custom conventional commit type mappings for specific file patterns</li> <li>Integration with upstream release notes for better categorization</li> <li>Advanced conflict resolution strategies for complex merges</li> </ul>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#migration-strategy","title":"Migration Strategy","text":"<ul> <li>Current implementation is additive (no breaking changes)</li> <li>Can be disabled by reverting to simple merge if needed</li> <li>Compatible with existing Release Please configurations</li> <li>No impact on existing fork instances</li> </ul>"},{"location":"adr/023-meta-commit-strategy-for-release-please/#references","title":"References","text":"<ul> <li>AIPR 1.4.0 Documentation</li> <li>Release Please Documentation</li> <li>Conventional Commits Specification</li> <li>ADR-001: Three-Branch Strategy</li> <li>ADR-011: Configuration-Driven Template Sync</li> </ul> <p>\u2190 ADR-022 |  Catalog | ADR-024 \u2192</p>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/","title":"ADR-024: Sync Workflow Duplicate Prevention Architecture","text":""},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#context","title":"Context","text":"<p>The daily upstream sync workflow in the Fork Management Template creates duplicate PRs and issues when humans delay reviewing PRs, causing notification fatigue and repository clutter. This problem manifests in multiple scenarios:</p> <ol> <li>Same upstream state triggers multiple syncs - Human delays reviewing PR, next day's sync creates identical duplicate PR/issue</li> <li>Upstream advances while previous sync PR is open - Creates new PR with 4 commits while old PR with 3 commits still exists  </li> <li>Failed syncs leave abandoned branches - Stale sync branches accumulate from failed workflow runs</li> </ol>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#problem-statement","title":"Problem Statement","text":"<p>The existing sync workflow lacks state management between runs, resulting in:</p> <ul> <li>Duplicate PRs/issues for identical upstream states</li> <li>Notification fatigue from redundant GitHub notifications</li> <li>Repository clutter from abandoned sync branches</li> <li>Broken workflow continuity when humans track multiple sync artifacts</li> <li>Confusion about which PR is current when upstream advances</li> </ul>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#decision","title":"Decision","text":"<p>We implement a comprehensive duplicate prevention system for sync workflows with these components:</p>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#1-overall-strategy","title":"1. Overall Strategy","text":"<ul> <li>State-based duplicate detection using git config persistence</li> <li>Smart decision matrix for handling all duplicate scenarios</li> <li>Graceful degradation to existing behavior when detection fails</li> <li>Clean separation of concerns via dedicated GitHub Action</li> </ul>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#2-state-persistence-pattern","title":"2. State Persistence Pattern","text":"<p>Options Considered:</p> <ul> <li>GitHub variables (rejected - limited and requires additional tokens)</li> <li>Git notes (rejected - complexity and merge conflicts)</li> <li>External storage (rejected - dependency and complexity)</li> <li>Git config (chosen) - simple, reliable, scoped to repository</li> </ul> <p>Implementation:</p> <ul> <li>Track upstream SHA, PR/issue numbers, timestamps</li> <li>Persist state between workflow runs</li> <li>Automatic cleanup when PRs/issues are closed</li> </ul>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#3-branch-management-strategy","title":"3. Branch Management Strategy","text":"<p>Options Considered:</p> <ul> <li>Close old PRs and create new ones (rejected - breaks human workflow continuity)</li> <li>Leave both PRs open (rejected - confusing and cluttered)</li> <li>Update existing sync branches (chosen) - maintains continuity</li> </ul> <p>Implementation:</p> <ul> <li>Force-push to existing branches when upstream advances</li> <li>Update PR metadata and titles</li> <li>Maintain same PR/issue URLs for human tracking</li> </ul>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#4-implementation-pattern","title":"4. Implementation Pattern","text":"<p>Options Considered:</p> <ul> <li>Inline implementation in sync.yml (rejected - poor maintainability)</li> <li>Dedicated action (chosen) - better separation of concerns</li> </ul> <p>Implementation:</p> <ul> <li><code>sync-state-manager</code> action following GitHub best practices</li> <li>Reusable by other workflows</li> <li>Comprehensive error handling and logging</li> </ul>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#architecture-components","title":"Architecture Components","text":""},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#sync-state-manager-action","title":"sync-state-manager Action","text":"<p>Purpose: Encapsulate duplicate detection and state management logic Location: <code>.github/actions/sync-state-manager/action.yml</code></p> <p>Key Functions:</p> <ul> <li>Detect existing open sync PRs using <code>upstream-sync</code> label</li> <li>Compare current upstream SHA with stored last-synced SHA</li> <li>Clean up abandoned sync branches (&gt;24h old, no associated PR)</li> <li>Make intelligent decisions based on current state</li> </ul> <p>Decision Matrix:</p> <pre><code>| Existing PR | Upstream Changed | Action                    |\n|-------------|------------------|---------------------------|\n| No          | Yes              | Create new PR and issue   |\n| Yes         | No               | Add reminder comment      |\n| Yes         | Yes              | Update existing branch    |\n| No          | No               | No action needed          |\n</code></pre>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#state-management","title":"State Management","text":"<p>Storage: Git config variables scoped to repository</p> <ul> <li><code>sync.last-upstream-sha</code>: Last successfully processed upstream SHA</li> <li><code>sync.current-pr-number</code>: Active sync PR number (if any)</li> <li><code>sync.current-issue-number</code>: Active tracking issue number (if any)</li> <li><code>sync.last-sync-timestamp</code>: Timestamp of last sync attempt</li> </ul> <p>Persistence: Automatic across workflow runs</p> <p>Cleanup: Automatic when PRs/issues are closed or merged</p>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#integration-points","title":"Integration Points","text":"<p>Pre-Sync Validation Step: Uses sync-state-manager action after \"Configure Git\"</p> <p>Conditional Sync Step: Modified to handle branch updates vs new creation</p> <p>Smart PR Management: Skip/update/create based on action outputs</p> <p>Intelligent Issue Management: Skip/comment/create based on action outputs</p>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#implementation-benefits","title":"Implementation Benefits","text":""},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#technical-benefits","title":"Technical Benefits","text":"<ul> <li>Eliminates duplicate PRs/issues across all scenarios</li> <li>Maintains clean repository state with automatic cleanup</li> <li>Preserves human workflow continuity with consistent URLs</li> <li>Better maintainability with action pattern separation</li> <li>Reusable by other workflows for similar state management needs</li> </ul>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#user-experience-benefits","title":"User Experience Benefits","text":"<ul> <li>Single tracking issue throughout entire sync cycle</li> <li>No duplicate notifications reducing noise</li> <li>Always current upstream state in active PR</li> <li>Clear progression history in issue comments</li> <li>Reduced cognitive load - same URLs to track</li> </ul>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#files-modifiedcreated","title":"Files Modified/Created","text":"<ol> <li><code>.github/actions/sync-state-manager/action.yml</code> - New action for state management</li> <li><code>.github/template-workflows/sync.yml</code> - Modified sync workflow using new action</li> <li><code>doc/src/adr/024-sync-workflow-duplicate-prevention-architecture.md</code> - This ADR</li> </ol>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#key-changes","title":"Key Changes","text":"<ul> <li>Pre-sync validation step checks for existing sync PRs/issues</li> <li>Upstream SHA comparison tracks last synced state</li> <li>Branch update logic updates existing branches instead of creating new ones</li> <li>State persistence stores sync state between runs via git config</li> <li>Cleanup logic removes abandoned sync branches</li> </ul>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#error-handling","title":"Error Handling","text":"<ul> <li>GitHub API Failures: Graceful degradation to create new PR/issue</li> <li>State Corruption: Automatic state reset and fallback to normal workflow</li> <li>Branch Access Issues: Skip branch cleanup if git operations fail</li> <li>Backwards Compatibility: No changes to existing sync behavior if detection disabled</li> </ul>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#consequences","title":"Consequences","text":""},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#positive","title":"Positive","text":"<ul> <li>\u2705 Eliminates duplicate PRs/issues - Core problem solved</li> <li>\u2705 Maintains clean repository state - Automatic cleanup</li> <li>\u2705 Preserves human workflow continuity - Same URLs to track</li> <li>\u2705 Better maintainability - Action pattern follows best practices</li> <li>\u2705 Reusable by other workflows - State management available elsewhere</li> <li>\u2705 Graceful degradation - Fallback to existing behavior on failure</li> </ul>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#negative","title":"Negative","text":"<ul> <li>\u26a0\ufe0f Requires state persistence between runs - Added complexity</li> <li>\u26a0\ufe0f Added complexity in sync workflow - More decision logic</li> <li>\u26a0\ufe0f Potential edge cases in decision logic - Requires thorough testing</li> </ul>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#neutral","title":"Neutral","text":"<ul> <li>\ud83d\udcdd No breaking changes - Existing forks continue working</li> <li>\ud83d\udcdd Automatic distribution - sync-config.json handles deployment</li> <li>\ud83d\udcdd No external dependencies - Uses existing GitHub tokens and permissions</li> </ul>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#testing-strategy","title":"Testing Strategy","text":"<p>Testing will be conducted through real-world scenarios by monitoring the behavior of daily sync workflows in production environments. The duplicate prevention logic will be validated by observing:</p> <ul> <li>Proper detection of duplicate sync scenarios</li> <li>Correct branch update behavior when upstream advances</li> <li>State persistence across multiple sync runs</li> <li>Cleanup of abandoned sync branches</li> <li>Action reliability and graceful degradation</li> </ul>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#rollout-plan","title":"Rollout Plan","text":"<ol> <li>Implementation Phase: Create action and update workflow in single PR</li> <li>Deployment Phase: Automatic sync-template workflow distributes changes</li> <li>Monitoring Phase: Validate duplicate prevention in production forks</li> <li>Success Assessment: Confirm reduction in duplicate PRs/issues</li> </ol>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#success-metrics","title":"Success Metrics","text":"<ul> <li>Reduction in duplicate PRs/issues - Primary success indicator</li> <li>Human workflow continuity maintained - Same URLs tracked throughout</li> <li>State persistence reliability - Consistent state across sync runs</li> <li>Cleanup effectiveness - Abandoned branches automatically removed</li> <li>User satisfaction - Reduced notification fatigue and confusion</li> </ul>"},{"location":"adr/024-sync-workflow-duplicate-prevention-architecture/#references","title":"References","text":"<ul> <li>Issue #121: Fix: Prevent duplicate sync PRs and issues</li> <li>ADR-001: Three-Branch Strategy</li> <li>ADR-020: Human-Required Labels</li> <li>ADR-023: Meta Commit Strategy</li> </ul> <p>\u2190 ADR-023 |  Catalog | ADR-025 \u2192</p>"},{"location":"adr/025-java-maven-build-architecture/","title":"ADR-025: Java/Maven Build Architecture","text":""},{"location":"adr/025-java-maven-build-architecture/#status","title":"Status","text":"<p>Accepted - 2025-10-01</p>"},{"location":"adr/025-java-maven-build-architecture/#context","title":"Context","text":"<p>The OSDU (Open Subsurface Data Universe) ecosystem is predominantly built using Java with Maven as the build system. Fork repositories created from this template need consistent, reliable build automation that:</p> <ul> <li>Supports Maven-based Java projects with standard OSDU dependencies</li> <li>Integrates with GitLab-hosted OSDU community Maven repositories</li> <li>Provides comprehensive test coverage reporting using JaCoCo</li> <li>Caches dependencies efficiently to reduce build times</li> <li>Works seamlessly with the three-branch fork management strategy</li> </ul> <p>The template needed to make an architectural decision about which build systems to support and how to implement that support consistently across all fork repositories.</p>"},{"location":"adr/025-java-maven-build-architecture/#decision","title":"Decision","text":"<p>Implement Java/Maven as the primary build architecture with:</p> <ol> <li>Java 17 Temurin as the standard runtime</li> <li>Maven 3.9+ as the build tool</li> <li>JaCoCo for code coverage reporting</li> <li>GitLab Maven repository integration for OSDU dependencies</li> <li>Reusable GitHub Actions for consistent build implementation</li> </ol>"},{"location":"adr/025-java-maven-build-architecture/#rationale","title":"Rationale","text":""},{"location":"adr/025-java-maven-build-architecture/#why-javamaven-focus","title":"Why Java/Maven Focus","text":"<ol> <li>OSDU Ecosystem Alignment: All core OSDU services are Java/Maven projects</li> <li>Enterprise Standard: Java remains the enterprise standard for large-scale systems</li> <li>Mature Tooling: Maven provides comprehensive dependency management and build lifecycle</li> <li>Coverage Integration: JaCoCo integrates seamlessly with Maven for coverage reporting</li> <li>Community Consistency: Aligns with OSDU community build practices</li> </ol>"},{"location":"adr/025-java-maven-build-architecture/#build-architecture-benefits","title":"Build Architecture Benefits","text":"<ol> <li>Dependency Caching: Maven <code>.m2/repository</code> caching speeds up builds by 50-70%</li> <li>Community Repository Access: Automatic authentication with GitLab OSDU repositories</li> <li>Standardized Structure: Consistent <code>pom.xml</code> patterns across all services</li> <li>Test Integration: Native support for JUnit, TestNG, and other test frameworks</li> <li>Security Scanning: Integration with dependency vulnerability scanning tools</li> </ol>"},{"location":"adr/025-java-maven-build-architecture/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/025-java-maven-build-architecture/#1-multi-language-support-java-python-nodejs","title":"1. Multi-Language Support (Java, Python, Node.js)","text":"<ul> <li>Pros: Broader applicability, flexibility for different project types</li> <li>Cons: Complexity, maintenance overhead, diluted focus</li> <li>Decision: Rejected - OSDU is Java-centric, focus provides better experience</li> </ul>"},{"location":"adr/025-java-maven-build-architecture/#2-gradle-build-system","title":"2. Gradle Build System","text":"<ul> <li>Pros: More flexible, better performance, Kotlin DSL</li> <li>Cons: OSDU uses Maven, would require conversion effort</li> <li>Decision: Rejected - Incompatible with OSDU ecosystem standards</li> </ul>"},{"location":"adr/025-java-maven-build-architecture/#3-bazel-build-system","title":"3. Bazel Build System","text":"<ul> <li>Pros: Excellent for monorepos, reproducible builds</li> <li>Cons: Steep learning curve, not used in OSDU</li> <li>Decision: Rejected - Too different from OSDU practices</li> </ul>"},{"location":"adr/025-java-maven-build-architecture/#4-no-build-system-opinion","title":"4. No Build System Opinion","text":"<ul> <li>Pros: Maximum flexibility for teams</li> <li>Cons: No automation, inconsistent practices, manual setup</li> <li>Decision: Rejected - Defeats purpose of template automation</li> </ul>"},{"location":"adr/025-java-maven-build-architecture/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/025-java-maven-build-architecture/#reusable-actions-structure","title":"Reusable Actions Structure","text":"<pre><code>.github/actions/\n\u251c\u2500\u2500 java-build/           # Core build logic\n\u251c\u2500\u2500 java-build-status/    # Status reporting with coverage\n\u2514\u2500\u2500 pr-status/           # PR status updates\n</code></pre>"},{"location":"adr/025-java-maven-build-architecture/#build-workflow-configuration","title":"Build Workflow Configuration","text":"<pre><code># build.yml\n- uses: ./.github/actions/java-build\n  with:\n    java-version: '17'\n    java-distribution: 'temurin'\n    maven-args: 'clean install'\n    community-maven-token: ${{ secrets.COMMUNITY_MAVEN_TOKEN }}\n</code></pre>"},{"location":"adr/025-java-maven-build-architecture/#coverage-configuration","title":"Coverage Configuration","text":"<pre><code>&lt;!-- Required in pom.xml --&gt;\n&lt;plugin&gt;\n  &lt;groupId&gt;org.jacoco&lt;/groupId&gt;\n  &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;\n  &lt;version&gt;0.8.11&lt;/version&gt;\n&lt;/plugin&gt;\n</code></pre>"},{"location":"adr/025-java-maven-build-architecture/#community-repository-access","title":"Community Repository Access","text":"<pre><code># Automatic GitLab OSDU repository configuration\nsettings.xml generated with:\n- Repository: https://community.opengroup.org/api/v4/projects/\n- Authentication: Bearer token from COMMUNITY_MAVEN_TOKEN\n</code></pre>"},{"location":"adr/025-java-maven-build-architecture/#consequences","title":"Consequences","text":""},{"location":"adr/025-java-maven-build-architecture/#positive","title":"Positive","text":"<ul> <li>Zero Configuration: Java projects work immediately after fork creation</li> <li>Fast Builds: Dependency caching reduces build times significantly</li> <li>OSDU Compatible: Seamless integration with OSDU ecosystem</li> <li>Coverage Reports: Automatic test coverage tracking and reporting</li> <li>Security Integration: Dependency vulnerability scanning included</li> <li>Consistent Experience: Same build behavior across all forks</li> </ul>"},{"location":"adr/025-java-maven-build-architecture/#negative","title":"Negative","text":"<ul> <li>Java-Only Focus: Non-Java projects require custom workflow modifications</li> <li>Maven Lock-in: Projects using Gradle need conversion or custom workflows</li> <li>Version Constraints: Locked to Java 17 (though configurable)</li> <li>GitLab Dependency: Requires GitLab community repository access</li> </ul>"},{"location":"adr/025-java-maven-build-architecture/#neutral","title":"Neutral","text":"<ul> <li>Opinionated Defaults: Prescriptive approach may not suit all teams</li> <li>OSDU Alignment: Tightly coupled to OSDU ecosystem practices</li> <li>Action Maintenance: Reusable actions require ongoing updates</li> </ul>"},{"location":"adr/025-java-maven-build-architecture/#success-criteria","title":"Success Criteria","text":"<ul> <li>Maven builds complete successfully in &lt; 10 minutes for typical projects</li> <li>JaCoCo coverage reports generated and accessible as artifacts</li> <li>GitLab OSDU dependencies resolve without authentication errors</li> <li>Build caching reduces subsequent build times by &gt; 50%</li> <li>Zero configuration required for standard OSDU Java projects</li> <li>Coverage thresholds enforced (80% line, 75% branch coverage)</li> </ul>"},{"location":"adr/025-java-maven-build-architecture/#migration-path","title":"Migration Path","text":"<p>For existing repositories adopting this architecture:</p> <ol> <li>Ensure Java 17 compatibility in source code</li> <li>Add JaCoCo plugin to pom.xml if not present</li> <li>Configure COMMUNITY_MAVEN_TOKEN secret for GitLab access</li> <li>Update workflow files via template-sync mechanism</li> <li>Verify build passes with new architecture</li> </ol>"},{"location":"adr/025-java-maven-build-architecture/#future-evolution","title":"Future Evolution","text":""},{"location":"adr/025-java-maven-build-architecture/#potential-enhancements","title":"Potential Enhancements","text":"<ol> <li>Multi-module Support: Better support for Maven multi-module projects</li> <li>Parallel Builds: Implement parallel test execution for faster builds</li> <li>Container Builds: Add Docker/OCI image building to workflow</li> <li>SBOM Generation: Software Bill of Materials for supply chain security</li> <li>Performance Profiling: Build performance metrics and optimization</li> </ol>"},{"location":"adr/025-java-maven-build-architecture/#extensibility-points","title":"Extensibility Points","text":"<ul> <li>Custom Maven settings via repository variables</li> <li>Override Java version through workflow inputs</li> <li>Additional Maven repositories via configuration</li> <li>Custom test frameworks through Maven profiles</li> </ul>"},{"location":"adr/025-java-maven-build-architecture/#related-adrs","title":"Related ADRs","text":"<ul> <li>ADR-002: GitHub Actions-Based Automation Architecture - Foundation for build automation</li> <li>ADR-013: Reusable GitHub Actions Pattern - Reusable build actions</li> <li>ADR-003: Template Repository Pattern - Template distribution of build configuration</li> </ul>"},{"location":"adr/025-java-maven-build-architecture/#references","title":"References","text":"<ul> <li>OSDU Platform Documentation</li> <li>Maven Documentation</li> <li>JaCoCo Documentation</li> <li>GitHub Actions Java Setup</li> </ul> <p>\u2190 ADR-024 |  Catalog | ADR-026 \u2192</p>"},{"location":"adr/026-dependabot-security-update-strategy/","title":"ADR-026: Dependabot Security Update Strategy","text":""},{"location":"adr/026-dependabot-security-update-strategy/#status","title":"Status","text":"<p>Accepted - 2025-10-01 Updated - 2025-10-24 (Separation of Concerns Architecture) Updated - 2025-10-28 (Removed pip/doc from template to prevent fork caching issues) Updated - 2025-12-19 (Changed Maven schedule from weekly to daily for faster rebasing)</p>"},{"location":"adr/026-dependabot-security-update-strategy/#context","title":"Context","text":"<p>Fork repositories managing OSDU services face unique challenges with dependency management:</p> <ol> <li>Security Vulnerabilities: Dependencies need timely security updates to prevent exploits</li> <li>Upstream Compatibility: Updates must not break compatibility with upstream OSDU</li> <li>Validation Requirements: All dependency updates need thorough testing before merge</li> <li>Update Frequency: Balance between security responsiveness and stability</li> <li>Fork-Specific Dependencies: Local enhancements may have additional dependencies</li> <li>Engineering System Updates: Workflows and actions maintained separately from application code</li> </ol> <p>GitHub's Dependabot provides automated dependency updates, but the fork management template needed a strategy that: - Ensures security updates are applied promptly - Maintains compatibility with the three-branch strategy - Provides appropriate validation for different update types - Handles both upstream and fork-specific dependencies - Separates platform concerns (workflows) from application concerns (code dependencies) - Eliminates race conditions during fork initialization</p>"},{"location":"adr/026-dependabot-security-update-strategy/#decision","title":"Decision","text":"<p>Implement a Separation of Concerns Dependabot Strategy with:</p> <ol> <li>Template Owns Engineering System: Template repository monitors <code>.github</code> (workflows, actions) and <code>doc</code> (documentation)</li> <li>Forks Own Application Code: Fork repositories monitor Maven dependencies ONLY</li> <li>Template Sync Propagates Platform Updates: Engineering system updates flow via <code>sync-template</code> workflow</li> <li>Grouped Updates: Related dependencies updated together to reduce PR noise</li> <li>Conservative Update Policy: Patch and minor updates only, major versions require manual review</li> <li>No Duplicate PRs: Forks never scan <code>.github</code>, eliminating race conditions and duplicate updates</li> </ol>"},{"location":"adr/026-dependabot-security-update-strategy/#rationale","title":"Rationale","text":""},{"location":"adr/026-dependabot-security-update-strategy/#security-first-approach","title":"Security-First Approach","text":"<ol> <li>Vulnerability Mitigation: Security updates applied within 48 hours of disclosure</li> <li>Automated Detection: GitHub Security Advisory database integration</li> <li>Priority Handling: Security PRs labeled and prioritized appropriately</li> <li>Compliance Requirements: Meet enterprise security update SLAs</li> </ol>"},{"location":"adr/026-dependabot-security-update-strategy/#controlled-update-strategy","title":"Controlled Update Strategy","text":"<ol> <li>Stability Focus: Conservative update policy prevents breaking changes</li> <li>Validation Gates: All updates must pass build, test, and integration checks</li> <li>Grouped Updates: Reduces PR proliferation and review overhead</li> <li>Manual Major Versions: Breaking changes require human review and testing</li> </ol>"},{"location":"adr/026-dependabot-security-update-strategy/#auto-rebase-strategy","title":"Auto-Rebase Strategy","text":"<p>Dependabot automatically rebases open PRs when: 1. The scheduled daily check runs at 09:00 UTC 2. Conflicts are detected with the target branch 3. A closed PR is reopened</p> <p>Why Daily Schedule: A weekly schedule meant PRs could become stale for up to 7 days before rebasing. With multiple developers merging changes to <code>pom.xml</code>, Dependabot PRs often had outdated dependency versions. The daily schedule ensures PRs are rebased within 24 hours of any conflicting merge to main.</p> <p>Manual Rebase: Use <code>@dependabot rebase</code> comment on any PR to trigger immediate rebase.</p>"},{"location":"adr/026-dependabot-security-update-strategy/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/026-dependabot-security-update-strategy/#1-disable-dependabot-entirely","title":"1. Disable Dependabot Entirely","text":"<ul> <li>Pros: No automated PRs, full manual control</li> <li>Cons: Miss critical security updates, increased security risk</li> <li>Decision: Rejected - Security risk too high</li> </ul>"},{"location":"adr/026-dependabot-security-update-strategy/#2-aggressive-update-strategy","title":"2. Aggressive Update Strategy","text":"<ul> <li>Pros: Always latest versions, newest features</li> <li>Cons: Frequent breaks, incompatibility with upstream OSDU</li> <li>Decision: Rejected - Stability more important than latest features</li> </ul>"},{"location":"adr/026-dependabot-security-update-strategy/#3-security-only-updates","title":"3. Security-Only Updates","text":"<ul> <li>Pros: Minimal changes, only critical updates</li> <li>Cons: Miss important bug fixes, technical debt accumulation</li> <li>Decision: Rejected - Need balance between security and maintenance</li> </ul>"},{"location":"adr/026-dependabot-security-update-strategy/#4-manual-security-monitoring","title":"4. Manual Security Monitoring","text":"<ul> <li>Pros: Human judgment for each update</li> <li>Cons: Slow response time, human error, doesn't scale</li> <li>Decision: Rejected - Automation essential for timely updates</li> </ul>"},{"location":"adr/026-dependabot-security-update-strategy/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/026-dependabot-security-update-strategy/#dependabot-configuration","title":"Dependabot Configuration","text":"<p>Template Repository (<code>.github/dependabot.yml</code>): <pre><code>version: 2\nupdates:\n  # Engineering System - Template Responsibility\n  - package-ecosystem: \"github-actions\"\n    directory: \"/.github\"  # Monitors ALL .github subdirectories recursively\n    schedule:\n      interval: \"daily\"\n      time: \"08:00\"\n    groups:\n      github-actions:\n        patterns:\n          - \"*\"\n        update-types:\n          - \"minor\"\n          - \"patch\"\n\n  # Note: pip/doc ecosystem REMOVED as of 2025-10-28\n  # Reason: Forks inherit this config momentarily before deploy-fork-resources.sh runs,\n  # causing Dependabot to cache the pip/doc ecosystem even after it's replaced with\n  # Maven-only config. Since /doc is removed during fork initialization, Dependabot\n  # fails trying to scan a non-existent directory.\n</code></pre></p> <p>Fork Repositories (<code>.github/fork-resources/dependabot.yml</code> \u2192 <code>.github/dependabot.yml</code>): <pre><code>version: 2\nupdates:\n  # NO GitHub Actions monitoring - Receives via sync-template!\n\n  # Maven Dependencies - Application Code Only\n  - package-ecosystem: \"maven\"\n    directory: \"/\"\n    schedule:\n      interval: \"daily\"\n      time: \"09:00\"\n    groups:\n      spring:\n        patterns:\n          - \"org.springframework*\"\n        update-types:\n          - \"patch\"\n    # Additional Maven configs for /&lt;service&gt;-core and /provider/&lt;service&gt;-azure\n</code></pre></p>"},{"location":"adr/026-dependabot-security-update-strategy/#validation-workflow","title":"Validation Workflow","text":"<pre><code># dependabot-validation.yml\nname: Dependabot Validation\non:\n  pull_request:\n    types: [opened, synchronize, reopened]\n\njobs:\n  validate:\n    if: github.actor == 'dependabot[bot]'\n    steps:\n      - Auto-approve security updates\n      - Run comprehensive test suite\n      - Check for breaking changes\n      - Validate against upstream OSDU\n</code></pre>"},{"location":"adr/026-dependabot-security-update-strategy/#update-flow-architecture","title":"Update Flow Architecture","text":"<pre><code>Template Repository (azure/osdu-spi):\n  Day 1 08:00 \u2192 Dependabot scans /.github\n             \u2192 Finds actions/checkout@v4 \u2192 v5\n             \u2192 Creates PR in template\n  Day 1 10:00 \u2192 Platform team merges PR\n  Day 2 08:00 \u2192 sync-template workflow runs\n             \u2192 Creates PRs in all forks with updated workflows\n\nFork Repositories (danielscholl-osdu/*):\n  Day 2 08:00 \u2192 Receive sync-template PR with workflow updates\n             \u2192 Review and merge (engineering system updates)\n  Daily 09:00 \u2192 Dependabot scans Maven dependencies\n             \u2192 Creates PRs for Spring Boot, Jackson, etc.\n             \u2192 Rebases open PRs when conflicts detected\n             \u2192 NO GitHub Actions scanning (eliminates duplicates)\n</code></pre>"},{"location":"adr/026-dependabot-security-update-strategy/#update-groups","title":"Update Groups","text":"Repository Ecosystem Update Frequency Managed By Template GitHub Actions Daily Template Dependabot Template Python/pip Daily Template Dependabot Forks Maven (root) Daily Fork Dependabot Forks Maven (core) Daily Fork Dependabot Forks Maven (provider) Daily Fork Dependabot Forks GitHub Actions N/A Template sync-template"},{"location":"adr/026-dependabot-security-update-strategy/#label-strategy","title":"Label Strategy","text":"<ul> <li><code>dependencies</code> - All Dependabot PRs</li> <li><code>security</code> - Security-related updates</li> <li><code>auto-merge</code> - Safe to merge automatically</li> <li><code>needs-review</code> - Requires human review</li> <li><code>breaking-change</code> - Potentially breaking update</li> </ul>"},{"location":"adr/026-dependabot-security-update-strategy/#consequences","title":"Consequences","text":""},{"location":"adr/026-dependabot-security-update-strategy/#positive","title":"Positive","text":"<ul> <li>Improved Security Posture: Vulnerabilities patched within 48 hours via template</li> <li>Eliminated Race Conditions: Forks don't scan <code>.github</code>, no timing issues during init</li> <li>No Duplicate PRs: Single source of truth for engineering system updates</li> <li>Clear Separation of Concerns: Template owns platform, forks own application code</li> <li>Reduced Manual Work: Automated dependency updates save developer time</li> <li>Scalable Architecture: 1 template update \u2192 N fork updates automatically</li> <li>Consistent Validation: All updates go through same validation process</li> <li>Audit Trail: Complete history of dependency updates in GitHub</li> <li>OSDU Compatibility: Conservative approach maintains upstream compatibility</li> </ul>"},{"location":"adr/026-dependabot-security-update-strategy/#negative","title":"Negative","text":"<ul> <li>PR Noise: Regular automated PRs require attention</li> <li>Validation Overhead: All updates require CI/CD resources</li> <li>Potential Conflicts: Updates may conflict with local modifications</li> <li>Template Dependency: Forks rely on template for workflow/action updates</li> </ul>"},{"location":"adr/026-dependabot-security-update-strategy/#neutral","title":"Neutral","text":"<ul> <li>GitHub Dependency: Relies on GitHub's Dependabot service</li> <li>Update Lag: Conservative strategy means not always latest versions</li> <li>Unified Daily Schedule: Both engineering system and application code update daily</li> </ul>"},{"location":"adr/026-dependabot-security-update-strategy/#success-criteria","title":"Success Criteria","text":"<ul> <li>Security vulnerabilities patched within 48 hours of disclosure</li> <li>&lt; 10 open Dependabot PRs at any time</li> <li>95% of security updates auto-merge successfully</li> <li>Zero breaking changes from automated updates</li> <li>Build success rate &gt; 90% for Dependabot PRs</li> <li>Clear audit trail of all dependency updates</li> </ul>"},{"location":"adr/026-dependabot-security-update-strategy/#monitoring-and-metrics","title":"Monitoring and Metrics","text":""},{"location":"adr/026-dependabot-security-update-strategy/#key-metrics","title":"Key Metrics","text":"<ul> <li>Time to Patch: Hours from CVE disclosure to PR merge</li> <li>PR Success Rate: Percentage of Dependabot PRs that pass validation</li> <li>Auto-merge Rate: Percentage of PRs merged automatically</li> <li>Breaking Change Rate: Frequency of updates causing failures</li> </ul>"},{"location":"adr/026-dependabot-security-update-strategy/#alerts","title":"Alerts","text":"<ul> <li>Security updates pending &gt; 48 hours</li> <li>Dependabot PRs failing repeatedly</li> <li>Critical vulnerabilities detected</li> <li>Update limit reached (10 PRs)</li> </ul>"},{"location":"adr/026-dependabot-security-update-strategy/#integration-points","title":"Integration Points","text":""},{"location":"adr/026-dependabot-security-update-strategy/#with-build-system-adr-025","title":"With Build System (ADR-025)","text":"<ul> <li>Dependabot updates trigger Maven builds</li> <li>JaCoCo coverage must remain above thresholds</li> <li>Community repository dependencies validated</li> </ul>"},{"location":"adr/026-dependabot-security-update-strategy/#with-validation-workflow","title":"With Validation Workflow","text":"<ul> <li>Comprehensive testing of dependency updates</li> <li>Integration testing with upstream OSDU</li> <li>Automated approval for safe updates</li> </ul>"},{"location":"adr/026-dependabot-security-update-strategy/#with-release-management-adr-004","title":"With Release Management (ADR-004)","text":"<ul> <li>Dependency updates reflected in release notes</li> <li>Security patches trigger patch releases</li> <li>Changelog includes dependency updates</li> </ul>"},{"location":"adr/026-dependabot-security-update-strategy/#future-evolution","title":"Future Evolution","text":""},{"location":"adr/026-dependabot-security-update-strategy/#potential-enhancements","title":"Potential Enhancements","text":"<ol> <li>Smart Grouping: ML-based dependency grouping for optimal updates</li> <li>Risk Scoring: Automated risk assessment for updates</li> <li>Rollback Automation: Automatic rollback of problematic updates</li> <li>Custom Security Policies: Organization-specific security requirements</li> <li>Cross-Repository Coordination: Synchronized updates across fork family</li> </ol>"},{"location":"adr/026-dependabot-security-update-strategy/#integration-opportunities","title":"Integration Opportunities","text":"<ul> <li>Integration with security scanning tools</li> <li>Custom validation for OSDU-specific dependencies</li> <li>Automated compatibility testing with upstream</li> <li>Security update notifications to Slack/Teams</li> </ul>"},{"location":"adr/026-dependabot-security-update-strategy/#related-adrs","title":"Related ADRs","text":"<ul> <li>ADR-002: GitHub Actions-Based Automation Architecture - Automation foundation</li> <li>ADR-016: Initialization Security Handling - Security considerations</li> <li>ADR-025: Java/Maven Build Architecture - Build system integration</li> </ul>"},{"location":"adr/026-dependabot-security-update-strategy/#references","title":"References","text":"<ul> <li>GitHub Dependabot Documentation</li> <li>GitHub Security Advisories</li> <li>OWASP Dependency Check</li> <li>Maven Dependency Management</li> </ul> <p>\u2190 ADR-025 |  Catalog | ADR-027 \u2192</p>"},{"location":"adr/027-documentation-generation-strategy/","title":"ADR-027: Documentation Generation Strategy with MkDocs","text":""},{"location":"adr/027-documentation-generation-strategy/#status","title":"Status","text":"<p>Accepted - 2025-10-01</p>"},{"location":"adr/027-documentation-generation-strategy/#context","title":"Context","text":"<p>The Fork Management Template requires comprehensive documentation for:</p> <ol> <li>Template Documentation: How to use and maintain the template itself</li> <li>Architectural Decisions: ADRs and their evolution over time</li> <li>Workflow Documentation: Detailed guides for each workflow</li> <li>API Documentation: Reusable actions and their interfaces</li> <li>User Guides: Step-by-step instructions for common tasks</li> </ol> <p>The documentation needed to be: - Automatically published and versioned - Searchable and well-organized - Maintainable alongside code - Accessible via GitHub Pages - Professional in appearance</p>"},{"location":"adr/027-documentation-generation-strategy/#decision","title":"Decision","text":"<p>Implement MkDocs Material as the documentation generation system with:</p> <ol> <li>MkDocs Material Theme: Professional, responsive documentation site</li> <li>GitHub Pages Deployment: Automatic publishing via GitHub Actions</li> <li>Markdown-Based Content: Documentation as code in the repository</li> <li>ADR Integration: Automatic inclusion of all ADRs in documentation</li> <li>Search Functionality: Built-in search across all documentation</li> </ol>"},{"location":"adr/027-documentation-generation-strategy/#rationale","title":"Rationale","text":""},{"location":"adr/027-documentation-generation-strategy/#why-mkdocs-material","title":"Why MkDocs Material","text":"<ol> <li>Developer-Friendly: Markdown-based, lives with code</li> <li>Professional Appearance: Material Design theme is clean and modern</li> <li>Feature-Rich: Search, navigation, syntax highlighting built-in</li> <li>GitHub Integration: Works seamlessly with GitHub Pages</li> <li>Active Community: Well-maintained with regular updates</li> </ol>"},{"location":"adr/027-documentation-generation-strategy/#documentation-as-code-benefits","title":"Documentation as Code Benefits","text":"<ol> <li>Version Control: Documentation versioned with code</li> <li>Pull Request Reviews: Documentation changes reviewed like code</li> <li>Consistency: Single source of truth in repository</li> <li>Automation: Generated and published automatically</li> <li>Searchability: Full-text search across all documentation</li> </ol>"},{"location":"adr/027-documentation-generation-strategy/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/027-documentation-generation-strategy/#1-github-wiki","title":"1. GitHub Wiki","text":"<ul> <li>Pros: Built into GitHub, no setup required</li> <li>Cons: Separate from code, poor version control, limited features</li> <li>Decision: Rejected - Lacks version control and automation</li> </ul>"},{"location":"adr/027-documentation-generation-strategy/#2-docusaurus","title":"2. Docusaurus","text":"<ul> <li>Pros: React-based, highly customizable, versioning support</li> <li>Cons: More complex, requires Node.js build pipeline</li> <li>Decision: Rejected - Unnecessary complexity for current needs</li> </ul>"},{"location":"adr/027-documentation-generation-strategy/#3-sphinx","title":"3. Sphinx","text":"<ul> <li>Pros: Powerful, extensive plugin ecosystem, reStructuredText</li> <li>Cons: Python-specific, steeper learning curve, complex configuration</li> <li>Decision: Rejected - MkDocs simpler for Markdown content</li> </ul>"},{"location":"adr/027-documentation-generation-strategy/#4-jekyll-github-pages-default","title":"4. Jekyll (GitHub Pages default)","text":"<ul> <li>Pros: GitHub native support, Ruby-based, simple</li> <li>Cons: Less features, dated appearance, limited search</li> <li>Decision: Rejected - MkDocs Material provides better UX</li> </ul>"},{"location":"adr/027-documentation-generation-strategy/#5-no-documentation-site","title":"5. No Documentation Site","text":"<ul> <li>Pros: Simplest approach, just README files</li> <li>Cons: Poor discoverability, no search, unprofessional</li> <li>Decision: Rejected - Documentation critical for adoption</li> </ul>"},{"location":"adr/027-documentation-generation-strategy/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/027-documentation-generation-strategy/#directory-structure","title":"Directory Structure","text":"<pre><code>doc/\n\u251c\u2500\u2500 mkdocs.yml                 # MkDocs configuration\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 index.md              # Home page\n\u2502   \u251c\u2500\u2500 architecture/         # Architecture documentation\n\u2502   \u251c\u2500\u2500 workflows/            # Workflow guides\n\u2502   \u251c\u2500\u2500 decisions/            # ADRs\n\u2502   \u251c\u2500\u2500 images/               # Diagrams and screenshots\n\u2502   \u251c\u2500\u2500 stylesheets/          # Custom CSS\n\u2502   \u2514\u2500\u2500 javascripts/          # Custom JavaScript\n\u2514\u2500\u2500 README.md                 # Documentation about documentation\n</code></pre>"},{"location":"adr/027-documentation-generation-strategy/#mkdocs-configuration","title":"MkDocs Configuration","text":"<pre><code># mkdocs.yml\nsite_name: OSDU Fork Management\nsite_url: https://azure.github.io/osdu-spi\ntheme:\n  name: material\n  features:\n    - navigation.instant\n    - navigation.tracking\n    - navigation.sections\n    - search.highlight\n    - content.code.copy\n  palette:\n    primary: indigo\n    accent: indigo\n\nplugins:\n  - search\n  - mermaid2\n\nnav:\n  - Home: index.md\n  - Architecture:\n    - Overview: architecture/overview.md\n    - Three-Branch Strategy: architecture/three_branch_strategy.md\n  - Workflows:\n    - Initialization: workflows/initialization.md\n    - Synchronization: workflows/synchronization.md\n    - Build: workflows/build.md\n  - Decisions:\n    - Index: decisions/index.md\n    - ADRs: decisions/*.md\n</code></pre>"},{"location":"adr/027-documentation-generation-strategy/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<pre><code># .github/workflows/docs.yml\nname: Documentation\non:\n  push:\n    branches: [main]\n    paths:\n      - 'doc/**'\n      - 'mkdocs.yml'\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v5\n      - uses: actions/setup-python@v4\n      - run: pip install mkdocs-material\n      - run: mkdocs gh-deploy --force\n</code></pre>"},{"location":"adr/027-documentation-generation-strategy/#documentation-categories","title":"Documentation Categories","text":"Category Content Update Frequency Architecture System design, patterns On architectural changes Workflows Detailed workflow guides On workflow updates Decisions ADRs On new decisions API Reference Action interfaces On action changes User Guides How-to documentation As needed"},{"location":"adr/027-documentation-generation-strategy/#consequences","title":"Consequences","text":""},{"location":"adr/027-documentation-generation-strategy/#positive","title":"Positive","text":"<ul> <li>Professional Documentation: Clean, searchable documentation site</li> <li>Automatic Publishing: Changes published on merge to main</li> <li>Version Control: Documentation versioned with code</li> <li>Search Capability: Full-text search across all content</li> <li>Mobile Friendly: Responsive design works on all devices</li> <li>Low Maintenance: Minimal ongoing maintenance required</li> </ul>"},{"location":"adr/027-documentation-generation-strategy/#negative","title":"Negative","text":"<ul> <li>Build Dependency: Requires Python and MkDocs for local preview</li> <li>Learning Curve: Team needs to learn MkDocs configuration</li> <li>Build Time: Adds ~2 minutes to CI/CD pipeline</li> <li>Storage: GitHub Pages has 1GB limit (not a practical concern)</li> </ul>"},{"location":"adr/027-documentation-generation-strategy/#neutral","title":"Neutral","text":"<ul> <li>Markdown Only: Limited to Markdown formatting capabilities</li> <li>Theme Lock-in: Customization limited to Material theme options</li> <li>GitHub Pages: Tied to GitHub's hosting service</li> </ul>"},{"location":"adr/027-documentation-generation-strategy/#success-criteria","title":"Success Criteria","text":"<ul> <li>Documentation site builds and deploys successfully on every merge</li> <li>Search returns relevant results across all documentation</li> <li>Page load time &lt; 2 seconds for documentation pages</li> <li>Documentation stays in sync with code changes</li> <li>ADRs automatically included in documentation site</li> <li>Mobile and desktop responsive design works correctly</li> </ul>"},{"location":"adr/027-documentation-generation-strategy/#integration-points","title":"Integration Points","text":""},{"location":"adr/027-documentation-generation-strategy/#with-github-actions-adr-002","title":"With GitHub Actions (ADR-002)","text":"<ul> <li>Automated build and deployment via GitHub Actions</li> <li>Triggered on documentation changes to main branch</li> <li>Uses GitHub Pages for hosting</li> </ul>"},{"location":"adr/027-documentation-generation-strategy/#with-adr-system","title":"With ADR System","text":"<ul> <li>All ADRs automatically included in documentation</li> <li>ADR index page generated from file system</li> <li>Cross-references between ADRs maintained</li> </ul>"},{"location":"adr/027-documentation-generation-strategy/#with-template-distribution","title":"With Template Distribution","text":"<ul> <li>Documentation included in template repository</li> <li>Fork repositories can customize their documentation</li> <li>Template updates include documentation improvements</li> </ul>"},{"location":"adr/027-documentation-generation-strategy/#future-evolution","title":"Future Evolution","text":""},{"location":"adr/027-documentation-generation-strategy/#potential-enhancements","title":"Potential Enhancements","text":"<ol> <li>API Documentation Generation: Auto-generate from code comments</li> <li>Multi-Version Documentation: Support multiple versions</li> <li>Internationalization: Multi-language documentation support</li> <li>Interactive Examples: Embedded code playgrounds</li> <li>Video Tutorials: Embedded video content</li> <li>PDF Export: Generate PDF versions of documentation</li> </ol>"},{"location":"adr/027-documentation-generation-strategy/#integration-opportunities","title":"Integration Opportunities","text":"<ul> <li>Link documentation to GitHub Discussions</li> <li>Integrate with search engines for better SEO</li> <li>Add analytics to understand usage patterns</li> <li>Create documentation feedback system</li> </ul>"},{"location":"adr/027-documentation-generation-strategy/#migration-path","title":"Migration Path","text":"<p>For repositories adopting this documentation strategy:</p> <ol> <li>Copy MkDocs configuration from template</li> <li>Move existing documentation to <code>doc/src/</code> structure</li> <li>Configure GitHub Pages in repository settings</li> <li>Run initial deployment to validate setup</li> <li>Update repository README with documentation link</li> </ol>"},{"location":"adr/027-documentation-generation-strategy/#related-adrs","title":"Related ADRs","text":"<ul> <li>ADR-002: GitHub Actions-Based Automation Architecture - Automation for docs deployment</li> <li>ADR-003: Template Repository Pattern - Documentation distribution</li> <li>ADR-011: Configuration-Driven Template Synchronization - Docs sync strategy</li> </ul>"},{"location":"adr/027-documentation-generation-strategy/#references","title":"References","text":"<ul> <li>MkDocs Documentation</li> <li>MkDocs Material Theme</li> <li>GitHub Pages Documentation</li> <li>Markdown Guide</li> </ul> <p>\u2190 ADR-026 |  Catalog | ADR-028 \u2192</p>"},{"location":"adr/028-workflow-script-extraction-pattern/","title":"ADR-028: Workflow Script Extraction Pattern","text":""},{"location":"adr/028-workflow-script-extraction-pattern/#status","title":"Status","text":"<p>Accepted - 2025-10-01</p>"},{"location":"adr/028-workflow-script-extraction-pattern/#context","title":"Context","text":"<p>The OSDU SPI Fork Management Template workflows contain approximately 3,500 lines of embedded bash scripts across 9 workflow files. While these scripts implement critical functionality, their embedded nature creates several challenges:</p> <p>Problems with Embedded Scripts:</p> <ul> <li>Debugging Difficulty: Cannot test scripts locally without running entire workflow</li> <li>Code Duplication: LLM provider detection duplicated 2x in sync.yml (~130 lines)</li> <li>Maintenance Burden: Changes require editing multiple workflows, understanding YAML context</li> <li>No Unit Testing: Complex bash logic (awk, conditionals, error handling) cannot be unit tested</li> <li>Poor Visibility: Difficult to see what scripts exist and what they do</li> <li>Version Control: Changes to scripts mixed with workflow structural changes in git diffs</li> </ul> <p>Most Complex Workflows:</p> <ul> <li>sync.yml (658 lines): AI-powered upstream sync with LLM provider detection, PR generation, state management</li> <li>cascade.yml (745 lines): Multi-stage integration with validation, conflict resolution, PR creation</li> <li>init-complete.yml (878 lines): Repository initialization with branch protection, security config, resource deployment</li> <li>sync-state-manager/action.yml (271 lines): Complex state management with decision matrix logic</li> </ul> <p>Key Challenges:</p> <ol> <li>How to extract scripts while maintaining sync propagation to fork instances?</li> <li>Where to place scripts so they're automatically synced via template sync (ADR-011, ADR-012)?</li> <li>How to handle GitHub App workflow permission limitations (ADR-015)?</li> <li>How to enable local testing without breaking workflow functionality?</li> <li>Which scripts should be extracted vs. remain inline?</li> </ol>"},{"location":"adr/028-workflow-script-extraction-pattern/#decision","title":"Decision","text":"<p>Implement a Workflow Script Extraction Pattern that extracts embedded bash scripts into separate, testable files organized within <code>.github/actions/</code> subdirectories. This pattern leverages existing sync infrastructure and composite actions to enable local testing, code reuse, and maintainability improvements.</p>"},{"location":"adr/028-workflow-script-extraction-pattern/#1-script-organization-structure","title":"1. Script Organization Structure","text":"<pre><code>.github/\n\u251c\u2500\u2500 actions/                    # Fork-operational actions (synced to forks)\n\u2502   \u251c\u2500\u2500 llm-provider-detect/\n\u2502   \u2502   \u251c\u2500\u2500 action.yml\n\u2502   \u2502   \u251c\u2500\u2500 detect-provider.sh\n\u2502   \u2502   \u2514\u2500\u2500 README.md\n\u2502   \u251c\u2500\u2500 issue-state-manager/\n\u2502   \u2502   \u251c\u2500\u2500 action.yml\n\u2502   \u2502   \u251c\u2500\u2500 update-issue-state.sh\n\u2502   \u2502   \u2514\u2500\u2500 README.md\n\u2502   \u2514\u2500\u2500 sync-state-manager/\n\u2502       \u251c\u2500\u2500 action.yml\n\u2502       \u251c\u2500\u2500 *.sh\n\u2502       \u2514\u2500\u2500 README.md\n\u2514\u2500\u2500 local-actions/              # Template-only actions (NOT synced to forks)\n    \u251c\u2500\u2500 init-helpers/\n    \u2502   \u251c\u2500\u2500 action.yml\n    \u2502   \u251c\u2500\u2500 setup-upstream.sh\n    \u2502   \u251c\u2500\u2500 setup-branch-protection.sh\n    \u2502   \u251c\u2500\u2500 setup-security.sh\n    \u2502   \u251c\u2500\u2500 deploy-fork-resources.sh\n    \u2502   \u2514\u2500\u2500 README.md\n    \u251c\u2500\u2500 push-protection-handler/\n    \u2502   \u251c\u2500\u2500 action.yml\n    \u2502   \u251c\u2500\u2500 detect-and-report.sh\n    \u2502   \u2514\u2500\u2500 README.md\n    \u251c\u2500\u2500 template-protection-check/\n    \u2502   \u251c\u2500\u2500 action.yml\n    \u2502   \u251c\u2500\u2500 check-template.sh\n    \u2502   \u2514\u2500\u2500 README.md\n    \u2514\u2500\u2500 configure-git/\n        \u251c\u2500\u2500 action.yml\n        \u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"adr/028-workflow-script-extraction-pattern/#2-script-placement-rationale","title":"2. Script Placement Rationale","text":"<p>Fork-Operational Actions (<code>.github/actions/</code>):</p> <ul> <li>\u2705 Synced to forks: Defined in sync-config.json lines 7-10 as synced directory</li> <li>\u2705 Used by fork workflows: Actions needed by sync.yml, cascade.yml, validate.yml, etc.</li> <li>\u2705 Template propagation: Updates flow to fork instances via template-sync.yml</li> <li>\u2705 Examples: llm-provider-detect, issue-state-manager, sync-state-manager</li> </ul> <p>Template-Only Actions (<code>.github/local-actions/</code>):</p> <ul> <li>\u2705 NOT synced to forks: Excluded in sync-config.json line 114</li> <li>\u2705 Used by init workflows: Actions only needed by init.yml and init-complete.yml</li> <li>\u2705 Removed after init: Cleaned up per sync-config.json cleanup_rules (line 123-126)</li> <li>\u2705 No fork pollution: Fork instances never receive these actions</li> <li>\u2705 Follows ADR-015 pattern: Similar to <code>.github/template-workflows/</code> separation</li> <li>\u2705 Examples: init-helpers, push-protection-handler, template-protection-check, configure-git</li> </ul> <p>Why Two Directories:</p> <ul> <li>Prevents syncing init-only actions to fork instances</li> <li>Fork instances only receive actions they actually use</li> <li>Follows established ADR-015 pattern for template vs fork separation</li> <li>Makes lifecycle intent explicit (one-time vs ongoing use)</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#3-composite-action-wrapper-pattern","title":"3. Composite Action Wrapper Pattern","text":"<p>Each extracted script group is wrapped in a composite action for workflow integration:</p> <pre><code># .github/actions/llm-provider-detect/action.yml\nname: 'LLM Provider Detection'\ndescription: 'Detect available LLM provider (Azure Foundry \u2192 OpenAI \u2192 Fallback)'\n\noutputs:\n  use_llm:\n    description: 'Whether LLM is available (true/false)'\n    value: ${{ steps.detect.outputs.use_llm }}\n  llm_model:\n    description: 'LLM model identifier (azure/gpt-4o or gpt-4)'\n    value: ${{ steps.detect.outputs.llm_model }}\n\nruns:\n  using: \"composite\"\n  steps:\n    - name: Detect LLM provider\n      id: detect\n      shell: bash\n      run: ${{ github.action_path }}/detect-provider.sh\n      env:\n        AZURE_API_KEY: ${{ env.AZURE_API_KEY }}\n        AZURE_API_BASE: ${{ env.AZURE_API_BASE }}\n        OPENAI_API_KEY: ${{ env.OPENAI_API_KEY }}\n</code></pre>"},{"location":"adr/028-workflow-script-extraction-pattern/#4-workflow-integration-pattern","title":"4. Workflow Integration Pattern","text":"<p>Workflows use actions instead of embedded scripts:</p> <pre><code># Before: Embedded script in sync.yml (lines 266-283)\n- name: Detect LLM provider\n  run: |\n    USE_LLM=false\n    LLM_MODEL=\"\"\n    if [[ -n \"$AZURE_API_KEY\" ]] &amp;&amp; [[ -n \"$AZURE_API_BASE\" ]]; then\n      USE_LLM=true\n      LLM_MODEL=\"azure\"\n    elif [[ -n \"$OPENAI_API_KEY\" ]]; then\n      USE_LLM=true\n      LLM_MODEL=\"gpt-4\"\n    fi\n    echo \"use_llm=$USE_LLM\" &gt;&gt; $GITHUB_OUTPUT\n    echo \"llm_model=$LLM_MODEL\" &gt;&gt; $GITHUB_OUTPUT\n\n# After: Action call\n- name: Detect LLM provider\n  uses: ./.github/actions/llm-provider-detect\n  id: llm\n  env:\n    AZURE_API_KEY: ${{ secrets.AZURE_API_KEY }}\n    AZURE_API_BASE: ${{ secrets.AZURE_API_BASE }}\n    OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}\n\n- name: Generate PR description\n  if: steps.llm.outputs.use_llm == 'true'\n  run: aipr pr -m ${{ steps.llm.outputs.llm_model }} ...\n</code></pre>"},{"location":"adr/028-workflow-script-extraction-pattern/#5-local-testing-pattern","title":"5. Local Testing Pattern","text":"<p>Each action includes README.md with local testing instructions:</p> <pre><code>## Local Testing\n\n# Navigate to action directory\ncd .github/actions/llm-provider-detect\n\n# Set required environment variables\nexport AZURE_API_KEY=\"your_test_key\"\nexport AZURE_API_BASE=\"https://your-instance.openai.azure.com\"\n\n# Run script directly\n./detect-provider.sh\n\n# Expected output:\n# use_llm=true\n# llm_model=azure\n\n# Test fallback scenario\nunset AZURE_API_KEY\nunset AZURE_API_BASE\nunset OPENAI_API_KEY\n./detect-provider.sh\n\n# Expected output:\n# use_llm=false\n# llm_model=\n</code></pre>"},{"location":"adr/028-workflow-script-extraction-pattern/#6-extraction-decision-matrix","title":"6. Extraction Decision Matrix","text":"<p>Use these criteria to determine if a script should be extracted:</p> Criterion Extract Keep Inline Weight Size &gt;200 lines &lt;100 lines High Complexity Decision matrices, state machines, platform compatibility logic Simple conditionals, straightforward commands Critical Reusability Used in 2+ places OR planned reuse Single-use workflow-specific logic High Testability Value Needs local validation (date parsing, complex conditionals) Simple orchestration, obvious behavior High Type Composite action logic (reusable components) Workflow orchestration (end-to-end flows) Medium Duplication Duplicated code exists Unique implementation Critical <p>Decision Rules:</p> <ul> <li>\u2705 Extract if: 2+ criteria favor extraction AND size &gt;200 lines OR critical complexity</li> <li>\u26a0\ufe0f Consider extraction if: Multiple high-weight criteria favor extraction</li> <li>\u274c Keep inline if: Mostly low-weight criteria OR workflow orchestration</li> <li>\ud83d\udeab Exception if: Technical constraint (see exceptions below)</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#7-extraction-exceptions","title":"7. Extraction Exceptions","text":"<p>7.1 sync.yml Scripts - Cannot Extract</p> <p>Constraint: sync.yml runs from <code>fork_upstream</code> branch where <code>.github/actions/</code> don't exist (per ADR-013, ADR-015).</p> <p>Rationale: - Workflow executes on newly synced upstream branch - Actions haven't been merged to fork_upstream yet - Must remain self-contained for execution - Acceptable tradeoff for sync architecture</p> <p>Status: EXCEPTION - Scripts remain inline by necessity</p> <p>7.2 Workflow Orchestration - Should Not Extract</p> <p>Decision: Complex workflow orchestration scripts (cascade.yml, validate.yml) generally remain inline.</p> <p>Rationale:</p> <ul> <li>End-to-end flows: Orchestration logic is workflow-specific</li> <li>Low reuse: Single-use patterns not shared across workflows</li> <li>Readable as-is: Workflow structure provides context</li> <li>Diminishing returns: Extraction effort exceeds maintainability gains</li> </ul> <p>Future opportunity: Can extract if specific logic becomes reusable (e.g., cascade integration state checking)</p>"},{"location":"adr/028-workflow-script-extraction-pattern/#rationale","title":"Rationale","text":""},{"location":"adr/028-workflow-script-extraction-pattern/#benefits-of-script-extraction","title":"Benefits of Script Extraction","text":"<p>Debuggability:</p> <ul> <li>Scripts can be executed locally with <code>bash script.sh</code></li> <li>Test with various inputs without triggering workflows</li> <li>Faster iteration cycle during development</li> <li>Easier to reproduce and debug issues</li> </ul> <p>Maintainability:</p> <ul> <li>Centralized logic in single location</li> <li>Clear ownership and organization</li> <li>Easier to review changes (pure bash vs YAML+bash)</li> <li>Better git diffs (separate script vs workflow changes)</li> </ul> <p>Reusability:</p> <ul> <li>Share logic across multiple workflows</li> <li>Eliminates code duplication (e.g., LLM provider detection)</li> <li>Consistent behavior across workflows</li> <li>DRY principle properly applied</li> </ul> <p>Testability:</p> <ul> <li>Unit test complex bash logic</li> <li>Mock external dependencies (GitHub API)</li> <li>Verify error handling paths</li> <li>Test edge cases systematically</li> </ul> <p>Readability:</p> <ul> <li>Workflows become declarative (\"detect LLM\" vs 20 lines of bash)</li> <li>Intent clearer (action name vs embedded code)</li> <li>Less cognitive load when reading workflows</li> <li>Better onboarding for new contributors</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#sync-propagation-compatibility","title":"Sync Propagation Compatibility","text":"<p>Leverages Existing Infrastructure:</p> <ul> <li><code>.github/actions/</code> already defined in sync-config.json</li> <li>Template sync (ADR-012) automatically propagates actions</li> <li>Daily sync (8 AM UTC) or manual trigger</li> <li>No new sync patterns required</li> </ul> <p>Propagation Flow:</p> <ol> <li>Template commits script changes to main branch</li> <li>Template-sync workflow detects changes in <code>.github/actions/</code></li> <li>Creates PR in fork instances with updated scripts</li> <li>Human reviews and merges</li> <li>Scripts immediately available to workflows</li> </ol>"},{"location":"adr/028-workflow-script-extraction-pattern/#github-app-workflow-permission-consideration","title":"GitHub App Workflow Permission Consideration","text":"<p>Per ADR-015, GitHub Apps cannot create/modify workflow files without workflows permission. This pattern avoids this limitation:</p> <p>Why This Works:</p> <ul> <li>Actions are NOT workflow files (no permission restriction)</li> <li>Actions can be created/modified by GITHUB_TOKEN</li> <li>Workflows reference actions via <code>uses:</code> (no workflow modification)</li> <li>Post-initialization, actions exist and are callable</li> <li>Template sync can update actions and workflows together</li> </ul> <p>Init-Time Consideration:</p> <ul> <li>During init, template-workflows copied BEFORE actions are available</li> <li>Solution: Init scripts remain inline (one-time use)</li> <li>Post-init workflows can use extracted actions</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/028-workflow-script-extraction-pattern/#1-new-githubscripts-directory","title":"1. New <code>.github/scripts/</code> Directory","text":"<p>Pros:</p> <ul> <li>Clearer separation between actions and scripts</li> <li>More intuitive location for shell scripts</li> <li>Could use for non-action scripts</li> </ul> <p>Cons:</p> <ul> <li>Requires modifying sync-config.json</li> <li>Triggers template update to all existing fork instances</li> <li>Introduces new pattern when existing solution works</li> <li>Additional maintenance burden</li> </ul> <p>Decision: Rejected - <code>.github/actions/</code> already synced and works</p>"},{"location":"adr/028-workflow-script-extraction-pattern/#2-external-script-repository","title":"2. External Script Repository","text":"<p>Pros:</p> <ul> <li>Separate versioning for scripts</li> <li>Could be shared across multiple templates</li> <li>Clear dependency management</li> </ul> <p>Cons:</p> <ul> <li>External dependency complicates deployment</li> <li>Version pinning and updates more complex</li> <li>Breaks self-contained template principle</li> <li>Additional repository to maintain</li> </ul> <p>Decision: Rejected - Violates template self-containment</p>"},{"location":"adr/028-workflow-script-extraction-pattern/#3-keep-scripts-embedded","title":"3. Keep Scripts Embedded","text":"<p>Pros:</p> <ul> <li>No structural changes required</li> <li>Scripts stay close to usage</li> <li>No abstraction layer</li> </ul> <p>Cons:</p> <ul> <li>Debugging remains difficult</li> <li>Code duplication continues</li> <li>Maintenance burden grows</li> <li>No local testing capability</li> </ul> <p>Decision: Rejected - Problems outweigh simplicity</p>"},{"location":"adr/028-workflow-script-extraction-pattern/#4-git-submodules-for-scripts","title":"4. Git Submodules for Scripts","text":"<p>Pros:</p> <ul> <li>Version pinning capability</li> <li>Could share scripts across repositories</li> </ul> <p>Cons:</p> <ul> <li>Git submodule complexity for users</li> <li>Breaks template simplicity</li> <li>Sync propagation more complex</li> <li>Poor developer experience</li> </ul> <p>Decision: Rejected - Too complex for benefit</p>"},{"location":"adr/028-workflow-script-extraction-pattern/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/028-workflow-script-extraction-pattern/#completed-extractions","title":"Completed Extractions","text":""},{"location":"adr/028-workflow-script-extraction-pattern/#llm-provider-detection","title":"\u2705 LLM Provider Detection","text":"<p>Status: COMPLETED</p> <ul> <li>Action: <code>.github/actions/llm-provider-detect/</code></li> <li>Scripts: detect-provider.sh (50 lines)</li> <li>Impact: Eliminated duplication, reused by sync.yml and create-enhanced-pr</li> <li>Decision Matrix: \u2705 Duplication (Critical), \u2705 Reusability (High), \u2705 Testability (High)</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#issue-state-manager","title":"\u2705 Issue State Manager","text":"<p>Status: COMPLETED</p> <ul> <li>Action: <code>.github/actions/issue-state-manager/</code></li> <li>Scripts: update-issue-state.sh (100 lines)</li> <li>Impact: Complex awk logic now testable locally</li> <li>Decision Matrix: \u2705 Complexity (Critical), \u2705 Testability (High), \u2705 Size (Medium)</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#init-helpers-suite","title":"\u2705 Init Helpers Suite","text":"<p>Status: COMPLETED - Moved to <code>.github/local-actions/</code></p> <ul> <li>Action: <code>.github/local-actions/init-helpers/</code></li> <li>Scripts:</li> <li>setup-upstream.sh (120 lines)</li> <li>setup-branch-protection.sh (140 lines)</li> <li>setup-security.sh (90 lines)</li> <li>deploy-fork-resources.sh (80 lines)</li> <li>Impact: Reduced init-complete.yml from 878 \u2192 593 lines (32.5% reduction)</li> <li>Decision Matrix: \u2705 Size (High), \u2705 Complexity (High), \u2705 Testability (High)</li> <li>Note: Moved to local-actions to prevent syncing init-only logic to fork instances</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#push-protection-handler","title":"\u2705 Push Protection Handler","text":"<p>Status: COMPLETED</p> <ul> <li>Action: <code>.github/local-actions/push-protection-handler/</code></li> <li>Scripts: detect-and-report.sh (76 lines)</li> <li>Impact: Extracted complex push protection error handling from init-complete.yml</li> <li>Decision Matrix: \u2705 Complexity (Critical), \u2705 Testability (High), \u2705 Reusability (Medium)</li> <li>Key Features: Regex parsing with ANSI code handling, secret allowlist URL extraction, detailed escalation issues</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#template-protection-check","title":"\u2705 Template Protection Check","text":"<p>Status: COMPLETED</p> <ul> <li>Action: <code>.github/local-actions/template-protection-check/</code></li> <li>Scripts: check-template.sh (40 lines)</li> <li>Impact: Eliminated duplication across init.yml and init-complete.yml</li> <li>Decision Matrix: \u2705 Duplication (Critical), \u2705 Reusability (High)</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#configure-git","title":"\u2705 Configure Git","text":"<p>Status: COMPLETED</p> <ul> <li>Action: <code>.github/local-actions/configure-git/</code></li> <li>Impact: Eliminated git config duplication across init workflows</li> <li>Decision Matrix: \u2705 Duplication (Critical), \u2705 Reusability (High)</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#sync-state-manager","title":"\u2705 Sync State Manager","text":"<p>Status: COMPLETED</p> <ul> <li>Action: <code>.github/actions/sync-state-manager/</code></li> <li>Scripts:</li> <li>get-upstream-sha.sh (35 lines)</li> <li>check-stored-state.sh (66 lines)</li> <li>detect-existing-prs.sh (56 lines)</li> <li>detect-existing-issues.sh (50 lines)</li> <li>cleanup-abandoned-branches.sh (78 lines)</li> <li>make-sync-decision.sh (132 lines)</li> <li>Impact: Reduced action.yml from 270 \u2192 85 lines (68% reduction)</li> <li>Decision Matrix: \u2705 Size (Critical), \u2705 Complexity (Critical), \u2705 Testability (Critical)</li> <li>Key features: Decision matrix with 4 scenarios, platform-compatible date parsing (GNU/BSD)</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#create-enhanced-pr-refactor","title":"\u2705 Create Enhanced PR Refactor","text":"<p>Status: COMPLETED</p> <ul> <li>Action: Refactored to use llm-provider-detect</li> <li>Impact: Eliminated LLM detection duplication (23 lines)</li> <li>Decision Matrix: \u2705 Duplication (Critical), \u2705 Reusability (High)</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#extraction-decisions-not-extracted","title":"Extraction Decisions - Not Extracted","text":""},{"location":"adr/028-workflow-script-extraction-pattern/#java-build-action","title":"\u274c java-build Action","text":"<p>Status: KEPT AS-IS</p> <ul> <li>Size: 93 lines</li> <li>Rationale: Simple Maven orchestration, already maintainable</li> <li>Decision Matrix: \u274c Complexity (Low), \u274c Size (Low), \u274c Testability value (Low)</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#cascadeyml-scripts","title":"\u274c cascade.yml Scripts","text":"<p>Status: KEPT AS-IS (Future opportunity noted)</p> <ul> <li>Size: 744 lines total, 15 scripts averaging 49 lines each</li> <li>Rationale: Workflow orchestration, single-use patterns</li> <li>Decision Matrix: \u26a0\ufe0f Size (High), \u274c Reusability (Low), \u274c Type (Orchestration)</li> <li>Future: Could extract \"Check Integration State\" logic (lines 45-118) if reused</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#validateyml-scripts","title":"\u274c validate.yml Scripts","text":"<p>Status: KEPT AS-IS</p> <ul> <li>Size: 325 lines total, 7 scripts averaging 46 lines each</li> <li>Rationale: Simple validation logic, already clear</li> <li>Decision Matrix: \u274c Complexity (Low), \u274c Reusability (Low)</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#sync-templateyml-scripts","title":"\u274c sync-template.yml Scripts","text":"<p>Status: KEPT AS-IS</p> <ul> <li>Size: 430 lines total, 9 scripts averaging 47 lines each</li> <li>Rationale: Single-use template sync orchestration</li> <li>Decision Matrix: \u274c Reusability (Low), \u274c Type (Orchestration)</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#syncyml-scripts","title":"\ud83d\udeab sync.yml Scripts","text":"<p>Status: EXCEPTION - Cannot extract</p> <ul> <li>Size: 642 lines total, 12 scripts</li> <li>Constraint: Runs from fork_upstream branch where actions don't exist</li> <li>Decision Matrix: N/A - Technical constraint overrides</li> </ul> <p>Attempted Workarounds Evaluated:</p> <ol> <li>Checkout actions to separate path - Rejected: Actions require relative path <code>uses: ./.github/actions/</code>, cannot reference custom paths</li> <li>Bash functions within workflow - Rejected: Eliminates duplication but provides no testability improvement; adds complexity without solving core problem</li> <li>Docker/JS action from registry - Rejected: External dependency, adds complexity, would require publishing action to marketplace</li> <li>Copy actions during workflow - Rejected: Race condition (actions needed before they can be copied from main)</li> <li>Accept inline duplication - ACCEPTED: Simplest solution given constraints; duplication is minimal (~24 lines) and localized to two locations with clear ADR reference comments</li> </ol>"},{"location":"adr/028-workflow-script-extraction-pattern/#summary-statistics","title":"Summary Statistics","text":"<p>Extractions Completed:</p> <ul> <li>8 composite actions created (4 fork-operational, 4 template-only)</li> <li>15+ shell scripts extracted (~1,200+ lines total)</li> <li>3 workflow files refactored (init.yml, init-complete.yml, create-enhanced-pr/action.yml)</li> </ul> <p>Impact:</p> <ul> <li>init.yml: 194 \u2192 195 lines (added job summaries, net neutral after extractions)</li> <li>init-complete.yml: 594 \u2192 561 lines (33 lines reduced, 5.6% reduction)</li> <li>sync-state-manager: 270 \u2192 85 lines (68% reduction)</li> <li>Eliminated LLM detection duplication (~150 lines)</li> <li>Eliminated template protection duplication (~40 lines)</li> <li>Eliminated git config duplication (~10 lines)</li> <li>100% of extracted scripts locally testable</li> </ul> <p>Directory Organization:</p> <ul> <li><code>.github/actions/</code> - 5 fork-operational actions (synced to forks)</li> <li><code>.github/local-actions/</code> - 4 template-only actions (excluded from sync, removed after init)</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#testing-strategy","title":"Testing Strategy","text":"<p>Local Testing:</p> <pre><code># Each action includes local test examples\ncd .github/actions/llm-provider-detect\nexport AZURE_API_KEY=\"test\"\n./detect-provider.sh\n# Verify outputs\n</code></pre> <p>Integration Testing:</p> <ol> <li>Test in template repository test branch</li> <li>Verify workflows use actions correctly</li> <li>Validate outputs match original inline behavior</li> <li>Test with various input scenarios</li> </ol> <p>Fork Testing:</p> <ol> <li>Wait for template-sync to create PR</li> <li>Review changes in fork instance</li> <li>Merge and test workflows</li> <li>Verify functionality preserved</li> </ol>"},{"location":"adr/028-workflow-script-extraction-pattern/#consequences","title":"Consequences","text":""},{"location":"adr/028-workflow-script-extraction-pattern/#positive-achieved","title":"Positive (Achieved)","text":"<ul> <li>\u2705 32-68% reduction in targeted workflow/action files: init-complete.yml and sync-state-manager significantly more manageable</li> <li>\u2705 Eliminated code duplication: LLM provider detection reused across sync.yml and create-enhanced-pr</li> <li>\u2705 100% local testability: All 12 extracted scripts testable without workflow execution</li> <li>\u2705 Improved maintainability: Single location for complex logic (decision matrices, date parsing, state management)</li> <li>\u2705 Enhanced reusability: llm-provider-detect used by 2 actions, init-helpers reusable across forks</li> <li>\u2705 Better readability: init-complete.yml now shows orchestration (593 lines) vs implementation details</li> <li>\u2705 Sync compatibility: Leverages existing <code>.github/actions/</code> sync path (no sync-config.json changes)</li> <li>\u2705 Consistent pattern: All scripts follow identical structure (shebang, header, validation, dual output)</li> <li>\u2705 Platform compatibility: Cleanup scripts handle both GNU and BSD date parsing</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#negative-observed","title":"Negative (Observed)","text":"<ul> <li>\u26a0\ufe0f Additional abstraction: Workflows call actions which call scripts (manageable with good documentation)</li> <li>\u26a0\ufe0f Learning curve: Team must understand action structure and script conventions (mitigated by READMEs)</li> <li>\u26a0\ufe0f More files: 1,043 lines across 12 files vs inline (organized by action directory)</li> <li>\u26a0\ufe0f Mixed extraction: Some workflows extracted (init-complete), others not (cascade, validate) - creates pattern inconsistency</li> <li>\u26a0\ufe0f sync.yml exception: Largest workflow (657 lines) cannot be extracted due to branch execution context</li> <li>\u26a0\ufe0f Workflow orchestration boundary: Difficult to determine extraction vs inline for medium-complexity scripts</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#net-assessment","title":"Net Assessment","text":"<p>Positive: For targeted, complex actions (sync-state-manager, init-helpers), extraction provided significant value:</p> <ul> <li>68% reduction in sync-state-manager makes decision matrix logic clearly testable</li> <li>32.5% reduction in init-complete.yml improves workflow readability</li> <li>Platform compatibility issues (GNU/BSD date) now testable locally</li> </ul> <p>Trade-offs Accepted:</p> <ul> <li>Workflow orchestration scripts (cascade.yml, validate.yml) remain inline - acceptable as single-use flows</li> <li>sync.yml exception due to technical constraint - documented and understood</li> <li>Slightly more files (12 scripts + 4 action.yml + 4 READMs = 20 files) vs inline - worth it for testability</li> </ul> <p>Pattern Established: Decision matrix in Section 6 provides clear guidance for future extractions</p>"},{"location":"adr/028-workflow-script-extraction-pattern/#mitigation-strategies","title":"Mitigation Strategies","text":"<p>Documentation:</p> <ul> <li>Comprehensive README.md in each action directory</li> <li>Local testing examples with expected outputs</li> <li>Usage documentation in workflows</li> <li>This ADR as architectural reference</li> </ul> <p>Testing:</p> <ul> <li>Local test procedures for each script</li> <li>Integration tests in template repository</li> <li>Fork instance validation before rollout</li> <li>Gradual extraction (one script at a time)</li> </ul> <p>Rollback:</p> <ul> <li>Keep original inline scripts until validated</li> <li>Easy to revert extracted scripts</li> <li>Gradual migration reduces risk</li> <li>Can pause extraction if issues arise</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#success-criteria","title":"Success Criteria","text":"<p>Achieved Results:</p> <ul> <li>\u2705 Code Reduction: 32.5% reduction in init-complete.yml, 68% reduction in sync-state-manager (exceeded 40% target for targeted files)</li> <li>\u2705 Duplication Eliminated: Zero duplication of LLM provider detection (achieved)</li> <li>\u2705 Local Testability: 100% of extracted scripts testable locally (achieved)</li> <li>\u2705 Sync Propagation: Scripts propagate via existing <code>.github/actions/</code> sync path (achieved)</li> <li>\u2705 No Config Changes: Zero modifications to sync-config.json required (achieved)</li> <li>\u2705 Maintained Functionality: All workflows preserve original behavior (achieved)</li> <li>\u2705 Improved Maintenance: Scripts now debuggable locally without workflow runs (achieved)</li> <li>\u2705 Consistent Pattern: All 12 scripts follow identical structure (9.5/10 consistency score)</li> </ul> <p>Validation Metrics:</p> <ul> <li>4 composite actions created</li> <li>12 shell scripts extracted</li> <li>1,043 lines in extracted scripts</li> <li>285 lines eliminated from init-complete.yml</li> <li>185 lines eliminated from sync-state-manager</li> <li>~150 lines of duplication eliminated</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#monitoring-and-validation","title":"Monitoring and Validation","text":""},{"location":"adr/028-workflow-script-extraction-pattern/#metrics-to-track","title":"Metrics to Track","text":"<p>Code Quality Metrics:</p> <ul> <li>Lines of code in workflows (should decrease ~40%)</li> <li>Script duplication instances (should be zero)</li> <li>Local test coverage (should be 100% of extracted scripts)</li> </ul> <p>Operational Metrics:</p> <ul> <li>Workflow success rate (should remain stable)</li> <li>Script execution time (should be negligible overhead)</li> <li>Template sync success rate (should remain 100%)</li> </ul> <p>Developer Experience:</p> <ul> <li>Time to debug script issues (should decrease)</li> <li>Time to update script logic (should decrease)</li> <li>New contributor onboarding time (should decrease)</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#lessons-learned","title":"Lessons Learned","text":""},{"location":"adr/028-workflow-script-extraction-pattern/#what-worked-well","title":"What Worked Well","text":"<ol> <li>Decision matrix approach: Having clear criteria (size, complexity, reusability) prevented over-extraction</li> <li>Consistent script pattern: All 12 scripts follow identical structure - easy for maintainers to understand</li> <li>Dual output pattern: Scripts work both in GitHub Actions (GITHUB_OUTPUT) and locally (stdout)</li> <li>Comprehensive READMEs: Each action includes testing examples - essential for adoption</li> <li>Incremental approach: Extracting one action at a time allowed validation before proceeding</li> </ol>"},{"location":"adr/028-workflow-script-extraction-pattern/#what-was-challenging","title":"What Was Challenging","text":"<ol> <li>Extraction boundary: Determining where \"reusable action\" ends and \"workflow orchestration\" begins</li> <li>sync.yml constraint: Most complex workflow (657 lines) cannot be extracted due to branch context</li> <li>Diminishing returns: After high-value extractions, remaining workflows showed less benefit</li> <li>Pattern inconsistency: Some workflows extracted, others not - creates maintenance expectations</li> </ol>"},{"location":"adr/028-workflow-script-extraction-pattern/#recommendations-for-future-extractions","title":"Recommendations for Future Extractions","text":"<ol> <li>Apply decision matrix strictly: Use Section 6 criteria before extracting</li> <li>Prioritize complexity over size: Extract decision matrices and state machines first</li> <li>Don't extract orchestration: Workflow-specific flows should generally remain inline</li> <li>Document exceptions clearly: Technical constraints (like sync.yml) should be explicit</li> <li>Test locally before committing: All scripts should be validated with actual repository state</li> </ol>"},{"location":"adr/028-workflow-script-extraction-pattern/#future-evolution","title":"Future Evolution","text":""},{"location":"adr/028-workflow-script-extraction-pattern/#realistic-enhancements","title":"Realistic Enhancements","text":"<p>Cascade Integration State Checker (if needed):</p> <ul> <li>Extract cascade.yml lines 45-118 if cascade-monitor.yml needs same logic</li> <li>Would follow same pattern as sync-state-manager</li> <li>Only if reuse justifies extraction</li> </ul> <p>Script Pattern Standardization:</p> <ul> <li>Standardize emoji usage (currently mixed: \u2713, \u26a0\ufe0f, \u2139)</li> <li>Consider adding common utility functions (error handling, logging)</li> <li>Create script template for new extractions</li> </ul> <p>Testing Improvements:</p> <ul> <li>Add example test cases to READMEs</li> <li>Document common testing scenarios (mocking gh CLI output)</li> <li>Consider bash testing framework if scripts become more complex</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#explicitly-not-planned","title":"Explicitly Not Planned","text":"<p>Not extracting workflow orchestration: cascade.yml, validate.yml, sync-template.yml will remain inline unless specific logic becomes reusable elsewhere</p> <p>Not adding test framework: Current manual testing sufficient for script complexity level</p> <p>Not creating shared utility directory: 12 scripts don't justify shared library overhead</p>"},{"location":"adr/028-workflow-script-extraction-pattern/#related-adrs","title":"Related ADRs","text":"<ul> <li>ADR-010: YAML-Safe Shell Scripting - Addresses YAML syntax safety</li> <li>ADR-011: Configuration-Driven Template Sync - Provides sync mechanism</li> <li>ADR-012: Template Update Propagation - Describes how scripts propagate</li> <li>ADR-013: Reusable GitHub Actions Pattern - Establishes composite action patterns</li> <li>ADR-015: Template-Workflows Separation - Explains workflow permission constraints and template/fork separation pattern</li> <li>ADR-018: Fork-Resources Staging Pattern - Similar two-stage deployment pattern for specialized resources</li> </ul>"},{"location":"adr/028-workflow-script-extraction-pattern/#notes-on-local-actions-pattern","title":"Notes on Local-Actions Pattern","text":"<p>The <code>.github/local-actions/</code> pattern was introduced to solve a lifecycle mismatch problem:</p> <p>Problem: Init-only actions (init-helpers, push-protection-handler, etc.) were placed in <code>.github/actions/</code>, causing them to:</p> <ul> <li>Sync to all fork instances via template-sync.yml</li> <li>Remain in fork repositories despite never being used (init workflows are removed after initialization)</li> <li>Consume sync bandwidth and pollute fork repositories with unused code</li> </ul> <p>Solution: Following ADR-015's template/fork separation pattern:</p> <ul> <li>Template-only actions \u2192 <code>.github/local-actions/</code> (excluded from sync, removed during init)</li> <li>Fork-operational actions \u2192 <code>.github/actions/</code> (synced to forks, used by ongoing workflows)</li> </ul> <p>Configuration:</p> <ul> <li><code>sync-config.json</code> line 114: Excludes <code>.github/local-actions</code> from template sync</li> <li><code>sync-config.json</code> line 123-126: Removes <code>.github/local-actions/</code> during initialization cleanup</li> </ul> <p>This ensures fork instances only receive actions they actually use, following the principle established in ADR-015.</p>"},{"location":"adr/028-workflow-script-extraction-pattern/#references","title":"References","text":"<ul> <li>GitHub Actions: Creating a composite action</li> <li>GitHub Actions: Workflow syntax</li> <li>Bash scripting best practices</li> <li>Template repository: <code>.github/sync-config.json</code></li> </ul> <p>\u2190 ADR-027 |  Catalog</p>"},{"location":"adr/029-github-app-authentication-strategy/","title":"ADR-029: GitHub App Authentication Strategy for Workflow Automation","text":""},{"location":"adr/029-github-app-authentication-strategy/#status","title":"Status","text":"<p>Accepted - 2025-10-06</p>"},{"location":"adr/029-github-app-authentication-strategy/#context","title":"Context","text":"<p>Microsoft's enterprise GitHub environment enforces strict security controls that fundamentally impact workflow automation capabilities. Three key constraints create the need for an alternative authentication approach:</p>"},{"location":"adr/029-github-app-authentication-strategy/#1-organization-wide-github_token-restrictions","title":"1. Organization-Wide GITHUB_TOKEN Restrictions","text":"<p>Microsoft DSR (Digital Security &amp; Resilience) has configured organization-level settings that override repository-level permissions:</p> <ul> <li>Default <code>GITHUB_TOKEN</code> permission is read-only for all scopes</li> <li>\"Allow GitHub Actions to create and approve pull requests\" is disabled</li> <li>These settings cannot be changed at the repository level</li> <li>Explicit <code>permissions</code> blocks in workflows are overridden by org policy</li> </ul>"},{"location":"adr/029-github-app-authentication-strategy/#2-personal-access-token-pat-deprecation-policy","title":"2. Personal Access Token (PAT) Deprecation Policy","text":"<p>Microsoft is aggressively phasing out PAT usage following the Secure Future Initiative:</p> <ul> <li>January 2025: 365-day maximum PAT lifetime</li> <li>March 2025: 180-day maximum PAT lifetime</li> <li>May 2025: 90-day maximum PAT lifetime</li> <li>July 2025: Classic PATs restricted to 30 days</li> <li>No automated renewal API available</li> <li>Security incidents involving compromised PATs drive policy</li> </ul>"},{"location":"adr/029-github-app-authentication-strategy/#3-required-elevated-permissions","title":"3. Required Elevated Permissions","text":"<p>Critical workflows in the fork management system require permissions that <code>GITHUB_TOKEN</code> cannot provide:</p> <ul> <li> <p>Release Automation: Creating release PRs and GitHub releases (requires <code>contents: write</code> and <code>pull-requests: write</code>)</p> </li> <li> <p>Repository Initialization: Setting repository variables, deploying workflows, configuring security settings, creating rulesets (requires <code>administration: write</code>, <code>workflows: write</code>, <code>variables: write</code>)</p> </li> </ul> <p>Traditional approaches (PATs, service accounts) are either blocked by policy or create operational/security burdens incompatible with enterprise requirements.</p>"},{"location":"adr/029-github-app-authentication-strategy/#decision","title":"Decision","text":"<p>Adopt GitHub Apps with installation tokens as the standard authentication mechanism for all workflow automation requiring elevated permissions.</p>"},{"location":"adr/029-github-app-authentication-strategy/#core-implementation","title":"Core Implementation","text":"<ol> <li> <p>Create Organization-Level GitHub App</p> </li> <li> <p>Owned by the Azure/Microsoft organization (not individuals)</p> </li> <li>Configured with minimal required permissions</li> <li> <p>Installed on specific repositories requiring automation</p> </li> <li> <p>Required Permissions</p> </li> <li> <p>Contents: Read and write (for releases, git operations)</p> </li> <li>Pull requests: Read and write (for release PRs)</li> <li>Administration: Read and write (for variables, security settings, rulesets)</li> <li>Workflows: Read and write (for deploying workflow files)</li> <li> <p>Variables: Read and write (for repository configuration)</p> </li> <li> <p>Token Generation in Workflows</p> </li> </ol> <pre><code>- name: Generate GitHub App Token\n  id: app-token\n  uses: actions/create-github-app-token@v1\n  with:\n    app-id: ${{ secrets.RELEASE_APP_ID }}\n    private-key: ${{ secrets.RELEASE_APP_PRIVATE_KEY }}\n\n- name: Use Token for Elevated Operations\n  env:\n    GH_TOKEN: ${{ steps.app-token.outputs.token }}\n  run: |\n    gh pr create --title \"release\"\n</code></pre> <ol> <li> <p>Secrets Configuration</p> </li> <li> <p><code>RELEASE_APP_ID</code>: Application ID (organization-level secret)</p> </li> <li><code>RELEASE_APP_PRIVATE_KEY</code>: Private certificate (organization-level secret)</li> <li>Secrets distributed to all repositories requiring automation</li> </ol>"},{"location":"adr/029-github-app-authentication-strategy/#rationale","title":"Rationale","text":""},{"location":"adr/029-github-app-authentication-strategy/#why-github-apps-are-superior","title":"Why GitHub Apps Are Superior","text":"<p>Security Advantages:</p> <ul> <li>Short-lived tokens: 1-hour expiration vs 90+ days for PATs</li> <li>Scoped permissions: Granular control over what the app can access</li> <li>Installation-based: Limited to specific repositories, not all user resources</li> <li>Certificate-based: Private key less likely to be accidentally committed than PAT</li> <li>Audit trail: Clear attribution in GitHub logs (app name vs user)</li> </ul> <p>Operational Advantages:</p> <ul> <li>Not tied to individuals: Survives employee changes, no personal account dependency</li> <li>No manual rotation: Tokens generated on-demand, no weekly/monthly renewal</li> <li>Team-managed: Multiple organization admins can manage the app</li> <li>Microsoft-approved: Explicitly recommended in Microsoft's GitHub TSG documentation</li> <li>Policy-compliant: Aligns with DSR requirements and PAT deprecation timeline</li> </ul> <p>Enterprise Advantages:</p> <ul> <li>Centralized management: Single app serves all OSDU repositories</li> <li>Consistent security model: Same approach across organization</li> <li>Emergency response: Org admins can revoke certificates in security incidents</li> <li>Compliance: Meets SDL requirements for credential lifecycle management</li> </ul>"},{"location":"adr/029-github-app-authentication-strategy/#comparison-with-alternatives","title":"Comparison with Alternatives","text":"Approach Pros Cons Verdict GitHub App \u2022 Short-lived tokens\u2022 Not tied to individuals\u2022 Microsoft-recommended\u2022 Granular permissions \u2022 Initial setup complexity\u2022 Requires org admin approval \u2705 Accepted Personal PAT \u2022 Simple to create\u2022 Direct user control \u2022 Tied to individual\u2022 Long-lived credentials\u2022 Being phased out by Microsoft\u2022 Manual rotation \u274c Rejected Service Account + PAT \u2022 Not tied to personal account \u2022 Still requires PAT\u2022 Manual rotation\u2022 Requires license seat\u2022 Against Microsoft policy \u274c Rejected Fine-grained PAT \u2022 Better scoping than classic PAT \u2022 Still manual rotation\u2022 90-day max lifetime\u2022 No renewal API\u2022 Against policy direction \u274c Rejected Manual Workflows \u2022 No automation complexity \u2022 Breaks automation benefits\u2022 Manual intervention required\u2022 Not scalable \u274c Rejected"},{"location":"adr/029-github-app-authentication-strategy/#consequences","title":"Consequences","text":""},{"location":"adr/029-github-app-authentication-strategy/#positive","title":"Positive","text":"<ul> <li>Policy Compliance: Aligns with Microsoft's PAT deprecation roadmap</li> <li>Enhanced Security: Short-lived tokens reduce compromise window from months to 1 hour</li> <li>Team Resilience: Not dependent on any individual employee's account</li> <li>Operational Simplicity: No manual rotation or credential management</li> <li>Audit Clarity: Clear attribution in GitHub audit logs (app identity vs user)</li> <li>Scalability: Single app serves all fork repositories with consistent behavior</li> <li>Future-Proof: Works within Microsoft's security control framework</li> </ul>"},{"location":"adr/029-github-app-authentication-strategy/#negative","title":"Negative","text":"<ul> <li>Setup Complexity: Requires organization admin to create and approve app</li> <li>Permission Management: Changes to permissions require re-approval on installations</li> <li>Documentation Burden: Teams need to understand GitHub Apps vs PATs</li> <li>Secret Distribution: App ID and private key must be added to each repository</li> <li>Dependency: Relies on GitHub Apps infrastructure availability</li> </ul>"},{"location":"adr/029-github-app-authentication-strategy/#neutral","title":"Neutral","text":"<ul> <li>Token Lifetime: 1-hour expiration sufficient for workflow execution (same as Entra ID tokens)</li> <li>Permission Model: Fine-grained permissions require careful configuration</li> <li>Migration Path: Existing repositories need secrets added but workflows adapt automatically</li> </ul>"},{"location":"adr/029-github-app-authentication-strategy/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/029-github-app-authentication-strategy/#phase-1-github-app-creation-completed","title":"Phase 1: GitHub App Creation (Completed)","text":"<p>Application Configuration:</p> <ul> <li>Name: <code>osdu-spi-automation</code></li> <li>Owner: Personal account initially, transfer to Azure organization for production</li> <li>Homepage: https://github.com/Azure/osdu-spi</li> <li>Webhook: Disabled (not needed for token generation)</li> <li>Installation: Azure organization repositories</li> </ul> <p>Permission Configuration:</p> <pre><code>Repository Permissions:\n  contents: read-write        # For releases, git operations\n  pull-requests: read-write   # For creating release PRs\n  administration: read-write  # For variables, security, rulesets\n  workflows: read-write       # For deploying workflow files\n  variables: read-write       # For setting repository variables\n  metadata: read-only         # Automatic, required\n\nOrganization Permissions: none\nAccount Permissions: none\n</code></pre>"},{"location":"adr/029-github-app-authentication-strategy/#phase-2-workflow-integration-completed","title":"Phase 2: Workflow Integration (Completed)","text":"<p>Release Automation (<code>dev-release.yml</code>):</p> <pre><code>jobs:\n  release-please:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n      pull-requests: write\n    steps:\n      - uses: actions/checkout@v5\n\n      - name: Generate GitHub App Token\n        id: app-token\n        uses: actions/create-github-app-token@v1\n        with:\n          app-id: ${{ secrets.RELEASE_APP_ID }}\n          private-key: ${{ secrets.RELEASE_APP_PRIVATE_KEY }}\n\n      - name: Generate Release PR\n        uses: googleapis/release-please-action@v4\n        with:\n          token: ${{ steps.app-token.outputs.token }}  # Uses app token\n          config-file: .release-please-config.json\n</code></pre> <p>Repository Initialization (<code>init-complete.yml</code>):</p> <pre><code>jobs:\n  setup_repository:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n      actions: write\n      issues: write\n    steps:\n      - name: Generate GitHub App Token\n        id: app-token\n        uses: actions/create-github-app-token@v1\n        with:\n          app-id: ${{ secrets.RELEASE_APP_ID }}\n          private-key: ${{ secrets.RELEASE_APP_PRIVATE_KEY }}\n\n      - name: Configure Variables\n        env:\n          GH_TOKEN: ${{ steps.app-token.outputs.token }}  # Uses app token\n        run: |\n          gh variable set UPSTREAM_REPO_URL --body \"$REPO_URL\"\n\n      - name: Configure Security\n        env:\n          GH_TOKEN: ${{ steps.app-token.outputs.token }}  # Uses app token\n        run: |\n          ./setup-security.sh\n\n      - name: Setup Repository Rulesets\n        env:\n          GH_TOKEN: ${{ steps.app-token.outputs.token }}  # Uses app token\n        run: |\n          ./setup-rulesets.sh\n</code></pre>"},{"location":"adr/029-github-app-authentication-strategy/#phase-3-secret-distribution","title":"Phase 3: Secret Distribution","text":"<p>Repository-Level Secrets:</p> <pre><code># Add secrets to individual repository\ngh secret set RELEASE_APP_ID --repo Azure/osdu-spi --body \"2072585\"\ngh secret set RELEASE_APP_PRIVATE_KEY --repo Azure/osdu-spi --body \"@osdu-spi-automation.pem\"\n</code></pre>"},{"location":"adr/029-github-app-authentication-strategy/#security-considerations","title":"Security Considerations","text":""},{"location":"adr/029-github-app-authentication-strategy/#token-lifecycle","title":"Token Lifecycle","text":"<ul> <li>Generation: On-demand per workflow run</li> <li>Lifetime: 1 hour maximum</li> <li>Scope: Limited to installed repositories and configured permissions</li> <li>Revocation: Automatic expiration, manual revocation via app settings</li> </ul>"},{"location":"adr/029-github-app-authentication-strategy/#private-key-management","title":"Private Key Management","text":"<ul> <li>Storage: GitHub Secrets (encrypted at rest)</li> <li>Access: Only available to workflow runs, not visible in UI</li> <li>Rotation: Generate new key, update secret, revoke old key</li> <li>Backup: Keep secure backup of private key for disaster recovery</li> </ul>"},{"location":"adr/029-github-app-authentication-strategy/#permission-boundaries","title":"Permission Boundaries","text":"<ul> <li>Principle of Least Privilege: Only grant permissions actively used by workflows</li> <li>Installation Scope: Only install on repositories requiring automation</li> <li>Regular Review: Audit app permissions quarterly</li> <li>Change Management: Re-approval required for permission changes</li> </ul>"},{"location":"adr/029-github-app-authentication-strategy/#incident-response","title":"Incident Response","text":"<p>If App Credentials Are Compromised: 1. Immediately revoke private key in app settings 2. Generate new private key 3. Update organization secrets with new key 4. Review audit logs for unauthorized operations 5. Document incident per Microsoft security procedures</p>"},{"location":"adr/029-github-app-authentication-strategy/#for-new-fork-repositories","title":"For New Fork Repositories","text":"<p>GitHub App authentication is automatically configured:</p> <ol> <li>Initialization workflow uses app token</li> <li>Secrets inherited from organization</li> <li>App already installed on organization repositories</li> <li>No manual configuration required</li> </ol>"},{"location":"adr/029-github-app-authentication-strategy/#monitoring-and-validation","title":"Monitoring and Validation","text":""},{"location":"adr/029-github-app-authentication-strategy/#success-metrics","title":"Success Metrics","text":"<ul> <li>Token Generation Rate: Monitor <code>actions/create-github-app-token</code> success rate</li> <li>Authentication Failures: Alert on 403 errors from GitHub API</li> <li>Workflow Success Rate: Track release and initialization workflow completion</li> <li>PAT Elimination: Verify no remaining <code>secrets.GH_TOKEN</code> references</li> </ul>"},{"location":"adr/029-github-app-authentication-strategy/#validation-steps","title":"Validation Steps","text":"<ol> <li>Release Workflow: Verify release PRs are created successfully</li> <li>Init Workflow: Verify repository variables, security settings, and rulesets are configured</li> <li>Audit Trail: Confirm app attribution in GitHub audit logs</li> <li>Token Lifetime: Verify 1-hour tokens sufficient for all workflow operations</li> <li>Permission Scope: Confirm no over-permissioning or access violations</li> </ol>"},{"location":"adr/029-github-app-authentication-strategy/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-002: GitHub Actions-Based Automation - Workflow automation framework</li> <li>ADR-004: Release Please for Version Management - Release automation using app tokens</li> <li>ADR-006: Two-Workflow Initialization Pattern - Initialization using app tokens</li> <li>ADR-026: Dependabot Security Update Strategy - Security automation context</li> </ul>"},{"location":"adr/029-github-app-authentication-strategy/#success-criteria","title":"Success Criteria","text":"<ul> <li>\u2705 Release Please successfully creates release PRs without PAT</li> <li>\u2705 Repository initialization completes all configuration steps</li> <li>\u2705 No <code>secrets.GH_TOKEN</code> references remain in workflow files</li> <li>\u2705 All fork repositories use GitHub App authentication</li> <li>\u2705 Zero manual credential rotation required</li> <li>\u2705 App attribution visible in GitHub audit logs</li> <li>\u2705 Workflow success rate matches or exceeds PAT baseline</li> </ul>"},{"location":"adr/029-github-app-authentication-strategy/#references","title":"References","text":"<ul> <li>Microsoft GitHub TSG: Reduce or Eliminate PAT Use</li> <li>Microsoft GitHub TSG: Securing and Evaluating GitHub Actions</li> <li>GitHub Docs: GitHub Apps Overview</li> <li>GitHub Docs: Authenticating with a GitHub App</li> <li>GitHub Docs: Permissions for GitHub Apps</li> <li>Actions: create-github-app-token</li> </ul> <p>\u2190 ADR-028 |  Catalog</p>"},{"location":"adr/030-codeql-summary-job-pattern/","title":"ADR-030: CodeQL Summary Job Pattern for Required Status Checks","text":""},{"location":"adr/030-codeql-summary-job-pattern/#status","title":"Status","text":"<p>Accepted - 2025-10-29</p>"},{"location":"adr/030-codeql-summary-job-pattern/#context","title":"Context","text":"<p>Fork repositories experienced PR blocking issues when using the CodeQL workflow with GitHub repository rulesets. Two related problems emerged:</p>"},{"location":"adr/030-codeql-summary-job-pattern/#problem-1-required-status-check-mismatch","title":"Problem 1: Required Status Check Mismatch","text":"<p>Repository rulesets configured during initialization require a status check named <code>\"CodeQL\"</code>:</p> <pre><code>{\n  \"type\": \"required_status_checks\",\n  \"parameters\": {\n    \"required_status_checks\": [\n      {\"context\": \"CodeQL\"}\n    ]\n  }\n}\n</code></pre> <p>However, the CodeQL workflow provided different job names: - <code>\"Check if Code Changes Present\"</code> (always runs) - <code>\"Detect Project Languages\"</code> (conditional) - <code>\"Analyze Code\"</code> (conditional)</p> <p>When PRs contained only configuration changes (e.g., dependabot.yml, workflows), the CodeQL workflow correctly skipped analysis to save resources. However, no check named <code>\"CodeQL\"</code> ever reported, leaving PRs in a BLOCKED state indefinitely.</p>"},{"location":"adr/030-codeql-summary-job-pattern/#problem-2-code-scanning-rule-blocking-config-only-prs","title":"Problem 2: Code Scanning Rule Blocking Config-Only PRs","text":"<p>The default branch protection ruleset included a <code>code_scanning</code> rule:</p> <pre><code>{\n  \"type\": \"code_scanning\",\n  \"parameters\": {\n    \"code_scanning_tools\": [{\n      \"tool\": \"CodeQL\",\n      \"security_alerts_threshold\": \"high_or_higher\",\n      \"alerts_threshold\": \"errors\"\n    }]\n  }\n}\n</code></pre> <p>This rule requires CodeQL to upload SARIF results (security scan analysis). For config-only PRs where analysis is appropriately skipped, no SARIF is uploaded, permanently blocking the PR. Even admin override (<code>gh pr merge --admin</code>) failed with:</p> <pre><code>Code scanning is waiting for results from CodeQL for the commits...\n</code></pre>"},{"location":"adr/030-codeql-summary-job-pattern/#impact","title":"Impact","text":"<ul> <li>Template sync PRs blocked: Config-only changes (dependabot, workflow updates) couldn't merge</li> <li>Dependabot PRs blocked: Dependency updates for <code>.github/</code> files couldn't merge</li> <li>Manual intervention required: Every config-only PR needed manual ruleset modification</li> <li>Inconsistent security posture: Some forks removed the rule manually, creating inconsistency</li> </ul>"},{"location":"adr/030-codeql-summary-job-pattern/#decision","title":"Decision","text":"<p>Implement a two-part solution:</p>"},{"location":"adr/030-codeql-summary-job-pattern/#1-add-codeql-summary-job","title":"1. Add CodeQL Summary Job","text":"<p>Add a summary job to the CodeQL workflow that: - Named <code>\"CodeQL\"</code>: Matches the required status check context exactly - Always executes: Uses <code>if: always()</code> to run regardless of previous job outcomes - Smart validation: Reports success for config-only changes, validates analysis results for code changes - Proper failure handling: Fails if actual analysis fails or is cancelled</p> <pre><code>CodeQL:\n  name: CodeQL  # Job name becomes the check context\n  runs-on: ubuntu-latest\n  needs: [check-paths, detect-languages, analyze]\n  if: always()  # Executes even when analysis skips\n  steps:\n    - name: Report CodeQL Status\n      run: |\n        # Validate check-paths succeeded\n        if [ \"${{ needs.check-paths.result }}\" != \"success\" ]; then\n          exit 1\n        fi\n\n        # Config-only changes: Report success\n        if [ \"${{ needs.check-paths.outputs.should-run }}\" = \"false\" ]; then\n          echo \"\u2705 CodeQL skipped - only configuration files changed\"\n          exit 0\n        fi\n\n        # Code changes: Validate analysis completed\n        if [ \"${{ needs.analyze.result }}\" = \"failure\" ] ||\n           [ \"${{ needs.analyze.result }}\" = \"cancelled\" ]; then\n          exit 1\n        fi\n\n        echo \"\u2705 CodeQL checks completed successfully\"\n</code></pre>"},{"location":"adr/030-codeql-summary-job-pattern/#2-remove-code-scanning-rule-from-template","title":"2. Remove Code Scanning Rule from Template","text":"<p>Remove the <code>code_scanning</code> rule from <code>.github/rulesets/default-branch.json</code>:</p> <p>Rationale: - The rule requires SARIF upload for every PR - Config-only PRs appropriately skip analysis (no code to scan) - No SARIF uploaded \u2192 PR permanently blocked - Status checks provide sufficient validation - CodeQL still runs on code changes and reports findings</p>"},{"location":"adr/030-codeql-summary-job-pattern/#rationale","title":"Rationale","text":""},{"location":"adr/030-codeql-summary-job-pattern/#why-summary-job-pattern","title":"Why Summary Job Pattern","text":"<ol> <li>Workflow Composability: GitHub Actions doesn't support renaming jobs dynamically</li> <li>Single Source of Truth: One job consolidates the status of multiple conditional jobs</li> <li>Standard Pattern: Widely used in GitHub Actions for exactly this use case</li> <li>Flexibility: Can add more checks in the future without changing ruleset</li> </ol>"},{"location":"adr/030-codeql-summary-job-pattern/#why-remove-code-scanning-rule","title":"Why Remove Code Scanning Rule","text":"<ol> <li>SARIF Upload Requirement: The rule fundamentally requires results upload</li> <li>No Conditional SARIF: Can't conditionally satisfy the rule (it either has results or doesn't)</li> <li>Analysis Already Validated: The status check validates that analysis ran when needed</li> <li>Security Findings Still Visible: Results still appear in Security tab when analysis runs</li> <li>Most Teams Prefer Triage: Blocking on alert thresholds is often too strict; teams prefer to triage findings</li> </ol>"},{"location":"adr/030-codeql-summary-job-pattern/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/030-codeql-summary-job-pattern/#1-always-upload-empty-sarif-for-skipped-analysis","title":"1. Always Upload Empty SARIF for Skipped Analysis","text":"<p>Approach: Generate and upload a minimal valid SARIF file when analysis is skipped</p> <pre><code>- name: Upload empty SARIF for skipped analysis\n  if: needs.check-paths.outputs.should-run == 'false'\n  uses: github/codeql-action/upload-sarif@v4\n  with:\n    sarif_file: empty.sarif\n</code></pre> <p>Pros: - Satisfies the <code>code_scanning</code> rule - Maintains alert threshold blocking capability</p> <p>Cons: - \u274c Adds complexity and maintenance burden - \u274c Generates misleading data (empty scan results) - \u274c Violates principle of least surprise - \u274c No real security benefit over status checks</p> <p>Decision: Rejected due to complexity without meaningful security benefit</p>"},{"location":"adr/030-codeql-summary-job-pattern/#2-rename-existing-jobs-to-codeql","title":"2. Rename Existing Jobs to \"CodeQL\"","text":"<p>Approach: Change <code>check-paths</code> job name to \"CodeQL\"</p> <p>Pros: - Simple, no new jobs</p> <p>Cons: - \u274c Loses semantic meaning (\"CodeQL\" doesn't describe what check-paths does) - \u274c Doesn't solve code_scanning rule problem - \u274c Confusing when check-paths succeeds but analysis never ran</p> <p>Decision: Rejected due to loss of clarity</p>"},{"location":"adr/030-codeql-summary-job-pattern/#3-use-workflow-level-required-checks-only","title":"3. Use Workflow-Level Required Checks Only","text":"<p>Approach: Remove job-level requirements, require entire workflow success</p> <p>Pros: - Simpler configuration</p> <p>Cons: - \u274c GitHub rulesets don't support workflow-level checks (only job names) - \u274c Not technically feasible with current GitHub features</p> <p>Decision: Rejected as not possible</p>"},{"location":"adr/030-codeql-summary-job-pattern/#4-keep-code-scanning-rule-block-config-prs","title":"4. Keep Code Scanning Rule, Block Config PRs","text":"<p>Approach: Accept that config-only PRs will block and require manual override</p> <p>Pros: - Maintains strict security enforcement</p> <p>Cons: - \u274c Terrible user experience for legitimate PRs - \u274c Breaks automation (Dependabot, template sync) - \u274c Manual intervention doesn't scale - \u274c Security theater (config files don't need CodeQL)</p> <p>Decision: Rejected due to operational impact</p>"},{"location":"adr/030-codeql-summary-job-pattern/#consequences","title":"Consequences","text":""},{"location":"adr/030-codeql-summary-job-pattern/#positive","title":"Positive","text":"<p>\u2705 Config-only PRs work: Dependabot, template sync, and workflow updates merge without blocking \u2705 Security scanning preserved: CodeQL still runs on code changes \u2705 Findings visible: Results still appear in Security tab \u2705 Better automation: Template sync works reliably \u2705 Consistent behavior: All forks behave identically \u2705 Clear semantics: \"CodeQL\" check clearly represents CodeQL validation status</p>"},{"location":"adr/030-codeql-summary-job-pattern/#negative","title":"Negative","text":"<p>\u274c Lost alert threshold blocking: Can't require \"zero high-severity alerts\" before merge \u274c Manual security triage: Teams must review findings rather than being blocked \u274c Existing forks need update: Forks created before this change need manual ruleset modification</p>"},{"location":"adr/030-codeql-summary-job-pattern/#mitigations","title":"Mitigations","text":"<ul> <li>Security findings still generate notifications and appear in Security tab</li> <li>Teams can still review findings before merge (just not forced to)</li> <li>Most organizations prefer manual triage over strict blocking (false positives common)</li> <li>The summary job can be enhanced later to check alert severity if needed</li> </ul>"},{"location":"adr/030-codeql-summary-job-pattern/#implementation","title":"Implementation","text":""},{"location":"adr/030-codeql-summary-job-pattern/#files-changed","title":"Files Changed","text":"<ol> <li><code>.github/template-workflows/codeql.yml</code></li> <li>Added <code>CodeQL</code> summary job</li> <li>Validates previous jobs and reports consolidated status</li> <li> <p>Added build artifact exclusion patterns</p> </li> <li> <p><code>.github/rulesets/default-branch.json</code></p> </li> <li>Removed <code>code_scanning</code> rule</li> <li>Kept <code>required_status_checks</code> with \"CodeQL\" context</li> </ol>"},{"location":"adr/030-codeql-summary-job-pattern/#build-artifact-exclusion-pattern","title":"Build Artifact Exclusion Pattern","text":"<p>Problem: CodeQL language detection was finding generated Python files in build directories (e.g., <code>build-aws/build-info.py</code>), attempting to analyze them, and failing because they're malformed or auto-generated code.</p> <p>Error Example: <pre><code>[ERROR] Failed to extract file /home/runner/work/partition/partition/provider/partition-aws/build-aws/build-info.py: 'name'\nCodeQL detected code written in Python but could not process any of it.\n</code></pre></p> <p>Solution: Exclude build and generated code directories from both language detection and CodeQL analysis:</p> <p>Language Detection (lines 102-115): <pre><code># Check for Python (exclude build directories and common generated code paths)\nif [ -f \"setup.py\" ] || [ -f \"pyproject.toml\" ] || [ -f \"requirements.txt\" ] || \\\n   find . -name \"*.py\" \\\n     -not -path \"./.*\" \\\n     -not -path \"*/build/*\" \\\n     -not -path \"*/build-*/*\" \\\n     -not -path \"*/target/*\" \\\n     -not -path \"*/dist/*\" \\\n     -not -path \"*/__pycache__/*\" \\\n     -not -path \"*/.venv/*\" \\\n     -not -path \"*/venv/*\" \\\n     -not -path \"*/node_modules/*\" | grep -q .; then\n  LANGUAGES=$(echo \"$LANGUAGES\" | jq -c '. + [\"python\"]')\nfi\n</code></pre></p> <p>CodeQL Configuration (lines 172-189): <pre><code>- name: Initialize CodeQL\n  uses: github/codeql-action/init@v4\n  with:\n    languages: ${{ matrix.language }}\n    queries: security-extended\n    build-mode: none\n    config: |\n      paths-ignore:\n        - '**/build/**'\n        - '**/build-*/**'\n        - '**/target/**'\n        - '**/dist/**'\n        - '**/__pycache__/**'\n        - '**/.venv/**'\n        - '**/venv/**'\n        - '**/node_modules/**'\n        - '**/.pytest_cache/**'\n        - '**/.mypy_cache/**'\n</code></pre></p> <p>Benefits: - Prevents false language detection from build artifacts - Avoids CodeQL analysis failures on generated code - Focuses security analysis on actual source code - Reduces analysis time by skipping irrelevant paths</p>"},{"location":"adr/030-codeql-summary-job-pattern/#migration-path-for-existing-forks","title":"Migration Path for Existing Forks","text":"<p>Forks created before this change may have the <code>code_scanning</code> rule in their rulesets. To fix:</p> <ol> <li>Navigate to: Settings \u2192 Rules \u2192 Rulesets \u2192 \"Default Branch Protection\"</li> <li>Edit the ruleset</li> <li>Remove the \"Code scanning\" rule</li> <li>Save changes</li> </ol> <p>Or via API: <pre><code>gh api --method PUT repos/OWNER/REPO/rulesets/RULESET_ID \\\n  --input updated-ruleset.json\n</code></pre></p> <p>Next template sync will provide the updated CodeQL workflow automatically.</p>"},{"location":"adr/030-codeql-summary-job-pattern/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-010: YAML-safe shell scripting pattern (used in summary job)</li> <li>ADR-028: Workflow script extraction pattern (influenced job structure)</li> <li>Product Spec: CodeQL workflow specification (dynamic path filtering)</li> </ul>"},{"location":"adr/030-codeql-summary-job-pattern/#success-criteria","title":"Success Criteria","text":"<p>\u2705 Config-only PRs merge without manual intervention \u2705 Code changes still trigger CodeQL analysis \u2705 Security findings appear in Security tab \u2705 Status check \"CodeQL\" reports correctly for both scenarios \u2705 Existing forks can apply fix with documented migration path</p>"},{"location":"adr/030-codeql-summary-job-pattern/#references","title":"References","text":"<ul> <li>GitHub Issue: PR blocking on template sync (2025-10-29)</li> <li>Production Testing: danielscholl-osdu/partition, danielscholl-osdu/entitlements</li> <li>GitHub Docs: Repository rulesets</li> <li>GitHub Docs: CodeQL code scanning</li> </ul> <p>\u2190 ADR-029 |  Catalog</p>"},{"location":"adr/031-template-sync-duplicate-prevention/","title":"ADR-031: Template Sync Duplicate Prevention Pattern","text":""},{"location":"adr/031-template-sync-duplicate-prevention/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/031-template-sync-duplicate-prevention/#context","title":"Context","text":"<p>Following the successful implementation of duplicate prevention for upstream sync workflows (ADR-024), the same problem was identified in the template sync workflow. The daily template sync workflow (<code>template-sync.yml</code>) was creating duplicate PRs when humans delayed reviewing PRs, causing:</p> <ol> <li>Duplicate template-sync PRs - Multiple open PRs for the same template updates</li> <li>Repository clutter - Accumulation of stale template-sync branches</li> <li>Notification fatigue - Redundant GitHub notifications for template updates</li> <li>Confusion - Unclear which PR contains the latest template changes</li> </ol> <p>Evidence of the Problem:</p> <p>In production fork repositories, template-sync was creating a new PR every day when changes existed, even if a previous PR was still open. This resulted in 6+ open template-sync PRs simultaneously (e.g., PRs #12-18 in danielscholl-osdu/workflow).</p> <p>Relationship to ADR-024:</p> <p>ADR-024 solved this problem for upstream sync using the <code>sync-state-manager</code> action. Template sync needed the same duplicate prevention pattern, but with a simpler inline implementation.</p>"},{"location":"adr/031-template-sync-duplicate-prevention/#decision","title":"Decision","text":"<p>Implement Template Sync Duplicate Prevention following the same architectural pattern as upstream sync (ADR-024), but with inline detection logic instead of using the sync-state-manager action:</p>"},{"location":"adr/031-template-sync-duplicate-prevention/#1-pr-detection-and-label-based-tracking","title":"1. PR Detection and Label-Based Tracking","text":"<ul> <li>New Label: <code>template-sync</code> added to <code>.github/labels.json</code></li> <li>Detection Logic: Query GitHub API for open PRs with <code>template-sync</code> label targeting <code>main</code> branch</li> <li>Inline Implementation: Detection logic embedded directly in workflow (not extracted to action)</li> </ul>"},{"location":"adr/031-template-sync-duplicate-prevention/#2-decision-matrix-identical-to-upstream-sync","title":"2. Decision Matrix (Identical to Upstream Sync)","text":"<pre><code>| Existing PR | Template Changed | Action                    |\n|-------------|------------------|---------------------------|\n| No          | Yes              | Create new PR             |\n| Yes         | No               | No action needed          |\n| Yes         | Yes              | Update existing branch/PR |\n| No          | No               | No action needed          |\n</code></pre>"},{"location":"adr/031-template-sync-duplicate-prevention/#3-branch-reuse-strategy","title":"3. Branch Reuse Strategy","text":"<ul> <li>Existing PR Found: Reuse existing branch, reset to <code>main</code>, force-push updates</li> <li>No PR Found: Create new timestamped branch (<code>template-sync/YYYYMMDD-HHMMSS</code>)</li> <li>Single Active PR: Only one template-sync PR open at any time</li> </ul>"},{"location":"adr/031-template-sync-duplicate-prevention/#4-pr-update-behavior","title":"4. PR Update Behavior","text":"<p>When updating an existing PR: - Force-push new commits to existing branch - Update PR title to show \"(Updated YYYY-MM-DD)\" - Regenerate PR description with all current changes - Add comment about the update (with duplicate comment prevention)</p>"},{"location":"adr/031-template-sync-duplicate-prevention/#rationale","title":"Rationale","text":""},{"location":"adr/031-template-sync-duplicate-prevention/#why-not-reuse-sync-state-manager-action","title":"Why Not Reuse sync-state-manager Action?","text":"<p>Decision: Inline Implementation</p> <p>The sync-state-manager action was designed for upstream sync's more complex state management needs (tracking upstream SHA, issue lifecycle, cascade coordination). Template sync has simpler requirements:</p> <ol> <li>Simpler State: Only needs to track PR existence, not upstream versions</li> <li>No Issue Tracking: Template sync doesn't create tracking issues like upstream sync</li> <li>Different Base Branch: Targets <code>main</code> instead of <code>fork_upstream</code></li> <li>Self-Contained: All logic fits naturally in workflow without external scripts</li> </ol> <p>Benefits of Inline Approach: - Simplicity: Easier to understand and maintain - Performance: No additional action overhead - Clarity: All logic visible in single workflow file - Maintainability: Changes don't affect upstream sync logic</p>"},{"location":"adr/031-template-sync-duplicate-prevention/#consistency-with-adr-024-pattern","title":"Consistency with ADR-024 Pattern","text":"<p>Despite the implementation difference, the pattern remains consistent: - Same decision matrix for handling duplicates - Same branch reuse strategy with force-push - Same PR update behavior with comments - Same label-based tracking approach</p>"},{"location":"adr/031-template-sync-duplicate-prevention/#implementation-details","title":"Implementation Details","text":""},{"location":"adr/031-template-sync-duplicate-prevention/#detection-step-new","title":"Detection Step (New)","text":"<pre><code>- name: Detect existing template sync PRs\n  id: detect-existing\n  if: steps.check-updates.outputs.has_updates == 'true'\n  env:\n    GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}\n  run: |\n    echo \"Detecting existing template sync PRs...\"\n\n    # Query for open PRs with template-sync label targeting main branch\n    EXISTING_PR=$(gh pr list \\\n      --state open \\\n      --label \"template-sync\" \\\n      --base main \\\n      --json number,headRefName \\\n      --jq '.[0]')\n\n    if [ -n \"$EXISTING_PR\" ] &amp;&amp; [ \"$EXISTING_PR\" != \"null\" ]; then\n      PR_NUMBER=$(echo \"$EXISTING_PR\" | jq -r '.number')\n      PR_BRANCH=$(echo \"$EXISTING_PR\" | jq -r '.headRefName')\n      echo \"has_existing_pr=true\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"existing_pr_number=$PR_NUMBER\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"existing_pr_branch=$PR_BRANCH\" &gt;&gt; $GITHUB_OUTPUT\n    else\n      echo \"has_existing_pr=false\" &gt;&gt; $GITHUB_OUTPUT\n    fi\n</code></pre>"},{"location":"adr/031-template-sync-duplicate-prevention/#branch-management-modified","title":"Branch Management (Modified)","text":"<pre><code>- name: Create or update template sync branch\n  if: steps.check-updates.outputs.has_updates == 'true'\n  run: |\n    if [ \"${{ steps.detect-existing.outputs.has_existing_pr }}\" = \"true\" ]; then\n      # Reuse existing branch\n      SYNC_BRANCH=\"${{ steps.detect-existing.outputs.existing_pr_branch }}\"\n      git fetch origin $SYNC_BRANCH\n      git checkout -b $SYNC_BRANCH origin/$SYNC_BRANCH\n      git reset --hard refs/heads/main\n    else\n      # Create new sync branch with timestamp\n      DATE_SUFFIX=$(date +%Y%m%d-%H%M%S)\n      SYNC_BRANCH=\"template-sync/${DATE_SUFFIX}\"\n      git checkout -b $SYNC_BRANCH refs/heads/main\n    fi\n\n    echo \"SYNC_BRANCH=$SYNC_BRANCH\" &gt;&gt; $GITHUB_ENV\n</code></pre>"},{"location":"adr/031-template-sync-duplicate-prevention/#split-pr-creation-new","title":"Split PR Creation (New)","text":"<pre><code>- name: Create new template sync PR\n  if: steps.check-updates.outputs.has_updates == 'true' &amp;&amp;\n      env.has_changes == 'true' &amp;&amp;\n      steps.detect-existing.outputs.has_existing_pr == 'false'\n  id: create-pr\n  uses: ./.github/actions/create-enhanced-pr\n  # See .github/template-workflows/sync-template.yml for implementation details (PR creation and labeling)\n\n- name: Update existing template sync PR\n  if: steps.check-updates.outputs.has_updates == 'true' &amp;&amp;\n      env.has_changes == 'true' &amp;&amp;\n      steps.detect-existing.outputs.has_existing_pr == 'true'\n  id: update-pr\n  # See .github/template-workflows/sync-template.yml for implementation details (PR update logic)\n</code></pre>"},{"location":"adr/031-template-sync-duplicate-prevention/#label-definition","title":"Label Definition","text":"<pre><code>{\n  \"name\": \"template-sync\",\n  \"description\": \"Template repository synchronization\",\n  \"color\": \"0e8a16\"\n}\n</code></pre>"},{"location":"adr/031-template-sync-duplicate-prevention/#consequences","title":"Consequences","text":""},{"location":"adr/031-template-sync-duplicate-prevention/#positive","title":"Positive","text":"<ul> <li>\u2705 Eliminates duplicate template-sync PRs - Core problem solved</li> <li>\u2705 Consistent with upstream sync pattern - Same architectural approach</li> <li>\u2705 Simpler implementation - Inline logic easier to maintain than action</li> <li>\u2705 Clean repository state - No accumulation of stale PRs</li> <li>\u2705 Reduced notification fatigue - Single PR per template update cycle</li> <li>\u2705 Clear PR progression - Updated PRs show complete history</li> <li>\u2705 Preserves human workflow - Same PR URL throughout update cycle</li> </ul>"},{"location":"adr/031-template-sync-duplicate-prevention/#negative","title":"Negative","text":"<ul> <li>\u26a0\ufe0f Code duplication with sync-state-manager - Detection logic duplicated (but simplified)</li> <li>\u26a0\ufe0f No shared state management - Each workflow manages its own state</li> <li>\u26a0\ufe0f Different from upstream sync - Uses inline approach vs action approach</li> </ul>"},{"location":"adr/031-template-sync-duplicate-prevention/#neutral","title":"Neutral","text":"<ul> <li>\ud83d\udcdd Pattern reuse - Same architectural pattern, different implementation</li> <li>\ud83d\udcdd No breaking changes - Existing forks work without modification</li> <li>\ud83d\udcdd Automatic distribution - sync-config.json handles deployment</li> </ul>"},{"location":"adr/031-template-sync-duplicate-prevention/#comparison-with-adr-024","title":"Comparison with ADR-024","text":"Aspect Upstream Sync (ADR-024) Template Sync (ADR-031) Pattern Duplicate prevention via state management Same pattern Implementation Dedicated action (<code>sync-state-manager</code>) Inline detection logic Label <code>upstream-sync</code> <code>template-sync</code> Base Branch <code>fork_upstream</code> <code>main</code> State Tracking Git config + issue lifecycle PR detection only Complexity Higher (cascade coordination) Lower (PR-only) Reusability Action reusable by other workflows Workflow-specific logic"},{"location":"adr/031-template-sync-duplicate-prevention/#success-criteria","title":"Success Criteria","text":"<ul> <li>\u2705 Reduction in duplicate template-sync PRs - Primary success indicator</li> <li>\u2705 Single active template-sync PR - Only one open at any time</li> <li>\u2705 PR updates work correctly - Force-push and description updates succeed</li> <li>\u2705 No notification spam - Reduced GitHub notification volume</li> <li>\u2705 Clear PR progression - Updated PRs show complete change history</li> <li>\u2705 Automatic label management - <code>template-sync</code> label correctly applied</li> </ul>"},{"location":"adr/031-template-sync-duplicate-prevention/#testing-strategy","title":"Testing Strategy","text":"<p>Real-world validation through production fork repositories: - Monitor daily template-sync workflow executions - Verify single PR creation/update behavior - Confirm force-push updates work correctly - Validate PR description regeneration - Check duplicate comment prevention</p>"},{"location":"adr/031-template-sync-duplicate-prevention/#references","title":"References","text":"<ul> <li>ADR-024: Sync Workflow Duplicate Prevention Architecture - Original pattern</li> <li>ADR-012: Template Update Propagation Strategy - Template sync workflow</li> <li>ADR-011: Configuration-Driven Template Synchronization - Template sync foundation</li> <li>Evidence: Multiple Template Sync PRs - Production repository showing duplicate PR problem</li> </ul> <p>\u2190 ADR-030 |  Catalog</p>"},{"location":"adr/learnings/","title":"Learnings &amp; Insights","text":"<p>Living Document</p> <p>These learnings represent accumulated wisdom from building, deploying, and maintaining a complex fork management system. They serve as guideposts for future development and as context for understanding the current architecture.</p>"},{"location":"adr/learnings/#the-power-of-isolation","title":"The Power of Isolation","text":"<p> Learning</p> <p>Complex integration problems become manageable when properly isolated. Adding isolation stages doesn't slow teams down, it accelerates them by preventing cascade failures.</p> <p>The system runs upstream sync on a schedule, creating a PR to <code>fork_upstream</code>. You control when to merge\u2014batching multiple changes or merging immediately. Once merged, the cascade automatically moves changes to <code>fork_integration</code> for validation. If builds pass, changes flow to <code>main</code>. If validation fails, the issue is isolated and fixed without blocking the team. Main stays protected and the team keeps shipping.</p> <pre><code>graph LR\n    A[Scheduled Sync] --&gt;|Creates PR| B[fork_upstream]\n    B --&gt;|You decide when| C{Merge?}\n    C --&gt;|Yes| D[fork_integration]\n    C --&gt;|Wait| B\n    D --&gt;|Validate| E{Build OK?}\n    E --&gt;|Pass| F[main]\n    E --&gt;|Fail| G[Fix in isolation]\n    G --&gt;|Retry| D\n    F --&gt;|Team keeps shipping| H[Production]\n\n    style B fill:#e1f5ff\n    style D fill:#fff4e1\n    style F fill:#e8f5e9\n    style G fill:#ffebee</code></pre> <p>The Airlock Pattern</p> <p>Think of <code>fork_integration</code> as an isolation airlock. Upstream changes enter the chamber where it is prepared for \"decompression\" (breaking changes). Breach detected? Fix it, while crews in main chamber continue to work. Only proven-safe changes pass through into main.</p> Branch Purpose Can Break? Team Impact <code>fork_upstream</code> Pure mirror No Zero - accumulates until you're ready <code>fork_integration</code> Validation workspace Yes Zero - isolated from production <code>main</code> Protected production Never Zero - only receives validated changes <p>Team Impact: When integration breaks, engineers fix, feature flag, or add integration necessary while others continue shipping. If main breaks, everyone must stop.</p>"},{"location":"adr/learnings/#managing-engineering-systems-across-many-repositories","title":"Managing Engineering Systems Across Many Repositories","text":"<p> Learning</p> <p>Managing engineering systems (workflows, actions, configs) across many repositories requires separating shared logic from instance-specific data. One central repository controls the engineering system; other repositories receive updates via PR.</p> <p>The Challenge: You have many different repositories. Each needs the same workflows (sync, cascade, build, release) but different upstream sources, labels, and settings. How do you improve workflows without manually updating each repository?</p> <p>The Pattern (Phone Home):</p> <pre><code>graph LR\n    A[Central Management]\n\n    B[Fork: repo-1 ]\n    C[Fork: repo-2 ]\n    D[Fork: repo-n ]\n\n    B --&gt;|Weekly &lt;br/&gt;check | A\n    C --&gt;|Weekly &lt;br/&gt;check | A\n    D --&gt;|Weekly &lt;br/&gt;check | A\n\n    style A fill:#e8f5e9\n    style B fill:#e1f5ff\n    style C fill:#e1f5ff\n    style D fill:#e1f5ff</code></pre> <p>Separation Strategy:</p> Type Lives In Controlled By Example Logic Template workflows Template owner How to sync, how to cascade, how to build Data Fork config files Fork owner Which upstream URL, which files to sync, which labels <p>How It Works:</p> <ol> <li>You fix a bug in <code>sync.yml</code> \u2192 commit to central template</li> <li>Weekly sync creates PRs in all repositories</li> <li>Repository owners control when to merge \u2192 Review changes, merge when ready</li> <li>Logic improves everywhere; data stays repository-specific</li> </ol> <p>Key Insight</p> <p>Externalizing repository-specific values (upstream URLs, file patterns, labels) into config files enables engineering system evolution without merge conflicts. Pull-based distribution via PR gives repository owners full control over timing. Cost of indirection &lt; cost of manually synchronizing many repositories.</p>"},{"location":"adr/learnings/#separation-of-concerns-wins","title":"Separation of Concerns Wins","text":"<p> Learning</p> <p>Splitting complex operations into focused components improves reliability and maintainability.</p> <p>Decision Framework: When to Split Workflows</p> <p>Ask: \"What are the distinct responsibilities?\"</p> Indicator Example Solution Multiple failure modes Init workflow handles user input AND system config Split into <code>init.yml</code> + <code>init-complete.yml</code> Different execution contexts Template development vs fork production Separate directories (ADR-015) Conflicting requirements User interaction vs automation Isolate human touchpoints <p>Pattern: When a workflow becomes complex, identify distinct responsibilities and split them.</p> <p>Impact: Both workflows become simpler, more testable, and easier to debug. Template-workflows separation eliminated workflow pollution entirely.</p>"},{"location":"adr/learnings/#safety-net-pattern-the-sweeper","title":"Safety Net Pattern: The Sweeper","text":"<p> Learning</p> <p>Human-triggered workflows need automated sweeper processes to catch missed triggers and enable self-healing recovery.</p> <p>The Problem:</p> <ul> <li>You merge upstream sync PR but forget to trigger cascade \u2192 Changes stuck</li> <li>Cascade fails due to temporary issue, you fix it \u2192 How does it retry?</li> </ul> <p>The Solution: <code>cascade-monitor.yml</code> runs every 6 hours as a sweeper:</p> <ol> <li>Checks for pending work: Compares <code>fork_upstream</code> vs <code>fork_integration</code> branches</li> <li>Detects missed triggers: Finds merged sync PRs without cascade started</li> <li>Auto-triggers cascade: Starts integration automatically when found</li> <li>Enables recovery: When humans remove <code>human-required</code> label after fixes, sweeper detects and retries</li> </ol> <p>Pattern: For human-triggered critical workflows, add scheduled sweeper that detects incomplete state and auto-triggers recovery.</p> <p>Safety Net, Not Replacement</p> <p>The sweeper is a fallback for human error or recovery scenarios. Primary path is still manual triggering after review. Sweeper ensures nothing gets permanently stuck.</p>"},{"location":"adr/learnings/#the-missing-yaml-problem","title":"The \"Missing YAML\" Problem","text":"<p> Learning</p> <p>Sometimes the simplest solution provides dramatic improvements.</p> <p>The Problem: Workflows not found when using <code>pull_request</code> events because init workflows don't exist in the PR branch yet.</p> <p>The Solution: Switch to <code>pull_request_target</code> which reads workflows from the target branch.</p> Event Type Workflow Source Use Case <code>pull_request</code> PR branch Standard PR validation <code>pull_request_target</code> Target branch Bootstrap scenarios <p>Takeaway: When facing GitHub Actions issues, thoroughly understand event contexts and workflow execution environments before building complex workarounds. One line of configuration solved weeks of reliability issues.</p>"},{"location":"adr/learnings/#ai-as-enhancement-not-dependency","title":"AI as Enhancement, Not Dependency","text":"<p> Learning</p> <p>AI capabilities should improve workflows without creating critical dependencies.</p> <p>Implementation Strategy:</p> <ul> <li>Core functionality operates reliably when AI services unavailable</li> <li>AI-enhanced PR descriptions fall back to structured templates</li> <li>Conflict analysis succeeds with or without AI suggestions</li> <li>AIPR with Azure Foundry provides single, reliable AI integration</li> </ul> <p>Pattern: Build resilient fallbacks first, then layer on AI enhancements.</p> <p>Current Approach: Using AIPR tool with Azure Foundry exclusively. Detection logic checks for Azure API credentials and gracefully falls back to static descriptions when unavailable. This single-provider approach simplifies configuration while maintaining reliability through comprehensive fallback handling.</p> <p>Impact: Teams trust and adopt workflows that work consistently, with AI providing value when available rather than creating blocking dependencies.</p>"},{"location":"adr/learnings/#human-centric-automation-philosophy","title":"Human-Centric Automation Philosophy","text":"<p> Learning</p> <p>The most successful automation enhances human capabilities rather than replacing human judgment.</p> <p>Applied Pattern:</p> <ul> <li>Cascade workflow: Manual triggering after sync PR review gives teams explicit control over timing and batching</li> <li>Conflict analysis: AI provides guidance and categorization; humans make resolution decisions</li> <li>Release decisions: Automation suggests version bumps; humans approve before release</li> </ul> <p>Takeaway: Automation should handle toil and provide analysis; humans should make decisions with clear context and control.</p> <p>Impact: Teams trust and adopt workflows that respect their expertise rather than treating them as obstacles to overcome.</p>"},{"location":"adr/learnings/#conflict-category-analysis","title":"Conflict Category Analysis","text":"<p> Learning</p> <p>Most conflicts fall into predictable, manageable categories with clear resolution strategies.</p> <p>Category Breakdown:</p> Category Frequency Risk Level Resolution Strategy Structural ~40% Low Preserve local structure while adopting upstream organization Functional ~35% High Preserve local enhancement intent while adopting improvements Merge Artifacts ~25% Medium Focus on testing behavior, not just compilation <p>Resolution Philosophy: Always understand the intent behind local modifications. Test functionality thoroughly\u2014successful compilation doesn't guarantee correct integration.</p> <p>Practical Impact: Categorizing conflicts reduces time-to-understanding and provides clear resolution approaches for each type.</p>"},{"location":"adr/learnings/#detection-vs-resolution","title":"Detection vs Resolution","text":"<p> Learning</p> <p>Detecting conflicts is valuable even when you can't automatically resolve them.</p> <p>Value Provided:</p> <ul> <li>Structured analysis and categorization</li> <li>Significantly reduced time-to-understanding</li> <li>Guided resolution even when manual work required</li> </ul> <p>Pattern: Build detection and analysis layers first; automated resolution emerges as patterns become clear over time.</p> <p>Takeaway: The value lies in guidance and structure, not full automation. AI-enhanced conflict detection provides immediate value even without automated fixes.</p>"},{"location":"adr/learnings/#backward-compatibility-is-non-negotiable","title":"Backward Compatibility is Non-Negotiable","text":"<p> Learning</p> <p>Template changes must work seamlessly with existing fork instances. The cost of supporting backward compatibility is far less than the cost of breaking production instances.</p> <p>Requirements:</p> <ul> <li>Migration strategies for breaking changes</li> <li>Clear communication to affected users</li> <li>Often automated migration tooling</li> <li>Testing against multiple real instances before deployment</li> </ul> <p>Pattern: Every template change requires validation against real fork instances, not just the template repository.</p> <p>Impact: Production fork instances continue operating smoothly through template evolution without surprise breakage or emergency fixes.</p>"},{"location":"adr/learnings/#template-pollution-problem","title":"Template Pollution Problem","text":"<p> Learning</p> <p>Mixing template development and fork production workflows creates confusion and pollutes fork repositories with infrastructure they don't need.</p> <p>The Solution: Directory Separation</p> <ul> <li><code>.github/workflows/</code> - Template infrastructure (this repository only)</li> <li><code>.github/template-workflows/</code> - Fork production workflows (copied during initialization)</li> </ul> <p>Pattern: Clear separation between \"infrastructure for this repository\" and \"infrastructure we deploy to instances.\"</p> <p>Takeaway: What seems obvious in retrospect emerged from painful experience. Separate contexts require separate locations.</p>"},{"location":"adr/learnings/#bootstrap-problem-local-actions-solution","title":"Bootstrap Problem: Local Actions Solution","text":"<p> Learning</p> <p>Extract critical logic to local actions that ship with the template instead of building complex workflow self-update mechanisms.</p> <p>The Problem: New repository workflows execute from the initial template state, potentially missing critical bug fixes (like <code>--allow-unrelated-histories</code>) made after template creation.</p> <p>The Solution: Extract critical initialization logic to <code>.github/local-actions/</code> which are part of the template repository and copied during initialization. Since these actions exist in the initial commit, fixes are automatically available without workflow self-update complexity.</p> <p>Implementation Example: <pre><code># .github/local-actions/merge-with-theirs-resolution/action.sh\ngit merge \"$SOURCE_BRANCH\" --allow-unrelated-histories --no-ff -X theirs\n</code></pre></p> <p>Why Local Actions Win:</p> Benefit Description Always Available Part of initial commit, no bootstrap needed No External Dependencies Self-contained within repository Testable Can test independently of workflows Cleaner No workflow self-modification complexity Maintainable Single source of truth <p>Pattern: For template infrastructure that needs to evolve, extract critical logic to local actions rather than building self-update mechanisms.</p> <p>Impact: Initialization uses latest fixes immediately without complex bootstrap patterns. See ADR-007 and ADR-028 for detailed rationale.</p>"},{"location":"adr/learnings/#labels-as-workflow-state-machines","title":"Labels as Workflow State Machines","text":"<p> Learning</p> <p>GitHub labels provide reliable, queryable state management for multi-stage workflows. Use labels to track state and control automation flow.</p> <p>How Labels Enable Automation:</p> Label Workflow Behavior Human Signal <code>cascade-active</code> Automation running, do not interfere Work in progress <code>human-required</code> Automation paused, waiting for human action Please investigate and fix <code>cascade-blocked</code> Automation stopped due to conflicts/failures Blocked on issue <code>validated</code> Passed all checks, ready for next stage Safe to proceed <p>State Transitions Example (Cascade): <pre><code>upstream-sync \u2192 cascade-active \u2192 validated \u2192 (closed when merged to main)\n                     \u2193\n                cascade-blocked \u2192 human-required \u2192 (human fixes) \u2192 cascade-active (retry)\n</code></pre></p> <p>Why Labels Work:</p> <ul> <li>Queryable: <code>gh issue list --label \"human-required\"</code> finds all paused work</li> <li>Reliable: Never fail due to API issues or permission problems</li> <li>Machine-Readable: Workflows make decisions based on label presence</li> <li>Human-Readable: Team sees state at a glance</li> </ul> <p>Pattern: Use labels to represent workflow state. When automation needs to pause for human intervention, add <code>human-required</code>. When humans signal \"ready to retry,\" remove it and let the sweeper detect and continue.</p> <p>Impact: Workflows can pause, wait for humans, and automatically resume without complex state management infrastructure.</p>"},{"location":"adr/learnings/#issue-lifecycle-tracking","title":"Issue Lifecycle Tracking","text":"<p> Learning</p> <p>Issues make excellent state machines for multi-stage workflows spanning hours or days.</p> <p>Capabilities Provided:</p> <ul> <li>Audit Trail: Full history for debugging and compliance</li> <li>Progress Updates: Clear updates stakeholders can understand</li> <li>Queryable State: Automation can track and react to changes</li> <li>Handoff Points: Explicit transitions between workflow stages</li> </ul> <p>Pattern: For complex workflows with multiple stages, use issues as state containers rather than workflow-local variables that disappear between runs.</p> <p>Practical Impact: Complete visibility into cascade progression with automated state tracking and human-readable progress updates.</p>"},{"location":"adr/learnings/#duplicate-prevention-architecture","title":"Duplicate Prevention Architecture","text":"<p> Learning</p> <p>State persistence between workflow runs prevents duplicate work and notification fatigue.</p> <p>Storage Mechanism: Git config provides lightweight, reliable storage for workflow state.</p> <p>Capabilities Enabled:</p> <ul> <li>Skip creating duplicate PRs for unchanged upstream</li> <li>Update existing branches when upstream advances</li> <li>Clean up abandoned sync branches automatically</li> </ul> <p>Pattern: Workflows often need persistent state between runs; git config provides the perfect storage mechanism without external dependencies.</p> <p>Impact: Smart decision-making eliminates duplicate PRs and unnecessary noise while keeping sync branches current.</p>"},{"location":"adr/learnings/#meta-commit-strategy-for-versioning","title":"Meta Commit Strategy for Versioning","text":"<p> Learning</p> <p>You can have both complete upstream history AND automated version management\u2014they're not mutually exclusive.</p> <p>The Approach: Layer automation-friendly metadata on top of preserved original data rather than transforming or losing the original.</p> <p>Benefits Comparison:</p> Aspect Traditional Meta Commit Approach History Squashed/modified Complete preservation Debugging Partial context Full upstream history Versioning Manual tracking Automated Release Please Fallback None Conservative auto-versioning <p>Pattern: Don't transform or lose original data\u2014add metadata layers instead.</p> <p>Practical Impact: Full debugging capability with complete upstream history while enabling automated version management and proper release correlation.</p>"},{"location":"adr/learnings/#dependabot-integration-complexity","title":"Dependabot Integration Complexity","text":"<p> Learning</p> <p>Automated dependency updates need workflow validation and auto-merge criteria\u2014aggressive automation without guardrails creates problems.</p> <p>Strategy:</p> Update Type SLA Auto-Merge Criteria Security patches 48 hours Tests pass + limited scope Feature updates Standard review Manual review required Grouped updates Reduced noise Related dependencies only <p>Pattern: Define clear auto-merge criteria (security patches, passing tests, limited scope) before enabling aggressive automation.</p> <p>Impact: Security updates get fast-tracked with 48-hour SLA while feature updates follow careful review, balancing speed with safety.</p>"},{"location":"adr/learnings/#monitor-everything-from-day-one","title":"Monitor Everything From Day One","text":"<p> Learning</p> <p>Comprehensive monitoring enables rapid issue identification and resolution\u2014but it must be built in from the beginning, not bolted on later.</p> <p>Built In From Start:</p> <ul> <li>Health checks and status reporting</li> <li>SLA tracking with automated alerts</li> <li>Automated escalation workflows</li> <li>Complete audit trails</li> </ul> <p>Pattern: Build observability into workflows as core functionality, not afterthought instrumentation.</p> <p>Impact: This design choice paid dividends in operational reliability. Issues are identified and resolved quickly because monitoring was designed in, not retrofitted.</p>"},{"location":"adr/learnings/#documentation-as-code-review","title":"Documentation as Code Review","text":"<p> Learning</p> <p>Writing comprehensive documentation often reveals design flaws before implementation begins.</p> <p>The Process:</p> <ol> <li>Articulate rationale and context</li> <li>Explore alternative approaches</li> <li>Document consequences and tradeoffs</li> <li>Discover better designs during writing</li> </ol> <p>Pattern: Write the ADR before implementing major decisions; treat documentation as a design tool, not just historical recording.</p> <p>Practical Impact: Better designs discovered during documentation phase rather than expensive refactoring during or after implementation.</p>"},{"location":"adr/learnings/#the-human-required-label-strategy","title":"The Human-Required Label Strategy","text":"<p> Learning</p> <p>Username resolution is fragile; label-based workflow management is robust and reliable.</p> <p>The Problem: Organization names can't be assigned to issues. User accounts change. API failures block workflows.</p> <p>The Solution: Labels have none of these problems and provide better filtering capabilities.</p> <p>Pattern: Design for reliability over convenience\u2014labels may seem less direct than assignees, but they work consistently across all scenarios.</p> <p>Impact: Workflows operate reliably without fragile user resolution dependencies or API failure blocking.</p>"},{"location":"adr/learnings/#future-directions","title":"Future Directions","text":"<p>Based on accumulated learnings, these areas show promise for continued evolution:</p> Pattern RecognitionCross-Repository IntelligenceDeeper AI Integration <p>Machine Learning Opportunities</p> <p>Learning from resolved conflicts could enable:</p> <ul> <li>Automated resolution suggestions for common patterns</li> <li>Confidence scoring for resolution approaches</li> <li>Learning from team-specific resolution preferences</li> </ul> <p>Impact: Progressively better automated assistance as the system learns from real conflict resolutions.</p> <p>Multi-Fork Coordination</p> <p>Managing multiple related fork instances could leverage:</p> <ul> <li>Dependency analysis across forks</li> <li>Coordinated update orchestration</li> <li>Template ecosystem versioning</li> </ul> <p>Impact: Intelligent coordination across the entire OSDU service portfolio rather than isolated per-repository management.</p> <p>Enhanced AI Capabilities</p> <p>Building on successful AI enhancement patterns:</p> <ul> <li>Proactive analysis of upstream changes before sync</li> <li>Integration testing suggestions for conflicts</li> <li>Advanced context awareness for complex scenarios</li> </ul> <p>Impact: AI provides even more valuable guidance while maintaining human control and reliable fallbacks.</p>"},{"location":"adr/learnings/#start-simple-evolve-systematically","title":"Start Simple, Evolve Systematically","text":"<p> Learning</p> <p>The most successful features began with minimal viable implementations and evolved based on real usage feedback.</p> <p>Anti-Pattern: Over-engineering early wastes effort on wrong assumptions.</p> <p>Impact: Focus effort on solving real problems discovered through usage rather than theoretical problems that may never materialize.</p>"},{"location":"adr/learnings/#real-world-testing-beats-assumptions","title":"Real-World Testing Beats Assumptions","text":"<p> Learning</p> <p>Template changes tested only against the template repository often failed when deployed to real fork instances.</p> <p>Pattern: Real-world scenarios reveal edge cases that perfect plans miss.</p> <p>Takeaway: Budget time for testing against multiple real fork instances before declaring template changes complete.</p>"},{"location":"adr/learnings/#clear-error-messages-are-feature-requirements","title":"Clear Error Messages Are Feature Requirements","text":"<p> Learning</p> <p>Actionable error messages with recovery instructions aren't nice-to-have polish\u2014they're essential for reliable automation.</p> <p>Impact: Users can resolve issues themselves with clear guidance rather than requiring expert intervention for every problem.</p> <p>Pattern: Budget time for clear error messages as core functionality, not optional polish added if time permits.</p>"},{"location":"adr/learnings/#bash-script-extraction-enables-testing","title":"Bash Script Extraction Enables Testing","text":"<p> Learning</p> <p>Extracting embedded bash scripts into separate .sh files with action.yml wrappers dramatically improves maintainability and testability.</p> <p>The Problem: Embedded bash scripts in workflows (~3,500 lines across 9 files) couldn't be tested locally, led to code duplication, and made debugging difficult.</p> <p>The Solution: Extract scripts to <code>.github/actions/*/script.sh</code> with composite action wrappers (<code>action.yml</code>).</p> <p>Benefits Achieved:</p> Benefit Description Local Testing Run <code>./script.sh</code> locally without triggering workflows Code Reuse Eliminate duplication (e.g., LLM detection duplicated 2x, now shared) Better Diffs Script changes separate from workflow structure changes in git Debuggability Debug bash logic with standard tools (shellcheck, bash -x) 40% Size Reduction Workflows became dramatically shorter and clearer <p>Implementation Pattern: <pre><code>.github/actions/llm-provider-detect/\n\u251c\u2500\u2500 action.yml          # Composite action wrapper\n\u251c\u2500\u2500 detect-provider.sh  # Testable bash script\n\u2514\u2500\u2500 README.md           # Usage and testing docs\n</code></pre></p> <p>Usage in Workflows: <pre><code>- uses: ./.github/actions/llm-provider-detect\n  id: llm\n  env:\n    AZURE_API_KEY: ${{ secrets.AZURE_API_KEY }}\n</code></pre></p> <p>Pattern: When bash scripts exceed ~20 lines or need reuse, extract to separate files with action wrappers. See ADR-028 for comprehensive rationale.</p> <p>Impact: Complex logic can be tested, debugged, and maintained like regular code rather than embedded workflow snippets.</p>"},{"location":"adr/learnings/#configuration-flexibility-compounds-value","title":"Configuration Flexibility Compounds Value","text":"<p> Learning</p> <p>Every configuration option added multiplies the template's applicability across different scenarios and use cases.</p> <p>ROI: The extra design effort pays back many times over through broader adoption and fewer special-case implementations.</p> <p>Pattern: Ask \"could someone need this to work differently?\" when making design decisions. If yes, make it configurable.</p> <p>Impact: Template serves diverse scenarios without forking or modification, dramatically increasing reusability.</p>"},{"location":"adr/list/","title":"ADR Catalog","text":"<p>Note: This file provides a quick-reference table format of all ADRs with expandable summaries. It is specifically designed for AI agents and automated tools that need rapid access to ADR metadata and high-level context. For human-readable navigation with categorization and search, see index.md.</p> <p>Architecture Decision Records for Fork Management Template</p>"},{"location":"adr/list/#index","title":"Index","text":"ID Title Details 001 Three-Branch Fork Management Strategy ADR-001 002 GitHub Actions-Based Automation ADR-002 003 Template Repository Pattern ADR-003 004 Release Please for Version Management ADR-004 005 Automated Conflict Management Strategy ADR-005 006 Two-Workflow Initialization Pattern ADR-006 007 Initialization Workflow Bootstrap Pattern ADR-007 008 Centralized Label Management Strategy ADR-008 009 Asymmetric Cascade Review Strategy ADR-009 010 YAML-Safe Shell Scripting in GitHub Actions ADR-010 011 Configuration-Driven Template Synchronization ADR-011 012 Template Update Propagation Strategy ADR-012 013 Reusable GitHub Actions Pattern for PR Creation ADR-013 014 AI-Enhanced Development Workflow Integration ADR-014 015 Template-Workflows Separation Pattern ADR-015 016 Initialization Security Handling ADR-016 017 MCP Server Integration Pattern ADR-017 018 Fork-Resources Staging Pattern ADR-018 019 Cascade Monitor Pattern ADR-019 020 Human-Required Label Strategy ADR-020 021 Pull Request Target Trigger Pattern ADR-021 022 Issue Lifecycle Tracking Pattern ADR-022 023 Meta Commit Strategy for Release Please ADR-023 024 Sync Workflow Duplicate Prevention Architecture ADR-024 025 Java/Maven Build Architecture ADR-025 026 Dependabot Security Update Strategy ADR-026 027 Documentation Generation Strategy with MkDocs ADR-027 028 Workflow Script Extraction Pattern ADR-028 029 GitHub App Authentication Strategy ADR-029 030 CodeQL Summary Job Pattern ADR-030 031 Template Sync Duplicate Prevention Pattern ADR-031"},{"location":"adr/list/#overview","title":"Overview","text":"<p>These Architecture Decision Records document the key design choices made in the Fork Management Template project. Each ADR explains the context, decision, rationale, and consequences of significant architectural choices that enable automated management of long-lived forks of upstream repositories.</p>"},{"location":"adr/list/#quick-reference","title":"Quick Reference","text":""},{"location":"adr/list/#core-architecture-decisions","title":"Core Architecture Decisions","text":"<p>Three-Branch Strategy (ADR-001) - <code>main</code>: Stable production branch - <code>fork_upstream</code>: Tracks upstream changes - <code>fork_integration</code>: Conflict resolution workspace</p> <p>Automation Framework (ADR-002) - GitHub Actions for all workflow automation (init, sync, cascade, validate, build, release) - Issue lifecycle tracking and duplicate prevention for upstream sync - Modular workflow design with separation of concerns</p> <p>Two-Workflow Initialization (ADR-006) - Separated user interaction from repository setup - Issue-driven configuration with progress updates - Simplified state management and error handling</p> <p>Workflow Bootstrap Pattern (ADR-007) - Self-updating initialization workflows - Ensures latest fixes are always available - Solves the template version bootstrap problem</p> <p>Centralized Label Management (ADR-008) - All labels defined in <code>.github/labels.json</code> - Created during repository initialization - Single source of truth for label definitions</p> <p>Version Management (ADR-004) - Release Please with Conventional Commits - Automated semantic versioning - Upstream version reference tracking</p> <p>Configuration-Driven Template Sync (ADR-011) - <code>.github/sync-config.json</code> defines what files get synced - Selective synchronization between template and forked repositories - Automated cleanup of template-specific content</p> <p>Template Update Propagation (ADR-012) - Daily automated template updates via <code>template-sync.yml</code> - AI-enhanced PR descriptions and human-centric manual cascade instructions - Solves template drift problem for forked repositories</p> <p>Reusable GitHub Actions (ADR-013) - Custom composite action for AI-enhanced PR creation - DRY principle for common workflow functionality - Centralized AI integration with multiple provider support</p> <p>AI-Enhanced Workflows (ADR-014) - Multi-provider AI support (Azure OpenAI, OpenAI) - AI-powered security analysis and PR description generation</p> <p>Template-Workflows Separation (ADR-015) - Clean separation between template development and fork production workflows - <code>.github/workflows/</code> for template development (not copied) - <code>.github/template-workflows/</code> for fork production workflows (copied during init) - Eliminates workflow pollution in fork repositories</p> <p>Initialization Security Handling (ADR-016) - Temporarily disables push protection during initialization - Allows syncing upstream repositories with historical secrets - Re-enables full security immediately after initialization - Simple and maintainable approach without complex error handling</p> <p>MCP Server Integration Pattern (ADR-017) - Automatic MCP server configuration for GitHub Copilot Agent - Maven MCP Server provides AI-enhanced dependency management - Configuration stored in fork-resources for template-wide deployment - Read-only MCP servers for security and Maven Central integration</p> <p>Fork-Resources Staging Pattern (ADR-018) - <code>.github/fork-resources/</code> as staging area for specialized template deployment - Templates requiring custom deployment logic (issue templates, AI configs, prompts) - Two-stage deployment: template staging \u2192 fork final locations - Integrates with sync configuration for automatic updates</p> <p>Cascade Monitor Pattern (ADR-019) - Human-centric cascade: manual triggering as primary path, monitor as safety net - Issue lifecycle tracking with label-based state management - Health monitoring detects missed triggers and conflict escalation - Explicit human control over integration timing with clear instructions</p> <p>Human-Required Label Strategy (ADR-020) - Label-based task management replaces unreliable assignee approach - <code>human-required</code> label marks items needing attention without username resolution - Team-flexible filtering and priority systems via label combinations - Works across all repository instances without GraphQL API failures</p> <p>Pull Request Target Trigger Pattern (ADR-021) - Solves \"missing YAML\" problem for cascade triggering - Uses <code>pull_request_target</code> to read workflow from main branch - Single-line change for dramatic reliability improvement - Maintains same security model as PAT approach</p> <p>Issue Lifecycle Tracking Pattern (ADR-022) - Comprehensive tracking of cascade state through GitHub issues - Label-based state management for machine and human readability - Complete audit trail from upstream sync to production deployment - Integration with human-centric cascade pattern</p> <p>Meta Commit Strategy for Release Please (ADR-023) - Preserves complete upstream commit history while enabling automated versioning - AIPR analyzes commit ranges to generate conventional meta commits - Fallback to conservative <code>feat:</code> commits when AI unavailable - Solves conflict between upstream non-conventional commits and Release Please requirements</p> <p>Sync Workflow Duplicate Prevention Architecture (ADR-024) - State-based duplicate detection using git config persistence - Smart decision matrix for handling all duplicate sync scenarios - Branch update strategy maintains human workflow continuity - Automatic cleanup of abandoned sync branches and state management</p> <p>Java/Maven Build Architecture (ADR-025) - Java 17 Temurin as standard runtime with Maven 3.9+ build tool - JaCoCo coverage reporting and GitLab Maven repository integration - Reusable GitHub Actions for consistent build implementation - Zero-configuration support for standard OSDU Java projects</p> <p>Dependabot Security Update Strategy (ADR-026) - Security-first configuration with 48-hour patch SLA - Grouped dependency updates to reduce PR noise - Conservative update policy for stability - Automated validation and auto-merge for safe updates</p> <p>Documentation Generation with MkDocs (ADR-027) - MkDocs Material theme for professional documentation site - Automatic publishing to GitHub Pages - Full-text search and mobile-responsive design - ADRs automatically included in documentation</p> <p>Workflow Script Extraction Pattern (ADR-028) - Extract embedded bash scripts to <code>.github/actions/</code> for local testing - Composite action wrappers enable parameter passing and reuse - Leverages existing sync infrastructure for propagation to forks - 40% reduction in workflow file sizes with eliminated duplication</p> <p>GitHub App Authentication Strategy (ADR-029) - Replace PATs with GitHub Apps for workflow automation - Short-lived tokens (1 hour) vs long-lived PATs (90+ days) - Microsoft-compliant authentication eliminating PAT dependency - Centralized management not tied to individual employees - Required for release automation and repository initialization under org security policies</p> <p>CodeQL Summary Job Pattern (ADR-030) - Summary job aggregates analysis results for required status checks - Enables branch protection rules with CodeQL regardless of language detection - Fails when zero analyzable languages detected for real repository issues - Consolidates multiple language analysis jobs into single mergeable status check</p> <p>Template Sync Duplicate Prevention Pattern (ADR-031) - Inline PR detection prevents duplicate template-sync PRs - Same architectural pattern as upstream sync (ADR-024) with simpler implementation - Label-based tracking with <code>template-sync</code> label for PR identification - Branch reuse with force-push when template advances - Eliminates daily accumulation of open template-sync PRs</p>"},{"location":"architecture/ai_integration/","title":"AI Integration Architecture","text":"<p>The OSDU SPI Fork Management system incorporates sophisticated AI capabilities to enhance development workflows while maintaining reliability and cost-effectiveness. This integration provides intelligent analysis, automated documentation generation, and enhanced decision-making support throughout the fork management lifecycle.</p>"},{"location":"architecture/ai_integration/#ai-integration-philosophy","title":"AI Integration Philosophy","text":"<ul> <li> <p> Enhancement, Not Dependency</p> <p>AI capabilities enhance existing workflows without creating dependencies. All core functionality operates normally when AI services are unavailable, ensuring system reliability.</p> </li> </ul> <ul> <li> <p> Azure Foundry Primary</p> <p>Standardized on Azure Foundry for enterprise compliance, Microsoft ecosystem integration, and consistent AI capabilities with graceful template fallback.</p> </li> </ul> <ul> <li> <p> Secure by Design</p> <p>API keys and sensitive data are handled through secure GitHub secrets management with proper access controls and audit trails.</p> </li> </ul> <ul> <li> <p> Cost-Conscious Usage</p> <p>Intelligent usage patterns, caching, and fallback strategies control API costs while maximizing value from AI capabilities.</p> </li> </ul>"},{"location":"architecture/ai_integration/#ai-provider-architecture","title":"AI Provider Architecture","text":"<pre><code>graph TD\n    A[Workflow Trigger] --&gt; B[AI Provider Detection]\n    B --&gt; C{Azure Foundry Available?}\n\n    C --&gt;|Yes| D[Azure API Access]\n    C --&gt;|No| E[Fallback Templates]\n\n    D --&gt; F{API Success?}\n    F --&gt;|Yes| G[AI-Enhanced Output]\n    F --&gt;|No| E\n\n    E --&gt; H[Template-Based Output]\n\n    style C fill:#f9f,stroke:#333,stroke-width:2px\n    style E fill:#ffd,stroke:#333,stroke-width:2px\n    style G fill:#dfd,stroke:#333,stroke-width:2px</code></pre>"},{"location":"architecture/ai_integration/#supported-ai-providers","title":"Supported AI Providers","text":"<p>The system uses Azure Foundry as the primary AI provider with graceful fallback to structured templates:</p> Provider Priority Integration Method Key Capabilities Typical Use Cases Azure Foundry Primary Azure API + Enterprise features Enterprise integration, compliance, GPT-4o access All AI-enhanced workflows Template Fallback Fallback Structured templates Consistent output, zero-cost operation When Azure unavailable"},{"location":"architecture/ai_integration/#ai-enhancement-points","title":"AI Enhancement Points","text":""},{"location":"architecture/ai_integration/#pull-request-descriptions","title":"Pull Request Descriptions","text":"<p>AI-generated PR descriptions provide comprehensive change analysis:</p> <pre><code># AI-powered PR description generation\n- Change categorization (feat, fix, chore, etc.)\n- Impact analysis\n- Security vulnerability assessment\n- Breaking change detection\n- Review recommendations\n</code></pre>"},{"location":"architecture/ai_integration/#commit-message-generation","title":"Commit Message Generation","text":"<p>Intelligent conventional commit messages from changesets:</p> <pre><code># AI analyzes changes and generates conventional commit\n# Input: Git diff\n# Output: \"feat(sync): add duplicate PR prevention logic\"\n</code></pre>"},{"location":"architecture/ai_integration/#security-analysis","title":"Security Analysis","text":"<p>AI-powered triage of vulnerability scans:</p> <pre><code># Trivy scan results \u2192 AI analysis \u2192 Actionable insights\n- Vulnerability severity assessment\n- Exploitation likelihood analysis\n- Mitigation recommendations\n- Priority ranking for remediation\n</code></pre>"},{"location":"architecture/ai_integration/#implementation-patterns","title":"Implementation Patterns","text":""},{"location":"architecture/ai_integration/#provider-detection-logic","title":"Provider Detection Logic","text":"<pre><code># Automatic provider detection based on available credentials\nUSE_LLM=false\nLLM_MODEL=\"\"\n\n# Check for Azure Foundry\nif [[ -n \"$AZURE_API_KEY\" ]] &amp;&amp; [[ -n \"$AZURE_API_BASE\" ]]; then\n  USE_LLM=true\n  LLM_MODEL=\"azure\"\n  echo \"Using Azure Foundry for AI tasks\"\nelse\n  echo \"No Azure Foundry configured - using templates\"\nfi\n</code></pre>"},{"location":"architecture/ai_integration/#fallback-mechanisms","title":"Fallback Mechanisms","text":"<p>Robust fallback ensures workflow continuity:</p> <pre><code>graph TD\n    A[AI Task Request] --&gt; B{Azure API Key?}\n    B --&gt;|Yes| C[Use Azure Foundry]\n    B --&gt;|No| D[Use Template Fallback]\n\n    C --&gt; E{API Success?}\n    E --&gt;|Yes| F[Return AI Result]\n    E --&gt;|No| D\n\n    D --&gt; G[Return Template Result]\n\n    style D fill:#ffd,stroke:#333,stroke-width:4px\n    style G fill:#dfd,stroke:#333,stroke-width:2px</code></pre>"},{"location":"architecture/ai_integration/#security-considerations","title":"Security Considerations","text":""},{"location":"architecture/ai_integration/#api-key-management","title":"API Key Management","text":"<pre><code># GitHub Secrets Configuration\nsecrets:\n  AZURE_API_KEY:         # Azure Foundry API key (required for AI features)\n  AZURE_API_BASE:        # Azure endpoint URL (required for AI features)\n  AZURE_API_VERSION:     # API version (required for AI features)\n\n# Access Control\n- Repository-level secrets\n- Environment-specific configurations\n- Audit logging for all AI API usage\n- Rotation reminders via GitHub notifications\n</code></pre>"},{"location":"architecture/ai_integration/#data-privacy","title":"Data Privacy","text":"<pre><code># Data handling practices\n- No sensitive data in AI prompts\n- Sanitize repository contents before AI processing\n- Use ephemeral environments for AI operations\n- Clear AI context after each workflow run\n</code></pre>"},{"location":"architecture/ai_integration/#related-documentation","title":"Related Documentation","text":"<ul> <li>ADR-014: AI-Enhanced Development Workflow</li> <li>Workflow System Architecture</li> <li>Security Architecture</li> </ul>"},{"location":"architecture/overview/","title":"Overview","text":""},{"location":"architecture/overview/#principles","title":"Principles","text":"<p>The OSDU SPI Fork Management system is built on a foundation of template-driven automation that prioritizes zero-configuration deployment, intelligent automation, and continuous maintenance. The architecture leverages GitHub's native capabilities to provide fork management without external dependencies.</p> <ul> <li> <p> Self Configuring</p> <p>Template repositories automatically adapt to specific upstream sources through intelligent initialization workflows that detect and configure appropriate settings.</p> </li> <li> <p> Safety First</p> <p>Multiple validation points prevent unstable code promotion through the three-branch strategy, with branch protection rules and automated security scanning.</p> </li> <li> <p> Event Driven</p> <p>Automated response to repository changes, schedules, and external triggers enables real-time synchronization and conflict management.</p> </li> <li> <p> Scalable</p> <p>Support unlimited repository deployments with consistent patterns, enabling enterprise-wide adoption across multiple OSDU repository forks.</p> </li> </ul>"},{"location":"architecture/overview/#system-design","title":"System Design","text":"<p>The system implements a sophisticated template repository pattern that separates concerns:</p> <pre><code>graph TD\n    A[Template Repository] --&gt; B[Fork Instance 1]\n    A --&gt; C[Fork Instance 2]\n    A --&gt; D[Fork Instance N]\n\n    B --&gt; E[Upstream OSDU library]\n    C --&gt; F[Upstream OSDU legal]\n    D --&gt; G[Upstream OSDU storage]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style B fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style C fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style D fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px</code></pre> <p>Template Repository Pattern</p> <p>This pattern separates template development from instance operation, enabling scalable management of unlimited fork deployments while maintaining consistent automation patterns.</p> <p>Template Development Context includes <code>.github/workflows/</code> for template development and maintenance workflows, template-specific documentation and configuration, and update propagation mechanisms with testing frameworks.</p> <p>Fork Instance Context encompasses <code>.github/template-workflows/</code> for production fork management workflows, instance-specific configuration and customization, and upstream-specific synchronization and integration.</p> <p>Event Driven Architecture enables intelligent automation through GitHub's native event system. The system responds to scheduled events (daily sync), change events (PR validation), and manual events (on-demand resolution), providing comprehensive lifecycle management.</p> <p>Architectural Success Pattern</p> <p>The combination of template-driven deployment with event-driven automation creates a self-managing system that scales across unlimited fork instances while maintaining consistent behavior and zero-configuration operation.</p> <p>System Components provide comprehensive automation through three specialized layers that work together to deliver fork management capabilities.</p> <ul> <li> <p> Three-Branch Strategy</p> <p>Isolated conflict resolution and controlled integration from upstream through staging to production environments.</p> <p> Learn about branch strategy</p> </li> </ul> <ul> <li> <p> Workflow System</p> <p>Event-driven automation with AI-enhanced capabilities for synchronization, validation, and release management.</p> <p> Explore workflow architecture</p> </li> </ul> <ul> <li> <p> AI Integration</p> <p>Multi-provider AI support with intelligent analysis, automated documentation, and fallback strategies.</p> <p> Discover AI capabilities</p> </li> </ul>"},{"location":"architecture/overview/#enterprise-capabilities","title":"Enterprise Capabilities","text":"<p>The system delivers enterprise-grade features through comprehensive security, proven scalability patterns, and native GitHub integration. Branch protection strategies ensure production stability while enabling flexible conflict resolution workflows.</p> <p>Enterprise Ready</p> <p>Production deployments benefit from automated security scanning, unlimited scalability through template propagation, and seamless integration with existing development toolchains and AI services.</p>"},{"location":"architecture/three_branch_strategy/","title":"Three-Branch Strategy","text":"<p>The three-branch strategy forms the cornerstone of safe, systematic fork management in the OSDU SPI Fork Management system. This architectural pattern provides controlled integration checkpoints that prevent cascade failures while enabling continuous upstream synchronization.</p>"},{"location":"architecture/three_branch_strategy/#branch-architecture","title":"Branch Architecture","text":"<pre><code>graph TD\n    A[Upstream Repository] --&gt; B[fork_upstream&lt;br/&gt;Mirror]\n    B --&gt; C[fork_integration&lt;br/&gt;Staging]  \n    C --&gt; D[main&lt;br/&gt;Production]\n\n    E[Local Development] --&gt; F[Feature Branches]\n    F --&gt; D\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style B fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style C fill:#fce4ec,stroke:#c2185b,stroke-width:2px\n    style D fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style E fill:#f3e5f5,stroke:#4a148c,stroke-width:2px\n    style F fill:#f3e5f5,stroke:#4a148c,stroke-width:2px</code></pre>"},{"location":"architecture/three_branch_strategy/#branch-purposes","title":"Branch Purposes","text":"<ul> <li> <p> <code>main</code> - Production Branch</p> <p>Stable production branch containing successfully integrated changes</p> <ul> <li>Maximum security with required PR reviews</li> <li>Production-ready Azure SPI implementations  </li> <li>Updates only through validated pull requests from <code>fork_integration</code></li> <li>All changes must pass comprehensive validation</li> </ul> </li> </ul> <ul> <li> <p> <code>fork_upstream</code> - Upstream Mirror</p> <p>Clean tracking of upstream OSDU repository without local modifications</p> <ul> <li>Automation-only updates to maintain purity</li> <li>Exact mirror of upstream repository state</li> <li>Automated synchronization from upstream repository</li> <li>Enables clear diff analysis and change detection</li> </ul> </li> </ul> <ul> <li> <p> <code>fork_integration</code> - Integration Workspace</p> <p>Dedicated space for conflict resolution and comprehensive validation</p> <ul> <li>Flexible protection for conflict resolution workflows</li> <li>Merge workspace for upstream changes with local modifications</li> <li>Automated merges from <code>fork_upstream</code> with conflict resolution</li> <li>Complete build, test, and security scanning before production</li> </ul> </li> </ul>"},{"location":"architecture/three_branch_strategy/#process-flow","title":"Process Flow","text":""},{"location":"architecture/three_branch_strategy/#synchronize","title":"Synchronize","text":"<pre><code>sequenceDiagram\n    participant U as Upstream Repo\n    participant FU as fork_upstream\n    participant S as Sync Workflow\n    participant SM as Sync State Manager\n    participant H as Human Reviewer\n\n    S-&gt;&gt;U: Fetch latest changes\n    S-&gt;&gt;SM: Check existing sync PRs and upstream SHA\n    SM-&gt;&gt;SM: Compare with stored last-sync state\n\n    alt New upstream changes, no existing PR\n        S-&gt;&gt;FU: Create new sync branch from fork_upstream\n        activate FU\n        S-&gt;&gt;S: Generate AI analysis\n        S-&gt;&gt;S: Create new sync PR and issue\n        S-&gt;&gt;H: Notify human reviewer\n    else Upstream advanced, existing PR open\n        S-&gt;&gt;FU: Update existing sync branch (force push)\n        S-&gt;&gt;S: Update PR title and description\n        S-&gt;&gt;S: Add progress comment to existing issue\n        S-&gt;&gt;H: Update notification on existing issue\n    else Duplicate detected (same upstream SHA)\n        S-&gt;&gt;S: Add reminder comment to existing issue\n        S-&gt;&gt;H: Gentle reminder notification\n    else No changes detected\n        S-&gt;&gt;S: Exit - no action needed\n    end\n\n    opt Human approval received\n        H-&gt;&gt;H: Review and approve\n        H-&gt;&gt;FU: Merge sync branch into fork_upstream\n        SM-&gt;&gt;SM: Update stored sync state\n        SM-&gt;&gt;SM: Cleanup completed sync artifacts\n        deactivate FU\n    end</code></pre> <p>Sync State Management</p> <p>The synchronization process includes intelligent duplicate prevention that maintains sync continuity. The Sync State Manager tracks upstream SHA, active PR numbers, and issue state between runs to prevent duplicate PRs and maintain human workflow continuity. When upstream advances while a PR is open, the existing branch is updated rather than creating duplicates.</p>"},{"location":"architecture/three_branch_strategy/#integrate","title":"Integrate","text":"<pre><code>sequenceDiagram\n    participant M as main\n    participant FU as fork_upstream\n    participant FI as fork_integration\n    participant C as Cascade Workflow\n    participant H as Human Reviewer\n\n    C-&gt;&gt;M: Check for local changes\n    M-&gt;&gt;FI: Merge main \u2192 fork_integration\n    activate FI\n    C-&gt;&gt;FU: Check for upstream updates\n    FU-&gt;&gt;FI: Merge fork_upstream \u2192 fork_integration\n    C-&gt;&gt;FI: Run validation suite\n    C-&gt;&gt;C: Create main PR\n\n    alt Validation Conflicts/Failures\n        C-&gt;&gt;C: Create conflict resolution issue\n        C-&gt;&gt;H: Notify about conflicts\n        H-&gt;&gt;FI: Push conflict resolution to fork_integration\n    end\n\n    C-&gt;&gt;FI: Run validation suite\n    C-&gt;&gt;H: Notify human reviewer\n    H-&gt;&gt;H: Review and approve\n    FI-&gt;&gt;M: Merge to main\n    deactivate FI</code></pre>"},{"location":"architecture/three_branch_strategy/#release","title":"Release","text":"<pre><code>sequenceDiagram\n    participant M as main\n    participant R as Release Workflow\n    participant H as Human Reviewer\n    participant DR as Downstream Repo\n\n    M-&gt;&gt;R: Push to main triggers release\n    R-&gt;&gt;R: Analyze commits for version bump\n    R-&gt;&gt;M: Create release branch with CHANGELOG.md\n    activate M\n    R-&gt;&gt;H: Create release PR\n    R-&gt;&gt;M: Run validation suite\n    H-&gt;&gt;H: Review and approve\n    H-&gt;&gt;M: Merge release branch into main\n    deactivate M\n    R-&gt;&gt;R: Create release &amp; tags\n\n    alt Downstream Consumption\n        DR-&gt;&gt;M: Pull desired release tag\n    end</code></pre>"},{"location":"architecture/three_branch_strategy/#safety-mechanisms","title":"Safety Mechanisms","text":""},{"location":"architecture/three_branch_strategy/#branch-protection-rules","title":"Branch Protection Rules","text":"Protection Setting main fork_upstream fork_integration Required Reviews 1 minimum Not required Not required Status Checks All workflows Not required Validation only Up-to-date Branch Required Not enforced Not enforced Force Push Blocked Allowed Allowed Human Access PR only Blocked Direct push"},{"location":"architecture/three_branch_strategy/#quality-gates","title":"Quality Gates","text":"<p>Integration Validation</p> <p>\u2713 Build Verification: Complete compilation and dependency resolution \u2713 Test Execution: Full test suite including integration tests \u2713 Security Scanning: Automated vulnerability and compliance checks \u2713 Code Quality: Linting and code quality metrics verification</p> <p>Production Validation</p> <p>\u26a0\ufe0f Human Review: Manual approval for all production changes \u26a0\ufe0f Impact Assessment: Analysis of changes to Azure SPI implementations \u26a0\ufe0f Rollback Planning: Verification of rollback procedures if needed \u26a0\ufe0f Documentation: Change documentation and release notes</p>"},{"location":"architecture/three_branch_strategy/#workflow-benefits","title":"Workflow Benefits","text":"<ul> <li> <p> Conflict Isolation</p> <p>Merge conflicts are resolved in the dedicated <code>fork_integration</code> branch, preventing disruption to the stable <code>main</code> branch during resolution.</p> </li> <li> <p> Clear Change Attribution</p> <p>Easy identification of what changes originate from upstream versus local Azure SPI modifications through clean branch separation.</p> </li> <li> <p> Multi-Stage Validation</p> <p>Multiple review and validation points ensure problematic changes are caught before reaching production systems.</p> </li> <li> <p> Upstream Tracking</p> <p>Pure upstream branch enables accurate diff analysis, change detection, and impact assessment for each synchronization.</p> </li> <li> <p> Rollback Capability</p> <p>Easy reversion of problematic integrations without losing upstream synchronization state or affecting ongoing development.</p> </li> <li> <p> Branch Preservation</p> <p>All three branches are permanently preserved, maintaining historical state for analysis and providing continuous availability.</p> </li> </ul>"},{"location":"architecture/three_branch_strategy/#operational-patterns","title":"Operational Patterns","text":""},{"location":"architecture/three_branch_strategy/#daily-synchronization-cycle","title":"Daily Synchronization Cycle","text":"<p>Automated Processing:</p> <p> Step 1: Check Upstream - Daily automated check for new upstream changes Step 2: Sync Detection - AI-enhanced analysis of change scope and impact Step 3: Integration Attempt - Automated merge to integration branch Step 4: Validation Execution - Comprehensive testing and security scanning</p> <p>Human Intervention Points:</p> <p> Step 1: Conflict Resolution - Manual resolution when automated merge fails Step 2: Validation Review - Assessment of test results and security findings Step 3: Production Approval - Final authorization for changes to reach <code>main</code> Step 4: Release Coordination - Alignment with downstream system requirements</p>"},{"location":"architecture/three_branch_strategy/#emergency-procedures","title":"Emergency Procedures","text":""},{"location":"architecture/three_branch_strategy/#upstream-rollback","title":"Upstream Rollback","text":"<p>If upstream changes cause issues:</p> <ol> <li>Identify last known good state in <code>fork_upstream</code></li> <li>Create rollback branch from previous stable point</li> <li>Update <code>fork_integration</code> with rollback changes</li> <li>Execute normal validation and approval process</li> </ol>"},{"location":"architecture/three_branch_strategy/#production-hotfix","title":"Production Hotfix","text":"<p>For urgent Azure SPI fixes:</p> <ol> <li>Create hotfix branch from current <code>main</code></li> <li>Implement and test fix in isolation</li> <li>Fast-track through integration validation</li> <li>Deploy with minimal upstream integration delay</li> </ol> <p>Release Strategy</p> <p>For production deployments, temporary release branches (<code>release/upstream-YYYYMMDD-HHMMSS</code>) are created from <code>fork_integration</code> to <code>main</code>, allowing safe cleanup while preserving the three-branch core architecture.</p>"},{"location":"architecture/workflow_system/","title":"Workflow System Architecture","text":"<p>The OSDU SPI Fork Management system implements a sophisticated workflow architecture that separates template development concerns from fork production operations. This design enables scalable deployment across multiple fork instances while maintaining centralized template management.</p>"},{"location":"architecture/workflow_system/#workflow-architecture-pattern","title":"Workflow Architecture Pattern","text":""},{"location":"architecture/workflow_system/#template-workflows-separation","title":"Template-Workflows Separation","text":"<p>The system implements a clean separation between template development and fork production workflows:</p> <pre><code>graph TD\n    A[Template Repository] --&gt; B[.github/workflows/&lt;br/&gt;Template Development]\n    A --&gt; C[.github/template-workflows/&lt;br/&gt;Fork Production]\n\n    C --&gt; D[Fork Instance 1&lt;br/&gt;.github/workflows/]\n    C --&gt; E[Fork Instance 2&lt;br/&gt;.github/workflows/]\n    C --&gt; F[Fork Instance N&lt;br/&gt;.github/workflows/]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style B fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style C fill:#f3e5f5,stroke:#4a148c,stroke-width:2px\n    style D fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style E fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style F fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px</code></pre> <ul> <li> <p> Template Development Context</p> <p><code>.github/workflows/</code> - Template management and maintenance</p> <ul> <li>Repository initialization and bootstrap workflows</li> <li>Template testing and validation workflows</li> <li>Template versioning and release management</li> <li>Development CI/CD pipelines</li> </ul> </li> </ul> <ul> <li> <p> Fork Production Context</p> <p><code>.github/template-workflows/</code> - Production fork operations</p> <ul> <li>Upstream synchronization workflows</li> <li>Build and validation workflows  </li> <li>Release management for fork instances</li> <li>Monitoring and maintenance workflows</li> </ul> </li> </ul>"},{"location":"architecture/workflow_system/#core-workflow-categories","title":"Core Workflow Categories","text":""},{"location":"architecture/workflow_system/#synchronization-workflows","title":"Synchronization Workflows","text":"<ul> <li> <p> Daily Upstream Sync (<code>sync.yml</code>)</p> <p>AI powered daily synchronization with intelligent duplicate prevention that fetches upstream changes, analyzes them for conflicts, and creates integration PRs with conventional commit messages</p> <ul> <li>Trigger: Scheduled daily at midnight UTC with intelligent duplicate prevention</li> <li>State Management: Tracks sync state between runs to prevent duplicate PRs and issues</li> <li>Decision Logic: Updates existing branches when upstream advances, prevents duplicates for same SHA</li> <li>Integration: Three-branch safety pattern (fork_upstream \u2192 fork_integration \u2192 main)</li> <li>AI Features: Intelligent change analysis and conventional commit generation</li> <li>Conflict Handling: Automated detection with human-guided resolution</li> </ul> <p> Detailed spec</p> </li> </ul> <ul> <li> <p> Template Propagation (<code>sync-template.yml</code>)</p> <p>Distributes template improvements across multiple fork instances with selective synchronization and automated validation</p> <ul> <li>Trigger: Daily scheduled execution at 8 AM UTC</li> <li>Scope: Selective file synchronization based on configuration rules</li> <li>Safety: Automated testing and validation before deployment</li> <li>Scalability: Supports unlimited fork instances with consistent patterns</li> </ul> <p> Detailed spec</p> </li> </ul>"},{"location":"architecture/workflow_system/#validation-workflows","title":"Validation Workflows","text":"<ul> <li> <p> Pull Request Validation (<code>validate.yml</code>)</p> <p>Comprehensive quality assurance system that enforces code standards, verifies build integrity, and ensures consistency across all changes</p> <ul> <li>Quality Gates: Multi-phase validation pipeline with adaptive rules</li> <li>Scope: Commit format, branch naming, build verification, conflict detection</li> <li>Intelligence: Context-aware validation for different contribution types</li> <li>Feedback: Detailed status reporting with actionable developer guidance</li> </ul> <p> Detailed spec</p> </li> </ul> <ul> <li> <p> Dependabot Automation (<code>dependabot-validation.yml</code>)</p> <p>Automated dependency update validation with intelligent risk assessment and selective auto-merging for routine updates</p> <ul> <li>Automation: Validates and tests all Dependabot dependency updates</li> <li>Security: Comprehensive vulnerability assessment of new dependencies</li> <li>Intelligence: Risk-based auto-merging for low-impact updates</li> <li>Integration: Seamless coordination with main validation pipeline</li> </ul> <p> Detailed spec</p> </li> </ul>"},{"location":"architecture/workflow_system/#build-release-workflows","title":"Build &amp; Release Workflows","text":"<ul> <li> <p> Project Build (<code>build.yml</code>)</p> <p>Feature branch build verification with comprehensive testing, coverage analysis, and performance-optimized execution</p> <ul> <li>Focus: Rapid developer feedback for feature branch development</li> <li>Coverage: Unit tests, integration tests, and comprehensive quality metrics</li> <li>Performance: Intelligent caching and parallel execution strategies</li> <li>Support: Java/Maven projects with extensible patterns for other languages</li> </ul> <p> Detailed spec</p> </li> </ul> <ul> <li> <p> Semantic Release (<code>release.yml</code>)</p> <p>Automated semantic versioning with conventional commit analysis, changelog generation, and coordinated release distribution</p> <ul> <li>Versioning: Release Please integration with conventional commit standards</li> <li>Coordination: Upstream version tracking and alignment strategies</li> <li>Documentation: Automated changelog and release notes generation</li> <li>Distribution: Package publication and artifact management</li> </ul> <p> Detailed spec</p> </li> </ul>"},{"location":"architecture/workflow_system/#cascade-workflows","title":"Cascade Workflows","text":"<ul> <li> <p> Integration Cascade (<code>cascade.yml</code>)</p> <p>Multi-stage integration workflow that safely promotes changes through the three-branch strategy with comprehensive validation</p> <ul> <li>Flow: Systematic progression from fork_upstream \u2192 fork_integration \u2192 main</li> <li>Safety: Comprehensive testing and validation at each integration stage</li> <li>Flexibility: Manual execution with automated monitoring capabilities</li> <li>Tracking: Complete progress monitoring through GitHub Issues</li> </ul> <p> Detailed spec</p> </li> </ul> <ul> <li> <p> Cascade Monitoring (<code>cascade-monitor.yml</code>)</p> <p>Intelligent monitoring system that detects completed synchronizations and automatically triggers cascade operations with SLA management</p> <ul> <li>Detection: Automated monitoring for completed upstream synchronizations</li> <li>SLA Management: Ensures cascade operations meet timing requirements</li> <li>Escalation: Proactive alerts and notifications for overdue operations</li> <li>Recovery: Automatic retry mechanisms with intelligent backoff strategies</li> </ul> <p> Detailed spec</p> </li> </ul>"},{"location":"architecture/workflow_system/#ai-enhanced-integration-workflows","title":"AI Enhanced Integration Workflows","text":""},{"location":"architecture/workflow_system/#cross-platform-integration","title":"Cross-Platform Integration","text":"<p>AI Enhanced Extensions</p> <p>These workflows extend the core fork management system with AI-powered capabilities that bridge platforms and enhance developer productivity. They operate alongside the core workflows without disrupting the fundamental three-branch strategy.</p>"},{"location":"architecture/workflow_system/#workflow-event-architecture","title":"Workflow Event Architecture","text":""},{"location":"architecture/workflow_system/#event-driven-triggers","title":"Event-Driven Triggers","text":"<pre><code>graph LR\n    A[Schedule Events] --&gt; B[Workflow Triggers]\n    C[Repository Events] --&gt; B\n    D[Manual Events] --&gt; B\n\n    B --&gt; E[Sync Workflows]\n    B --&gt; F[Validation Workflows]\n    B --&gt; G[Build Workflows]\n    B --&gt; H[Cascade Workflows]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style C fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style D fill:#f3e5f5,stroke:#4a148c,stroke-width:2px</code></pre> Trigger Type Workflow Schedule/Event Description Scheduled Daily Sync <code>0 0 * * *</code> Midnight UTC upstream synchronization with duplicate prevention Scheduled Template Sync <code>0 8 * * *</code> Daily 8 AM UTC template updates with duplicate prevention Scheduled Monitoring <code>0 */6 * * *</code> 6-hour cascade monitoring Event-Based PR Validation PR creation/updates Validation workflows on pull requests Event-Based Cascade Trigger Issue creation Cascade triggering on sync completion Event-Based Build Push to main Build workflows on main branch updates Event-Based Release Tag creation Distribution workflows on releases Manual Emergency Sync On-demand Immediate upstream synchronization Manual Cascade Override On-demand Manual cascade operation initiation Manual Template Update On-demand Immediate template propagation Manual Validation Retry On-demand Re-execution of failed workflows"},{"location":"architecture/workflow_system/#workflow-integration-patterns","title":"Workflow Integration Patterns","text":""},{"location":"architecture/workflow_system/#ai-enhanced-automation","title":"AI-Enhanced Automation","text":"<ul> <li> <p> Azure OpenAI</p> <p>Primary AI provider with enterprise integration, Microsoft compliance features, and comprehensive reasoning capabilities</p> </li> <li> <p> OpenAI GPT-4</p> <p>Secondary AI provider providing comprehensive coverage and established performance baselines</p> </li> <li> <p> Claude (Anthropic)</p> <p>Third-tier AI provider for analysis and generation with advanced reasoning capabilities</p> </li> </ul> <p>AI-Powered Capabilities enhance every stage of the workflow system:</p> <ul> <li>Change Analysis: Intelligent assessment of upstream modifications</li> <li>Commit Generation: Conventional commit message creation</li> <li>PR Descriptions: Comprehensive pull request documentation</li> <li>Conflict Guidance: Step-by-step conflict resolution instructions</li> </ul>"},{"location":"architecture/workflow_system/#security-integration","title":"Security Integration","text":"<p>Security-First Approach</p> <p>All workflows integrate comprehensive security scanning and branch protection to ensure production stability and compliance.</p> <ul> <li> <p> Automated Security Scanning</p> <ul> <li>Trivy scanning for container and dependency vulnerabilities</li> <li>Secret detection and automated leak prevention</li> <li>GitHub security advisory integration</li> <li>Automated compliance rule validation</li> </ul> </li> <li> <p> Branch Protection Integration</p> <ul> <li>Required workflow completion before merge</li> <li>Mandatory human approval for production changes</li> <li>Prevention of unauthorized direct pushes</li> <li>Controlled override procedures for critical issues</li> </ul> </li> </ul>"},{"location":"architecture/workflow_system/#workflow-state-management","title":"Workflow State Management","text":""},{"location":"architecture/workflow_system/#issue-based-tracking","title":"Issue-Based Tracking","text":""},{"location":"architecture/workflow_system/#lifecycle-management","title":"Lifecycle Management","text":"<ul> <li>State Tracking: GitHub Issues for workflow state management</li> <li>Progress Updates: Automated status updates throughout workflow execution</li> <li>Error Reporting: Detailed failure analysis and resolution guidance</li> <li>Audit Trail: Complete record of all workflow operations</li> </ul>"},{"location":"architecture/workflow_system/#label-based-organization","title":"Label-Based Organization","text":"<ul> <li>Workflow Types: <code>upstream-sync</code>, <code>cascade-active</code>, <code>template-update</code></li> <li>Status Indicators: <code>in-progress</code>, <code>completed</code>, <code>requires-attention</code></li> <li>Priority Levels: <code>high-priority</code>, <code>critical</code>, <code>routine</code></li> <li>Assignment Strategy: <code>human-required</code> for manual intervention points</li> </ul>"},{"location":"architecture/workflow_system/#performance-optimization","title":"Performance Optimization","text":"<ul> <li> <p> Intelligent Caching</p> <ul> <li>Maven dependencies, Node modules, Docker layers</li> <li>Compiled assets and test results</li> <li>Upstream repository metadata</li> <li>Previously generated AI analysis results</li> </ul> </li> <li> <p> Resource Management</p> <ul> <li>Concurrent workflow execution where safe</li> <li>Intelligent scheduling to prevent resource contention</li> <li>Appropriate timeouts with graceful degradation</li> <li>Exponential backoff for transient failures</li> </ul> </li> </ul>"},{"location":"architecture/workflow_system/#workflow-extensibility","title":"Workflow Extensibility","text":""},{"location":"architecture/workflow_system/#custom-action-integration","title":"Custom Action Integration","text":""},{"location":"architecture/workflow_system/#reusable-actions","title":"Reusable Actions","text":"<ul> <li>Enhanced PR Creation: AI-powered pull request generation</li> <li>Java Build Status: Specialized build reporting for Maven projects</li> <li>Security Scanning: Standardized vulnerability assessment</li> <li>Notification Management: Intelligent alert distribution</li> </ul>"},{"location":"architecture/workflow_system/#extension-points","title":"Extension Points","text":"<ul> <li>Project Type Detection: Automatic workflow adaptation based on project type</li> <li>Custom Validation: Project-specific quality gates and testing</li> <li>Integration Hooks: External system integration capabilities</li> <li>Notification Customization: Flexible alert and reporting mechanisms</li> </ul>"},{"location":"workflows/build/","title":"Build and Test Workflow","text":"<p>The build and test workflow provides rapid feedback for developers by automatically building and testing code changes on feature branches. This workflow focuses specifically on giving developers immediate visibility into whether their changes compile correctly, pass existing tests, and maintain adequate code coverage before they submit pull requests for review.</p> <p>Unlike the more comprehensive validation workflow that runs on protected branches, the build workflow is optimized for speed and developer productivity. It runs in parallel with your development process, helping you catch issues early when they're easier and cheaper to fix. The workflow supports multiple project types and includes intelligent caching to minimize build times while maintaining thorough verification.</p>"},{"location":"workflows/build/#when-it-runs","title":"When It Runs","text":"<p>The build workflow activates during active development to provide continuous feedback:</p> <ul> <li>Feature branch pushes - Triggers on every commit to non-protected branches during development</li> <li>Pull request updates - Runs when a PR is created or updated to verify changes</li> <li>Manual trigger - Available via GitHub Actions tab for debugging build issues or testing configurations</li> </ul>"},{"location":"workflows/build/#what-happens","title":"What Happens","text":"<p>The workflow follows an optimized build and test process designed for rapid developer feedback:</p> <ol> <li>Environment setup - Configures the build environment with correct runtime versions and dependencies</li> <li>Dependency installation - Downloads and caches project dependencies to speed up subsequent builds</li> <li>Code compilation - Builds the project and immediately reports any compilation errors</li> <li>Test execution - Runs the full test suite with coverage analysis and performance monitoring</li> <li>Results reporting - Provides detailed feedback on build status, test results, and coverage metrics</li> </ol> <p>The workflow produces clear outcomes to help you understand the state of your changes: - Success: Build passes, all tests complete, and coverage meets or exceeds minimum thresholds - Failure: Build errors, test failures, or coverage drops below required minimum requirements</p>"},{"location":"workflows/build/#build-support","title":"Build Support","text":""},{"location":"workflows/build/#supported-project-types","title":"Supported Project Types","text":"<ul> <li>Java/Maven only - Detects Maven-based projects with <code>pom.xml</code> files</li> <li>Java 17 runtime - Uses Temurin distribution for consistent builds</li> <li>Community Maven repositories - Supports GitLab-hosted OSDU dependencies</li> </ul>"},{"location":"workflows/build/#build-features","title":"Build Features","text":"<ul> <li>Maven dependency caching - Speeds up builds by caching <code>.m2/repository</code></li> <li>JaCoCo coverage reporting - Generates detailed test coverage reports using JaCoCo plugin</li> <li>Community repository access - Authenticates with GitLab Maven repositories for OSDU dependencies</li> <li>Artifact storage - Saves test reports and coverage data for 30 days</li> </ul>"},{"location":"workflows/build/#when-you-need-to-act","title":"When You Need to Act","text":""},{"location":"workflows/build/#build-failures","title":"Build Failures","text":"<ul> <li>Red X on PR - Build failed, check details in Actions tab</li> <li>Email notifications - If configured for your repository</li> <li>Status badges - Build status indicators in README</li> </ul>"},{"location":"workflows/build/#coverage-issues","title":"Coverage Issues","text":"<ul> <li>Coverage dropped - New code lacks sufficient test coverage</li> <li>Threshold warnings - Coverage below required minimums</li> </ul>"},{"location":"workflows/build/#how-to-respond","title":"How to Respond","text":""},{"location":"workflows/build/#debug-build-failures","title":"Debug Build Failures","text":"<pre><code># Run build locally to reproduce\nmvn clean install\n\n# Check for common issues\nmvn dependency:analyze  # dependency conflicts\nmvn versions:display-dependency-updates  # outdated dependencies\n</code></pre>"},{"location":"workflows/build/#fix-test-failures","title":"Fix Test Failures","text":"<pre><code># Run tests locally\nmvn test\n\n# Run specific test class\nmvn test -Dtest=TestClassName\n\n# Run specific test method\nmvn test -Dtest=TestClassName#testMethodName\n</code></pre>"},{"location":"workflows/build/#improve-coverage","title":"Improve Coverage","text":"<pre><code># Generate coverage report locally\nmvn clean test org.jacoco:jacoco-maven-plugin:0.8.11:report\n\n# View coverage report\nopen target/site/jacoco/index.html\n\n# Add tests for uncovered code\n# Focus on critical paths and edge cases\n</code></pre>"},{"location":"workflows/build/#configuration","title":"Configuration","text":""},{"location":"workflows/build/#required-maven-configuration","title":"Required Maven Configuration","text":"<pre><code>&lt;!-- Required plugins for build workflow --&gt;\n&lt;plugin&gt;\n  &lt;groupId&gt;org.jacoco&lt;/groupId&gt;\n  &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;\n  &lt;version&gt;0.8.11&lt;/version&gt;\n&lt;/plugin&gt;\n</code></pre>"},{"location":"workflows/build/#community-repository-access","title":"Community Repository Access","text":"<pre><code>&lt;!-- Maven settings for GitLab OSDU dependencies --&gt;\n&lt;settings&gt;\n  &lt;servers&gt;\n    &lt;server&gt;\n      &lt;id&gt;gitlab-maven&lt;/id&gt;\n      &lt;configuration&gt;\n        &lt;token&gt;${env.COMMUNITY_MAVEN_TOKEN}&lt;/token&gt;\n      &lt;/configuration&gt;\n    &lt;/server&gt;\n  &lt;/servers&gt;\n&lt;/settings&gt;\n</code></pre>"},{"location":"workflows/build/#coverage-thresholds","title":"Coverage Thresholds","text":"Metric Minimum Target Line Coverage 80% 90% Branch Coverage 75% 85% Function Coverage 85% 95%"},{"location":"workflows/build/#performance","title":"Performance","text":""},{"location":"workflows/build/#build-times-typical","title":"Build Times (Typical)","text":"<ul> <li>Small projects - 2-5 minutes</li> <li>Medium projects - 5-10 minutes</li> <li>Large projects - 10-20 minutes</li> </ul>"},{"location":"workflows/build/#optimization-features","title":"Optimization Features","text":"<ul> <li>Incremental builds - Only rebuild changed components</li> <li>Dependency caching - Reuse cached dependencies across builds</li> <li>Parallel execution - Run tests in parallel when possible</li> </ul>"},{"location":"workflows/build/#troubleshooting","title":"Troubleshooting","text":"Issue Solution \"Dependencies not found\" Check pom.xml, clear cache \"Build timeout\" Reduce test scope or optimize build scripts \"Memory issues\" Increase heap size in build configuration \"Test flakiness\" Fix non-deterministic tests, add proper waits \"Coverage calculation errors\" Verify test configuration, check exclusions"},{"location":"workflows/build/#integration","title":"Integration","text":""},{"location":"workflows/build/#with-other-workflows","title":"With Other Workflows","text":"<ul> <li>Validation workflow - Uses build results for PR checks</li> <li>Release workflow - Requires successful builds for releases</li> <li>Security scanning - Runs after successful builds</li> </ul>"},{"location":"workflows/build/#artifact-handling","title":"Artifact Handling","text":"<ul> <li>Test reports - Stored for 30 days in GitHub Actions</li> <li>Coverage reports - Available as downloadable artifacts</li> <li>Build logs - Accessible via Actions tab for debugging</li> </ul>"},{"location":"workflows/build/#related","title":"Related","text":"<ul> <li>Validation Workflow - PR quality gates that use build results</li> <li>Java Build Action - Maven-specific build details</li> <li>Test Coverage Guidelines - Testing standards</li> </ul>"},{"location":"workflows/cascade/","title":"Cascade Integration Workflow","text":"<p>The cascade integration workflow is the second phase of the fork management process. It is responsible for safely moving synchronized upstream changes through your repository's three-branch hierarchy toward production. After an upstream synchronization PR has been merged into the <code>fork_upstream</code> branch, this workflow takes over to validate and integrate those changes into your main development branch.</p> <p>This workflow acts as a quality gate, running comprehensive validation including Maven builds, unit tests, and compatibility checks before allowing changes to reach your production <code>main</code> branch. It embodies a \"trust but verify\" approach - trusting that the upstream sync was correct, but verifying that the integration works properly with your fork's specific modifications and enhancements.</p> <p>The cascade process includes built-in safety mechanisms with a dedicated monitor workflow that runs every 6 hours to detect stalled sync PRs. If a sync PR has been merged but no cascade has been triggered within 6 hours, the monitor automatically starts the cascade process, ensuring synchronized changes never get stuck in the pipeline.</p>"},{"location":"workflows/cascade/#when-it-runs","title":"When It Runs","text":"<p>The cascade workflow operates on both manual and automatic triggers to ensure reliable integration:</p> <ul> <li>Manual trigger - You provide the sync issue number in the GitHub Actions tab after reviewing a sync PR</li> <li>Automatic trigger - The monitor system detects unhandled sync PRs after 6 hours and runs automatically</li> <li>Emergency manual - Can be run on-demand for any validated upstream changes that need immediate propagation</li> </ul>"},{"location":"workflows/cascade/#what-happens","title":"What Happens","text":"<p>The workflow follows a structured validation and integration process:</p> <ol> <li>Validates sync completion - Ensures the upstream sync PR was properly merged and prerequisites are met</li> <li>Creates integration branch - Merges changes from <code>fork_upstream</code> into <code>fork_integration</code> for testing</li> <li>Runs full validation - Executes comprehensive Maven build, unit tests, and integration compatibility checks</li> <li>Creates production PR - If all validation passes, opens a PR to merge changes into your <code>main</code> branch</li> <li>Provides status updates - Comments on the original sync issue with progress reports and next steps</li> </ol>"},{"location":"workflows/cascade/#three-branch-progression","title":"Three-Branch Progression","text":"<pre><code>flowchart LR\n    A[fork_upstream&lt;br/&gt;\u2705 Sync Merged] --&gt; B[fork_integration&lt;br/&gt;\ud83d\udd28 Build &amp; Test]\n    B --&gt; C{Validation&lt;br/&gt;Passes?}\n    C --&gt;|\u2705 Pass| D[main&lt;br/&gt;\ud83d\udccb Production PR]\n    C --&gt;|\u274c Fail| E[\ud83d\udea8 Failure Issue&lt;br/&gt;Human Fix Required]\n\n    style A fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style B fill:#fce4ec,stroke:#c2185b,stroke-width:2px\n    style D fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style E fill:#ffebee,stroke:#c62828,stroke-width:2px</code></pre> <p>The workflow produces clear outcomes to guide your next actions: - Success: A production-ready PR is created for final human review before merge to <code>main</code> - Failure: Validation errors reported with specific resolution steps and a dedicated failure issue</p>"},{"location":"workflows/cascade/#when-you-need-to-act","title":"When You Need to Act","text":""},{"location":"workflows/cascade/#automatic-triggers","title":"Automatic Triggers","text":"<ul> <li>Monitor alerts - Issue comments when 6-hour threshold reached</li> <li>Validation failures - PR created with specific errors to fix</li> </ul>"},{"location":"workflows/cascade/#manual-triggers-required","title":"Manual Triggers Required","text":"<ul> <li>After sync PR merge - Trigger cascade with sync issue number</li> <li>Integration conflicts - Resolve conflicts in <code>fork_integration</code> branch</li> <li>Production PR review - Final approval before merge to <code>main</code></li> </ul>"},{"location":"workflows/cascade/#how-to-respond","title":"How to Respond","text":""},{"location":"workflows/cascade/#manual-cascade-trigger","title":"Manual Cascade Trigger","text":"<ol> <li>Find sync issue number - From completed upstream sync</li> <li>Go to Actions \u2192 \"Cascade Integration\" workflow</li> <li>Click \"Run workflow\" \u2192 Enter issue number \u2192 Run</li> <li>Monitor progress - Watch for completion or error comments</li> </ol>"},{"location":"workflows/cascade/#handle-integration-conflicts","title":"Handle Integration Conflicts","text":"<pre><code># Checkout integration branch\ngit checkout fork_integration\ngit status  # See conflict files\n\n# Resolve conflicts\n# ... resolve using IDE or manual editing ...\n\n# Test and push\nmvn test\ngit add .\ngit commit -m \"resolve: integration conflicts\"\ngit push origin fork_integration\n</code></pre>"},{"location":"workflows/cascade/#review-production-pr","title":"Review Production PR","text":"<ol> <li>Validate changes - Ensure integration preserved your fork modifications</li> <li>Check test results - All validation must pass</li> <li>Approve and merge - Final step to production</li> </ol>"},{"location":"workflows/cascade/#configuration","title":"Configuration","text":"Setting Default Description Monitor Schedule Every 6 hours Automatic detection of stalled sync PRs Validation Process Maven build + tests Required validation before production PR Auto-merge Production Disabled Always requires human approval for <code>main</code> Integration Conflicts Manual resolution Human intervention required for conflicts Failure Handling Create dedicated issue Automatic issue creation with resolution steps"},{"location":"workflows/cascade/#troubleshooting","title":"Troubleshooting","text":"Issue Solution \"Invalid sync issue number\" Verify issue exists and is upstream sync type \"Sync PR not merged\" Complete upstream sync process first \"Integration conflicts\" Resolve conflicts in <code>fork_integration</code> branch \"Validation failed\" Check PR comments for specific test/build failures \"Production merge blocked\" Ensure all status checks pass"},{"location":"workflows/cascade/#safety-features","title":"Safety Features","text":"<ul> <li>Three-branch isolation - Failures don't affect <code>main</code> branch</li> <li>Comprehensive validation - Build, test, security, and quality gates</li> <li>Human approval gates - Production changes require explicit review</li> <li>Rollback capability - Can revert to previous stable state</li> <li>Complete audit trail - All actions logged in GitHub issues</li> </ul>"},{"location":"workflows/cascade/#related","title":"Related","text":"<ul> <li>Synchronization Workflow - Previous step in process</li> <li>Validation Workflow - Details on quality checks</li> <li>Three-Branch Strategy - Core architecture</li> </ul>"},{"location":"workflows/initialization/","title":"Repository Initialization Workflow","text":"<p>The repository initialization workflow transforms a newly created repository from the OSDU Azure SPI Management template into a fully functional fork management system. This workflow handles all the complex setup tasks automatically, including deploying the complete workflow suite, creating the three-branch architecture, configuring security settings, and validating that everything is working correctly before your team begins development.</p> <p>The initialization process is designed with a two-phase approach that separates the immediate user experience from the more time-consuming system configuration tasks. This ensures you get immediate feedback that setup has started successfully, while the detailed configuration work happens in the background without requiring you to wait or monitor the process.</p>"},{"location":"workflows/initialization/#when-it-runs","title":"When It Runs","text":"<p>The initialization workflow activates in several scenarios to ensure your repository is properly configured:</p> <ul> <li>Template creation - Automatically triggers when you create a new repository from this template</li> <li>Manual trigger - Available via GitHub Actions tab if setup needs to be rerun or troubleshooting is required</li> <li>Fork creation - Activates when forking an existing OSDU SPI repository to ensure proper configuration</li> </ul>"},{"location":"workflows/initialization/#what-happens","title":"What Happens","text":"<p>The initialization process unfolds in two coordinated phases designed to provide optimal user experience while ensuring thorough setup:</p>"},{"location":"workflows/initialization/#immediate-setup-phase-30-seconds","title":"Immediate Setup Phase (30 seconds)","text":"<p>The workflow immediately creates a setup issue that serves as a tracking mechanism for initialization progress, validates that all required template files are present and properly formatted, triggers the main configuration workflow to begin the detailed setup process, and provides immediate feedback through the setup issue so you know the process has started successfully.</p>"},{"location":"workflows/initialization/#full-configuration-phase-5-10-minutes","title":"Full Configuration Phase (5-10 minutes)","text":"<p>The comprehensive setup process deploys all workflow files including sync, cascade, build, validation, and release management workflows to your repository. It creates the essential <code>fork_upstream</code> and <code>fork_integration</code> branches that form the foundation of the three-branch architecture, applies branch protection rules and security settings to ensure safe collaboration, enables repository features like issues and discussions that support the fork management process, and validates the entire setup by running initial checks to confirm everything is functioning correctly.</p> <p>The initialization process produces clear outcomes to guide your next steps: - Success: Your repository is fully configured and ready for upstream synchronization and team development - Failure: The setup issue is updated with specific resolution steps and guidance for addressing any configuration problems</p>"},{"location":"workflows/initialization/#when-you-need-to-act","title":"When You Need to Act","text":""},{"location":"workflows/initialization/#required-configuration","title":"Required Configuration","text":"<ul> <li>Repository secrets - Must be configured before first sync</li> <li>Upstream repository - Must specify which repository to sync from</li> <li>Team permissions - Ensure team has appropriate access levels</li> </ul>"},{"location":"workflows/initialization/#optional-configuration","title":"Optional Configuration","text":"<ul> <li>AI providers - Configure API keys for enhanced PR descriptions</li> <li>Notifications - Set up issue/PR notifications for your team</li> <li>Custom labels - Add project-specific labels beyond defaults</li> </ul>"},{"location":"workflows/initialization/#how-to-respond","title":"How to Respond","text":""},{"location":"workflows/initialization/#complete-required-setup","title":"Complete Required Setup","text":"<ol> <li>Check setup issue - Look for repository configuration checklist</li> <li> <p>Configure secrets:    <pre><code>UPSTREAM_REPO_URL - Repository to sync from (required)\nGITHUB_TOKEN - Provided automatically\nAZURE_API_KEY - AI provider (optional)\nAZURE_API_BASE - Azure Foundry endpoint (optional)\nAZURE_API_VERSION - Azure API version (optional)\n</code></pre></p> </li> <li> <p>Verify branch protection - Ensure <code>main</code> branch is protected</p> </li> <li>Test initial sync - Run upstream sync workflow manually to verify setup</li> </ol>"},{"location":"workflows/initialization/#handle-setup-failures","title":"Handle Setup Failures","text":"<pre><code># Check workflow logs in Actions tab\n# Common issues and solutions:\n\n# Permission errors\n# - Ensure repository has Actions write permissions\n# - Check team has admin access to repository\n\n# Branch creation failures\n# - Verify default branch is 'main'\n# - Check for existing conflicting branches\n\n# Workflow deployment issues\n# - Ensure Actions are enabled in repository settings\n# - Verify no conflicting workflow files exist\n</code></pre>"},{"location":"workflows/initialization/#verify-successful-setup","title":"Verify Successful Setup","text":"<ol> <li>Check branches - Should have <code>main</code>, <code>fork_upstream</code>, <code>fork_integration</code></li> <li>Test workflows - All workflows should be visible in Actions tab</li> <li>Verify protection - Branch protection rules should be active</li> <li>Run sync test - Manual upstream sync should work without errors</li> </ol>"},{"location":"workflows/initialization/#repository-structure-created","title":"Repository Structure Created","text":""},{"location":"workflows/initialization/#branches","title":"Branches","text":"<ul> <li><code>main</code> - Your production branch (protected)</li> <li><code>fork_upstream</code> - Mirror of upstream repository</li> <li><code>fork_integration</code> - Integration and conflict resolution branch</li> </ul>"},{"location":"workflows/initialization/#workflows-installed","title":"Workflows Installed","text":"<ul> <li><code>sync.yml</code> - Daily upstream synchronization</li> <li><code>cascade.yml</code> - Three-branch integration process</li> <li><code>build.yml</code> - Build and test automation</li> <li><code>validate.yml</code> - PR quality gates</li> <li><code>release.yml</code> - Automated version management</li> </ul>"},{"location":"workflows/initialization/#security-configuration","title":"Security Configuration","text":"<ul> <li>Branch protection - Required PR reviews and status checks</li> <li>Action permissions - Appropriate workflow execution permissions</li> <li>Issue templates - Standardized issue reporting</li> <li>Security scanning - Dependabot and vulnerability detection</li> </ul>"},{"location":"workflows/initialization/#required-secrets","title":"Required Secrets","text":"Secret Purpose Required <code>UPSTREAM_REPO_URL</code> Repository to sync from \u2705 Yes <code>GITHUB_TOKEN</code> Automatically provided \u2705 Yes <code>AZURE_API_KEY</code> AI-enhanced PR descriptions \u274c Optional <code>AZURE_API_BASE</code> Azure Foundry endpoint \u274c Optional <code>AZURE_API_VERSION</code> Azure API version \u274c Optional"},{"location":"workflows/initialization/#troubleshooting","title":"Troubleshooting","text":"Issue Solution \"Setup issue not created\" Check Actions are enabled, rerun workflow \"Branch creation failed\" Verify default branch is 'main', check permissions \"Workflow deployment error\" Remove conflicting <code>.github/workflows/</code> files \"Protection rules failed\" Ensure admin access, check repository settings \"Initial sync fails\" Verify <code>UPSTREAM_REPO_URL</code> secret is correct"},{"location":"workflows/initialization/#post-setup-checklist","title":"Post-Setup Checklist","text":"<ul> <li> Setup issue closed successfully - Initialization completed without errors</li> <li> Three branches exist - <code>main</code>, <code>fork_upstream</code>, <code>fork_integration</code></li> <li> Workflows active - All 5 workflows visible in Actions tab</li> <li> Secrets configured - At minimum <code>UPSTREAM_REPO_URL</code> is set</li> <li> Protection enabled - <code>main</code> branch requires PR reviews</li> <li> Initial sync works - Manual upstream sync runs successfully</li> <li> Team permissions - Team has appropriate repository access</li> </ul>"},{"location":"workflows/initialization/#next-steps","title":"Next Steps","text":"<ol> <li>Configure upstream sync - Set <code>UPSTREAM_REPO_URL</code> to target repository</li> <li>Run first sync - Manually trigger upstream synchronization workflow</li> <li>Set up notifications - Configure team alerts for sync issues and PRs</li> <li>Review documentation - Read synchronization and cascade workflows</li> <li>Add team members - Invite collaborators with appropriate permissions</li> </ol>"},{"location":"workflows/initialization/#related","title":"Related","text":"<ul> <li>Synchronization Workflow - Next step after initialization</li> <li>Three-Branch Strategy - Branching architecture</li> <li>Security Setup - Security configuration details</li> </ul>"},{"location":"workflows/release/","title":"Release Management Workflow","text":"<p>The release management workflow automates the entire process of creating semantic versions and publishing releases for your fork, eliminating manual version management while ensuring consistent release practices. This workflow uses Google's Release Please tool to analyze your commit history, automatically determine appropriate version numbers, and generate professional changelogs that clearly communicate what changed between releases.</p> <p>The system maintains correlation between your fork releases and corresponding upstream OSDU versions, providing clear traceability for compliance and auditing purposes. This is particularly valuable in enterprise environments where you need to demonstrate exactly which upstream changes are included in each of your fork releases.</p>"},{"location":"workflows/release/#when-it-runs","title":"When It Runs","text":"<p>The release workflow operates on specific triggers to maintain consistent release cadence:</p> <ul> <li>Push to main - Automatically scans for conventional commits and creates release PRs when changes are pushed to main</li> <li>Release PR merge - Immediately publishes the new version and creates a GitHub release when a release PR is merged</li> <li>Manual trigger - Available on-demand via GitHub Actions for urgent releases or troubleshooting</li> </ul>"},{"location":"workflows/release/#what-happens","title":"What Happens","text":"<p>The release process unfolds in two distinct phases, each handling different aspects of version management:</p>"},{"location":"workflows/release/#release-pr-creation-phase","title":"Release PR Creation Phase","text":"<p>The workflow begins by scanning your commit history to analyze conventional commits that have been made since the last release, then calculates the appropriate version bump (major, minor, or patch) based on the types of changes detected. It generates a structured changelog that categorizes changes by type and impact, then creates a release PR containing all version updates and changelog modifications.</p>"},{"location":"workflows/release/#release-publication-phase","title":"Release Publication Phase","text":"<p>Once the release PR is reviewed and merged, the workflow immediately creates a git tag with the new version number, publishes a GitHub release using the generated changelog as release notes, triggers any additional workflows configured for artifact publishing or distribution, and sends notifications to configured channels to alert the team about the new release.</p>"},{"location":"workflows/release/#version-calculation","title":"Version Calculation","text":"<p>Release Please automatically determines version bumps based on conventional commit prefixes:</p> Commit Type Version Impact Example <code>feat:</code> Minor (0.1.0) New features or capabilities <code>fix:</code> Patch (0.0.1) Bug fixes and corrections <code>BREAKING CHANGE:</code> Major (1.0.0) Breaking changes or API changes <code>chore:</code>, <code>docs:</code> No bump Maintenance, documentation"},{"location":"workflows/release/#breaking-changes","title":"Breaking Changes","text":"<pre><code># Triggers major version bump\nfeat!: redesign user authentication API\n\n# Or in commit body\nfeat: add new auth system\n\nBREAKING CHANGE: Authentication API completely redesigned\n</code></pre>"},{"location":"workflows/release/#when-you-need-to-act","title":"When You Need to Act","text":""},{"location":"workflows/release/#review-release-prs","title":"Review Release PRs","text":"<ul> <li>New release PR created - Review version bump and changelog accuracy</li> <li>Upstream correlation - Verify relationship to upstream versions</li> <li>Quality validation - Ensure all tests pass before merge</li> </ul>"},{"location":"workflows/release/#handle-failed-releases","title":"Handle Failed Releases","text":"<ul> <li>Version conflicts - Resolve tag conflicts or duplicate versions</li> <li>Changelog issues - Fix formatting or missing information</li> <li>Publication failures - Debug artifact publishing problems</li> </ul>"},{"location":"workflows/release/#how-to-respond","title":"How to Respond","text":""},{"location":"workflows/release/#review-release-pr","title":"Review Release PR","text":"<ol> <li>Check version bump - Verify appropriate version increase</li> <li>Review changelog - Ensure all important changes are documented</li> <li>Validate correlation - Confirm upstream version relationship</li> <li>Approve and merge - Release will be published automatically</li> </ol>"},{"location":"workflows/release/#fix-version-issues","title":"Fix Version Issues","text":"<pre><code># If wrong version was released\ngit tag -d v1.2.3  # Delete local tag\ngit push --delete origin v1.2.3  # Delete remote tag\n\n# Manually trigger new release\n# Go to Actions \u2192 Release Please \u2192 Run workflow\n</code></pre>"},{"location":"workflows/release/#update-changelog-manually","title":"Update Changelog Manually","text":"<pre><code># Edit CHANGELOG.md if needed\ngit checkout release-please--branches--main\n# Make edits to CHANGELOG.md\ngit add CHANGELOG.md\ngit commit -m \"docs: update changelog format\"\ngit push\n</code></pre>"},{"location":"workflows/release/#configuration","title":"Configuration","text":""},{"location":"workflows/release/#supported-project-types","title":"Supported Project Types","text":"<ul> <li>Node.js - Updates <code>package.json</code> version</li> <li>Java/Maven - Updates <code>pom.xml</code> version numbers</li> <li>Python - Updates <code>setup.py</code> or <code>pyproject.toml</code></li> <li>Multi-project - Handles multiple packages in monorepos</li> </ul>"},{"location":"workflows/release/#release-configuration","title":"Release Configuration","text":"<p>Located in <code>.release-please-config.json</code>: <pre><code>{\n  \"release-type\": \"simple\",\n  \"changelog-sections\": [\n    {\"type\": \"feat\", \"section\": \"Features\"},\n    {\"type\": \"fix\", \"section\": \"Bug Fixes\"},\n    {\"type\": \"chore\", \"section\": \"Miscellaneous\", \"hidden\": true}\n  ]\n}\n</code></pre></p>"},{"location":"workflows/release/#upstream-correlation","title":"Upstream Correlation","text":""},{"location":"workflows/release/#version-tracking","title":"Version Tracking","text":"<p>Each release maintains correlation with upstream versions through: - Release notes - Document corresponding upstream version - Git tags - Include upstream SHA reference - Changelog entries - Note upstream integration points</p>"},{"location":"workflows/release/#example-correlation","title":"Example Correlation","text":"<pre><code>## [1.2.3] - 2025-01-15\n\n### Features\n- Updated from upstream OSDU v1.5.2 (commit: abc123)\n- Added Azure-specific authentication improvements\n</code></pre>"},{"location":"workflows/release/#troubleshooting","title":"Troubleshooting","text":"Issue Solution \"No release PR created\" Ensure conventional commits exist since last release \"Version calculation wrong\" Check commit message format, use <code>feat!:</code> for breaking \"Changelog missing entries\" Verify commit messages follow conventional format \"Release failed\" Check GitHub release permissions and tag conflicts \"Correlation tracking missing\" Update release notes with upstream version info"},{"location":"workflows/release/#best-practices","title":"Best Practices","text":""},{"location":"workflows/release/#commit-messages","title":"Commit Messages","text":"<pre><code># Good - triggers minor version\nfeat: add user preference management\n\n# Good - triggers patch version\nfix: resolve authentication timeout issue\n\n# Good - triggers major version\nfeat!: redesign storage API interface\n\n# Bad - no version bump\nupdate some stuff\n</code></pre>"},{"location":"workflows/release/#release-timing","title":"Release Timing","text":"<ul> <li>Regular schedule - Let Release Please run daily for consistency</li> <li>Emergency releases - Manual trigger for critical fixes</li> <li>Coordination - Align with upstream release cycles when possible</li> </ul>"},{"location":"workflows/release/#integration","title":"Integration","text":""},{"location":"workflows/release/#with-osdu-ecosystem","title":"With OSDU Ecosystem","text":"<ul> <li>Upstream tracking - Correlate with upstream OSDU version releases</li> <li>Dependency updates - Coordinate with other OSDU service updates</li> <li>Testing integration - Ensure releases work with OSDU platform versions</li> </ul>"},{"location":"workflows/release/#automation-triggers","title":"Automation Triggers","text":"<ul> <li>Build workflows - Triggered by new tags for artifact publishing</li> <li>Deployment workflows - Can be triggered by release events</li> <li>Notification systems - Team alerts for new releases</li> </ul>"},{"location":"workflows/release/#related","title":"Related","text":"<ul> <li>Conventional Commits - Commit message standards</li> <li>Release Please - Official documentation</li> <li>Semantic Versioning - Version numbering standards</li> </ul>"},{"location":"workflows/synchronization/","title":"Upstream Synchronization Workflow","text":"<p>The upstream synchronization workflow is the cornerstone of the fork management system, automatically keeping your repository synchronized with changes from the upstream OSDU repository. This workflow runs daily to detect new commits, bug fixes, and features from upstream. It then intelligently integrates them into your fork using a safe three-branch strategy.</p> <p>The workflow includes sophisticated duplicate prevention that avoids creating multiple PRs for the same upstream state. When changes are detected, it either creates a new sync PR or updates an existing one, ensuring a clean workflow without PR proliferation. The system intelligently uses AI for change analysis on reasonably-sized diffs (under 20,000 lines) while falling back to standard templates for massive changes to avoid token limits.</p> <p>Both clean merges and conflicts are handled gracefully - clean changes get a straightforward PR ready for review, while conflicts are automatically packaged with detailed resolution guidance and marked for human attention.</p>"},{"location":"workflows/synchronization/#when-it-runs","title":"When It Runs","text":"<p>The synchronization workflow runs on multiple triggers to ensure your fork stays current:</p> <ul> <li>Daily at midnight UTC - Scheduled automatic sync to catch upstream changes</li> <li>Manual trigger - Run on-demand via the GitHub Actions tab when needed</li> <li>API trigger - Programmatically triggered via GitHub REST API for integrations</li> </ul>"},{"location":"workflows/synchronization/#what-happens","title":"What Happens","text":"<p>The workflow follows a systematic process to safely integrate upstream changes:</p> <ol> <li>Checks for upstream changes - Compares your fork with upstream repository to detect new commits</li> <li>Creates sync branch - If changes exist, creates a timestamped <code>sync/upstream-YYYYMMDD-HHMMSS</code> branch</li> <li>Generates PR - Creates pull request with AI-generated description analyzing the changes</li> <li>Creates tracking issue - Links to PR with <code>human-required</code> label for team visibility and coordination</li> <li>Waits for human review - Team reviews and merges PR to continue the cascade process</li> </ol>"},{"location":"workflows/synchronization/#smart-duplicate-prevention","title":"Smart Duplicate Prevention","text":"<p>The workflow uses intelligent state management to avoid creating duplicate sync PRs:</p> Situation Action Taken No existing PR + upstream changed Creates new PR and tracking issue Existing PR + upstream unchanged Adds reminder comment to existing PR Existing PR + upstream changed Updates existing PR with new changes No existing PR + upstream unchanged No action - exits cleanly <p>This prevents PR proliferation and maintains a clear workflow where only one sync PR exists at a time.</p>"},{"location":"workflows/synchronization/#workflow-outcomes","title":"Workflow Outcomes","text":"<pre><code>flowchart TD\n    A[Daily Sync Trigger] --&gt; B{Upstream Changes?}\n    B --&gt;|No| C[Exit - No Action Needed]\n    B --&gt;|Yes| D{Existing Sync PR?}\n    D --&gt;|No| E{Merge Conflicts?}\n    D --&gt;|Yes| F[Update Existing PR]\n    E --&gt;|No| G[Create Clean PR]\n    E --&gt;|Yes| H[Create Conflict PR]\n    G --&gt; I[AI Description &lt; 20k lines]\n    H --&gt; I\n    F --&gt; I\n    I --&gt; J[Ready for Human Review]</code></pre> <p>The workflow produces different outcomes based on what it discovers: - Clean merge: Creates a straightforward PR ready for review with no conflicts - Merge conflicts: Creates a PR with conflict markers and detailed step-by-step resolution instructions - Large changes: Uses standard templates instead of AI for diffs over 20,000 lines - Existing PR updates: Updates the existing sync PR rather than creating duplicates</p>"},{"location":"workflows/synchronization/#when-you-need-to-act","title":"When You Need to Act","text":"<p>Look for GitHub issues labeled <code>human-required</code> + <code>upstream-sync</code>:</p> <ul> <li>Clean sync - Review AI summary and merge PR if changes look safe</li> <li>Conflict sync - Resolve merge conflicts locally before merging</li> </ul>"},{"location":"workflows/synchronization/#how-to-respond","title":"How to Respond","text":""},{"location":"workflows/synchronization/#for-clean-syncs","title":"For Clean Syncs","text":"<ol> <li>Review the PR - Check AI-generated summary of upstream changes</li> <li>Verify compatibility - Ensure no breaking changes for your fork</li> <li>Merge PR - Approve and merge to <code>fork_upstream</code> branch</li> <li>Trigger cascade - Go to Actions \u2192 \"Cascade Integration\" \u2192 enter issue number \u2192 Run</li> </ol>"},{"location":"workflows/synchronization/#for-conflicts","title":"For Conflicts","text":"<ol> <li> <p>Checkout branch locally:    <pre><code>git checkout sync/upstream-YYYYMMDD-HHMMSS\ngit status  # See conflicted files\n</code></pre></p> </li> <li> <p>Resolve conflicts - Use your IDE's merge tools or edit manually</p> </li> <li> <p>Test and commit:    <pre><code># Test your changes\nnpm test  # or your project's test command\n\n# Commit resolution\ngit add .\ngit commit -m \"resolve: merge conflicts from upstream sync\"\ngit push\n</code></pre></p> </li> <li> <p>Complete PR - Request review, get approval, merge</p> </li> <li>Trigger cascade - Same as clean sync process</li> </ol>"},{"location":"workflows/synchronization/#configuration","title":"Configuration","text":"Setting Default Description Schedule <code>0 0 * * *</code> Daily at midnight UTC AI Provider Azure Foundry Primary AI for PR descriptions AI Diff Limit 20,000 lines Uses standard templates above this limit Duplicate Prevention Enabled Prevents multiple PRs for same upstream state Monitor Trigger 6 hours Auto-cascade if human trigger missed State Persistence Git config Tracks last sync state between runs"},{"location":"workflows/synchronization/#ai-configuration","title":"AI Configuration","text":"<p>To enable AI-generated PR descriptions, configure these secrets: - <code>AZURE_API_KEY</code> + <code>AZURE_API_BASE</code> (primary) - <code>OPENAI_API_KEY</code> (fallback) - <code>ANTHROPIC_API_KEY</code> (future use)</p>"},{"location":"workflows/synchronization/#troubleshooting","title":"Troubleshooting","text":"Issue Cause Solution \"No upstream changes detected\" Fork is current with upstream Normal - no action needed \"Failed to fetch upstream\" Network issues or incorrect URL Verify <code>UPSTREAM_REPO_URL</code> secret \"AI description generation failed\" API key issues or service down PR created with fallback template \"Large diff - using fallback template\" Changes exceed 20k lines Normal for major upstream updates \"Duplicate PR detected\" Existing sync PR found Updates existing PR instead \"Cascade not triggered\" Forgot to run manually Monitor auto-triggers after 6 hours \"Sync branch conflicts\" Upstream conflicts with fork changes Follow conflict resolution steps in PR"},{"location":"workflows/synchronization/#related","title":"Related","text":"<ul> <li>Three-Branch Strategy - Core branching approach</li> <li>Cascade Workflow - Next step after sync PR is merged</li> <li>Conflict Management - Detailed resolution guidance</li> </ul>"},{"location":"workflows/validation/","title":"Pull Request Validation Workflow","text":"<p>The pull request validation workflow acts as the automated quality gatekeeper for your repository. It ensures that all changes meet established standards before they can be merged into protected branches. This workflow runs comprehensive checks on every pull request and serves as your first line of defense against build failures, security vulnerabilities, and process violations that could disrupt your development workflow or compromise your fork's stability.</p> <p>The validation system is intelligent enough to apply different rules based on context - it treats upstream sync pull requests differently than regular development contributions, and applies stricter requirements to changes targeting your production <code>main</code> branch versus integration branches. This contextual awareness helps balance thorough quality control with practical workflow needs.</p>"},{"location":"workflows/validation/#when-it-runs","title":"When It Runs","text":"<p>The validation workflow activates automatically across multiple scenarios to maintain consistent quality standards:</p> <ul> <li>Every pull request to protected branches (<code>main</code>, <code>fork_integration</code>, <code>fork_upstream</code>) - Ensures all incoming changes meet quality standards</li> <li>Direct pushes to protected branches - Validates changes that bypass the PR process (when permitted)</li> <li>Manual trigger for post-initialization validation - Allows on-demand quality checks during setup or troubleshooting</li> </ul>"},{"location":"workflows/validation/#what-gets-validated","title":"What Gets Validated","text":"<p>The workflow performs comprehensive validation across three key areas to ensure both code quality and process compliance:</p>"},{"location":"workflows/validation/#code-quality-validation","title":"Code Quality Validation","text":"<p>The system verifies that your code is functional and maintainable by running build verification to ensure code compiles and all dependencies resolve correctly, executing the full test suite and generating coverage reports, and performing lint checks to enforce consistent code style and formatting standards.</p>"},{"location":"workflows/validation/#process-compliance-verification","title":"Process Compliance Verification","text":"<p>Beyond code quality, the workflow enforces development process standards by validating that commit messages follow conventional commit format for consistent release notes, checking that branch names follow established naming patterns, and detecting potential merge conflicts early in the development cycle.</p>"},{"location":"workflows/validation/#security-and-dependency-analysis","title":"Security and Dependency Analysis","text":"<p>The validation system includes security-focused checks that scan for known vulnerabilities in your dependencies, analyze package integrity to prevent supply chain attacks, and detect accidentally committed secrets or credentials in your code changes.</p>"},{"location":"workflows/validation/#validation-results","title":"Validation Results","text":""},{"location":"workflows/validation/#all-checks-pass","title":"\u2705 All Checks Pass","text":"<ul> <li>PR can be merged immediately</li> <li>No action required</li> </ul>"},{"location":"workflows/validation/#some-checks-fail","title":"\u26a0\ufe0f Some Checks Fail","text":"<ul> <li>PR blocked until issues resolved</li> <li>Check specific failure details in PR status</li> </ul>"},{"location":"workflows/validation/#critical-failures","title":"\u274c Critical Failures","text":"<ul> <li>Build errors, security issues, or policy violations</li> <li>Must be fixed before merge consideration</li> </ul>"},{"location":"workflows/validation/#how-to-fix-common-issues","title":"How to Fix Common Issues","text":""},{"location":"workflows/validation/#build-failures","title":"Build Failures","text":"<pre><code># Run build locally to debug\nmvn clean install\n\n# Check for missing dependencies\nmvn dependency:tree\n</code></pre>"},{"location":"workflows/validation/#commit-message-issues","title":"Commit Message Issues","text":"<pre><code># Fix last commit message\ngit commit --amend -m \"feat: add new feature description\"\n\n# For multiple commits, use interactive rebase\ngit rebase -i HEAD~3\n</code></pre>"},{"location":"workflows/validation/#test-failures","title":"Test Failures","text":"<pre><code># Run tests locally\nmvn test\n\n# Run specific test class\nmvn test -Dtest=TestClassName\n\n# Run with coverage report\nmvn test jacoco:report\n</code></pre>"},{"location":"workflows/validation/#security-vulnerabilities","title":"Security Vulnerabilities","text":"<pre><code># Check for vulnerabilities\nmvn dependency-check:check\n\n# Update dependencies to latest versions\nmvn versions:use-latest-versions\n\n# Display dependency updates available\nmvn versions:display-dependency-updates\n</code></pre>"},{"location":"workflows/validation/#merge-conflicts","title":"Merge Conflicts","text":"<pre><code># Update your branch with target branch\ngit fetch origin\ngit merge origin/main  # or target branch\n\n# Resolve conflicts in IDE\n# Then commit resolution\ngit add .\ngit commit -m \"resolve: merge conflicts with main\"\n</code></pre>"},{"location":"workflows/validation/#validation-jobs","title":"Validation Jobs","text":"<p>The workflow runs four distinct validation jobs:</p> Job Purpose What It Checks Initialization Check Verifies repository setup Ensures workflows are properly deployed Repository State Detects project type Identifies Java projects via <code>pom.xml</code> Java Build Compiles and tests Maven build, unit tests, dependency resolution Code Validation Process compliance Conventional commits, merge conflicts, branch status"},{"location":"workflows/validation/#branch-specific-rules","title":"Branch-Specific Rules","text":"<p>All protected branches use the same validation rules, with exemptions for specific PR types:</p> Branch Standard Validation Exemptions <code>main</code> All checks required + human approval None - strictest validation <code>fork_integration</code> All checks required None - full validation for integration safety <code>fork_upstream</code> All checks required Sync PRs skip conventional commit validation Feature branches N/A - not protected Standard PR validation when targeting protected branches"},{"location":"workflows/validation/#special-cases","title":"Special Cases","text":""},{"location":"workflows/validation/#sync-prs","title":"Sync PRs","text":"<ul> <li>Relaxed commit standards - Upstream commits may not follow conventions</li> <li>Conflict handling - Automatically creates resolution guidance</li> <li>AI enhancement - Generates PR descriptions when possible</li> </ul>"},{"location":"workflows/validation/#emergency-fixes","title":"Emergency Fixes","text":"<ul> <li>Override capability - Admin can bypass non-critical checks</li> <li>Audit trail required - Override reason must be documented</li> </ul>"},{"location":"workflows/validation/#status-check-details","title":"Status Check Details","text":""},{"location":"workflows/validation/#required-checks","title":"Required Checks","text":"<ul> <li><code>check-initialization</code> - Repository setup verification</li> <li><code>java-build</code> - Maven compilation, dependency resolution, unit tests</li> <li><code>code-validation</code> - Conventional commits, merge conflicts, branch status</li> </ul>"},{"location":"workflows/validation/#check-exemptions","title":"Check Exemptions","text":"<ul> <li>Sync PRs: Skip conventional commit validation (upstream commits may not follow format)</li> <li>Release PRs: Skip conventional commit validation (generated by release automation)</li> <li>Dependabot PRs: Reduced validation requirements for automated dependency updates</li> </ul>"},{"location":"workflows/validation/#troubleshooting","title":"Troubleshooting","text":"Issue Cause Solution \"Initialization check failed\" Repository not properly set up Ensure workflows are deployed and <code>pom.xml</code> exists \"Java build failed\" Compilation or dependency issues Run <code>mvn clean install</code> locally, check dependency conflicts \"Unit tests failing\" Test failures in Maven build Run <code>mvn test</code> locally, fix failing test cases \"Conventional commits validation failed\" Commit messages don't follow format Use format: <code>feat:</code>, <code>fix:</code>, <code>chore:</code>, etc. \"Merge conflicts detected\" Git conflict markers found Resolve conflicts locally and commit resolution \"Repository not initialized\" Missing required setup files Complete repository initialization first \"Branch status validation failed\" Branch protection or merge issues Ensure branch is up to date with target"},{"location":"workflows/validation/#configuration","title":"Configuration","text":""},{"location":"workflows/validation/#commit-message-format","title":"Commit Message Format","text":"<pre><code>type(scope): description\n\nfeat: add new feature\nfix: resolve bug in component\ndocs: update API documentation\nchore: update dependencies\n</code></pre>"},{"location":"workflows/validation/#coverage-thresholds","title":"Coverage Thresholds","text":"<ul> <li>Minimum coverage: 80%</li> <li>Branch coverage: 75%</li> <li>Function coverage: 85%</li> </ul>"},{"location":"workflows/validation/#related","title":"Related","text":"<ul> <li>Conventional Commits - Commit message standards</li> <li>Security Scanning - Security validation details</li> <li>Build Workflow - Detailed build process</li> </ul>"}]}